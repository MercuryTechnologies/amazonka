-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package amazonka-kinesis-video-archived-mediaZSamazonka-kinesis-video-archived-media
@version 1.6.1


module Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType
newtype ClipFragmentSelectorType
ClipFragmentSelectorType' :: Text -> ClipFragmentSelectorType
[fromClipFragmentSelectorType] :: ClipFragmentSelectorType -> Text
pattern ClipFragmentSelectorType_PRODUCER_TIMESTAMP :: ClipFragmentSelectorType
pattern ClipFragmentSelectorType_SERVER_TIMESTAMP :: ClipFragmentSelectorType
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelectorType.ClipFragmentSelectorType


module Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newClipTimestampRange</a> smart constructor.
data ClipTimestampRange
ClipTimestampRange' :: POSIX -> POSIX -> ClipTimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:ClipTimestampRange'] :: ClipTimestampRange -> POSIX

-- | The end of the timestamp range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:ClipTimestampRange'] :: ClipTimestampRange -> POSIX

-- | Create a value of <a>ClipTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_startTimestamp</a> - The starting timestamp in
--   the range of timestamps for which to return fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
--   
--   <a>$sel:endTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
newClipTimestampRange :: UTCTime -> UTCTime -> ClipTimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
clipTimestampRange_startTimestamp :: Lens' ClipTimestampRange UTCTime

-- | The end of the timestamp range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
clipTimestampRange_endTimestamp :: Lens' ClipTimestampRange UTCTime
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.ClipTimestampRange.ClipTimestampRange


module Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the clip will contain all of the fragments within the requested
--   timestamp range. If some fragments are ingested within the same time
--   range and very different points in time, only the oldest ingested
--   collection of fragments are returned.
--   
--   <i>See:</i> <a>newClipFragmentSelector</a> smart constructor.
data ClipFragmentSelector
ClipFragmentSelector' :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
[$sel:fragmentSelectorType:ClipFragmentSelector'] :: ClipFragmentSelector -> ClipFragmentSelectorType

-- | The range of timestamps to return.
[$sel:timestampRange:ClipFragmentSelector'] :: ClipFragmentSelector -> ClipTimestampRange

-- | Create a value of <a>ClipFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_timestampRange</a> - The range of timestamps
--   to return.
newClipFragmentSelector :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
clipFragmentSelector_fragmentSelectorType :: Lens' ClipFragmentSelector ClipFragmentSelectorType

-- | The range of timestamps to return.
clipFragmentSelector_timestampRange :: Lens' ClipFragmentSelector ClipTimestampRange
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.ClipFragmentSelector.ClipFragmentSelector


module Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat
newtype ContainerFormat
ContainerFormat' :: Text -> ContainerFormat
[fromContainerFormat] :: ContainerFormat -> Text
pattern ContainerFormat_FRAGMENTED_MP4 :: ContainerFormat
pattern ContainerFormat_MPEG_TS :: ContainerFormat
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.ContainerFormat.ContainerFormat


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber
newtype DASHDisplayFragmentNumber
DASHDisplayFragmentNumber' :: Text -> DASHDisplayFragmentNumber
[fromDASHDisplayFragmentNumber] :: DASHDisplayFragmentNumber -> Text
pattern DASHDisplayFragmentNumber_ALWAYS :: DASHDisplayFragmentNumber
pattern DASHDisplayFragmentNumber_NEVER :: DASHDisplayFragmentNumber
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentNumber.DASHDisplayFragmentNumber


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp
newtype DASHDisplayFragmentTimestamp
DASHDisplayFragmentTimestamp' :: Text -> DASHDisplayFragmentTimestamp
[fromDASHDisplayFragmentTimestamp] :: DASHDisplayFragmentTimestamp -> Text
pattern DASHDisplayFragmentTimestamp_ALWAYS :: DASHDisplayFragmentTimestamp
pattern DASHDisplayFragmentTimestamp_NEVER :: DASHDisplayFragmentTimestamp
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHDisplayFragmentTimestamp.DASHDisplayFragmentTimestamp


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType
newtype DASHFragmentSelectorType
DASHFragmentSelectorType' :: Text -> DASHFragmentSelectorType
[fromDASHFragmentSelectorType] :: DASHFragmentSelectorType -> Text
pattern DASHFragmentSelectorType_PRODUCER_TIMESTAMP :: DASHFragmentSelectorType
pattern DASHFragmentSelectorType_SERVER_TIMESTAMP :: DASHFragmentSelectorType
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelectorType.DASHFragmentSelectorType


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode
newtype DASHPlaybackMode
DASHPlaybackMode' :: Text -> DASHPlaybackMode
[fromDASHPlaybackMode] :: DASHPlaybackMode -> Text
pattern DASHPlaybackMode_LIVE :: DASHPlaybackMode
pattern DASHPlaybackMode_LIVE_REPLAY :: DASHPlaybackMode
pattern DASHPlaybackMode_ON_DEMAND :: DASHPlaybackMode
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHPlaybackMode.DASHPlaybackMode


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   The values in <tt>DASHimestampRange</tt> are inclusive. Fragments that
--   start exactly at or after the start time are included in the session.
--   Fragments that start before the start time and continue past it are
--   not included in the session.
--   
--   <i>See:</i> <a>newDASHTimestampRange</a> smart constructor.
data DASHTimestampRange
DASHTimestampRange' :: Maybe POSIX -> Maybe POSIX -> DASHTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:DASHTimestampRange'] :: DASHTimestampRange -> Maybe POSIX

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:DASHTimestampRange'] :: DASHTimestampRange -> Maybe POSIX

-- | Create a value of <a>DASHTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media. This value must be within 24 hours of
--   the specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newDASHTimestampRange :: DASHTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
dASHTimestampRange_endTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
dASHTimestampRange_startTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHTimestampRange.DASHTimestampRange


module Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newDASHFragmentSelector</a> smart constructor.
data DASHFragmentSelector
DASHFragmentSelector' :: Maybe DASHFragmentSelectorType -> Maybe DASHTimestampRange -> DASHFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
[$sel:fragmentSelectorType:DASHFragmentSelector'] :: DASHFragmentSelector -> Maybe DASHFragmentSelectorType

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
[$sel:timestampRange:DASHFragmentSelector'] :: DASHFragmentSelector -> Maybe DASHTimestampRange

-- | Create a value of <a>DASHFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newDASHFragmentSelector :: DASHFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
dASHFragmentSelector_fragmentSelectorType :: Lens' DASHFragmentSelector (Maybe DASHFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
dASHFragmentSelector_timestampRange :: Lens' DASHFragmentSelector (Maybe DASHTimestampRange)
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.DASHFragmentSelector.DASHFragmentSelector


module Network.AWS.KinesisVideoArchivedMedia.Types.Fragment

-- | Represents a segment of video or other time-delimited data.
--   
--   <i>See:</i> <a>newFragment</a> smart constructor.
data Fragment
Fragment' :: Maybe POSIX -> Maybe POSIX -> Maybe Text -> Maybe Integer -> Maybe Integer -> Fragment

-- | The timestamp from the producer corresponding to the fragment.
[$sel:producerTimestamp:Fragment'] :: Fragment -> Maybe POSIX

-- | The timestamp from the AWS server corresponding to the fragment.
[$sel:serverTimestamp:Fragment'] :: Fragment -> Maybe POSIX

-- | The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
[$sel:fragmentNumber:Fragment'] :: Fragment -> Maybe Text

-- | The total fragment size, including information about the fragment and
--   contained media data.
[$sel:fragmentSizeInBytes:Fragment'] :: Fragment -> Maybe Integer

-- | The playback duration or other time value associated with the
--   fragment.
[$sel:fragmentLengthInMilliseconds:Fragment'] :: Fragment -> Maybe Integer

-- | Create a value of <a>Fragment</a> with all optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:producerTimestamp:Fragment'</a>,
--   <a>fragment_producerTimestamp</a> - The timestamp from the producer
--   corresponding to the fragment.
--   
--   <a>$sel:serverTimestamp:Fragment'</a>, <a>fragment_serverTimestamp</a>
--   - The timestamp from the AWS server corresponding to the fragment.
--   
--   <a>$sel:fragmentNumber:Fragment'</a>, <a>fragment_fragmentNumber</a> -
--   The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
--   
--   <a>$sel:fragmentSizeInBytes:Fragment'</a>,
--   <a>fragment_fragmentSizeInBytes</a> - The total fragment size,
--   including information about the fragment and contained media data.
--   
--   <a>$sel:fragmentLengthInMilliseconds:Fragment'</a>,
--   <a>fragment_fragmentLengthInMilliseconds</a> - The playback duration
--   or other time value associated with the fragment.
newFragment :: Fragment

-- | The timestamp from the producer corresponding to the fragment.
fragment_producerTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The timestamp from the AWS server corresponding to the fragment.
fragment_serverTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
fragment_fragmentNumber :: Lens' Fragment (Maybe Text)

-- | The total fragment size, including information about the fragment and
--   contained media data.
fragment_fragmentSizeInBytes :: Lens' Fragment (Maybe Integer)

-- | The playback duration or other time value associated with the
--   fragment.
fragment_fragmentLengthInMilliseconds :: Lens' Fragment (Maybe Integer)
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.Fragment.Fragment


module Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType
newtype FragmentSelectorType
FragmentSelectorType' :: Text -> FragmentSelectorType
[fromFragmentSelectorType] :: FragmentSelectorType -> Text
pattern FragmentSelectorType_PRODUCER_TIMESTAMP :: FragmentSelectorType
pattern FragmentSelectorType_SERVER_TIMESTAMP :: FragmentSelectorType
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelectorType.FragmentSelectorType


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode
newtype HLSDiscontinuityMode
HLSDiscontinuityMode' :: Text -> HLSDiscontinuityMode
[fromHLSDiscontinuityMode] :: HLSDiscontinuityMode -> Text
pattern HLSDiscontinuityMode_ALWAYS :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_NEVER :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_ON_DISCONTINUITY :: HLSDiscontinuityMode
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSDiscontinuityMode.HLSDiscontinuityMode


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp
newtype HLSDisplayFragmentTimestamp
HLSDisplayFragmentTimestamp' :: Text -> HLSDisplayFragmentTimestamp
[fromHLSDisplayFragmentTimestamp] :: HLSDisplayFragmentTimestamp -> Text
pattern HLSDisplayFragmentTimestamp_ALWAYS :: HLSDisplayFragmentTimestamp
pattern HLSDisplayFragmentTimestamp_NEVER :: HLSDisplayFragmentTimestamp
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSDisplayFragmentTimestamp.HLSDisplayFragmentTimestamp


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType
newtype HLSFragmentSelectorType
HLSFragmentSelectorType' :: Text -> HLSFragmentSelectorType
[fromHLSFragmentSelectorType] :: HLSFragmentSelectorType -> Text
pattern HLSFragmentSelectorType_PRODUCER_TIMESTAMP :: HLSFragmentSelectorType
pattern HLSFragmentSelectorType_SERVER_TIMESTAMP :: HLSFragmentSelectorType
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelectorType.HLSFragmentSelectorType


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode
newtype HLSPlaybackMode
HLSPlaybackMode' :: Text -> HLSPlaybackMode
[fromHLSPlaybackMode] :: HLSPlaybackMode -> Text
pattern HLSPlaybackMode_LIVE :: HLSPlaybackMode
pattern HLSPlaybackMode_LIVE_REPLAY :: HLSPlaybackMode
pattern HLSPlaybackMode_ON_DEMAND :: HLSPlaybackMode
instance Network.AWS.Data.XML.ToXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.XML.FromXML Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.Headers.ToHeader Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.Log.ToLog Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.Text.ToText Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Network.AWS.Data.Text.FromText Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance GHC.Classes.Ord Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSPlaybackMode.HLSPlaybackMode


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   <i>See:</i> <a>newHLSTimestampRange</a> smart constructor.
data HLSTimestampRange
HLSTimestampRange' :: Maybe POSIX -> Maybe POSIX -> HLSTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:HLSTimestampRange'] :: HLSTimestampRange -> Maybe POSIX

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:HLSTimestampRange'] :: HLSTimestampRange -> Maybe POSIX

-- | Create a value of <a>HLSTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_endTimestamp</a> - The end of the timestamp range
--   for the requested media. This value must be within 24 hours of the
--   specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newHLSTimestampRange :: HLSTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
hLSTimestampRange_endTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
hLSTimestampRange_startTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSTimestampRange.HLSTimestampRange


module Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newHLSFragmentSelector</a> smart constructor.
data HLSFragmentSelector
HLSFragmentSelector' :: Maybe HLSFragmentSelectorType -> Maybe HLSTimestampRange -> HLSFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
[$sel:fragmentSelectorType:HLSFragmentSelector'] :: HLSFragmentSelector -> Maybe HLSFragmentSelectorType

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
[$sel:timestampRange:HLSFragmentSelector'] :: HLSFragmentSelector -> Maybe HLSTimestampRange

-- | Create a value of <a>HLSFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newHLSFragmentSelector :: HLSFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
hLSFragmentSelector_fragmentSelectorType :: Lens' HLSFragmentSelector (Maybe HLSFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
hLSFragmentSelector_timestampRange :: Lens' HLSFragmentSelector (Maybe HLSTimestampRange)
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.HLSFragmentSelector.HLSFragmentSelector


module Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newTimestampRange</a> smart constructor.
data TimestampRange
TimestampRange' :: POSIX -> POSIX -> TimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
[$sel:startTimestamp:TimestampRange'] :: TimestampRange -> POSIX

-- | The ending timestamp in the range of timestamps for which to return
--   fragments.
[$sel:endTimestamp:TimestampRange'] :: TimestampRange -> POSIX

-- | Create a value of <a>TimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:TimestampRange'</a>,
--   <a>timestampRange_startTimestamp</a> - The starting timestamp in the
--   range of timestamps for which to return fragments.
--   
--   <a>$sel:endTimestamp:TimestampRange'</a>,
--   <a>timestampRange_endTimestamp</a> - The ending timestamp in the range
--   of timestamps for which to return fragments.
newTimestampRange :: UTCTime -> UTCTime -> TimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_startTimestamp :: Lens' TimestampRange UTCTime

-- | The ending timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_endTimestamp :: Lens' TimestampRange UTCTime
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.TimestampRange.TimestampRange


module Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Only fragments with a start timestamp greater than or equal to the
--   given start time and less than or equal to the end time are returned.
--   For example, if a stream contains fragments with the following start
--   timestamps:
--   
--   <ul>
--   <li>00:00:00</li>
--   <li>00:00:02</li>
--   <li>00:00:04</li>
--   <li>00:00:06</li>
--   </ul>
--   
--   A fragment selector range with a start time of 00:00:01 and end time
--   of 00:00:04 would return the fragments with start times of 00:00:02
--   and 00:00:04.
--   
--   <i>See:</i> <a>newFragmentSelector</a> smart constructor.
data FragmentSelector
FragmentSelector' :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
[$sel:fragmentSelectorType:FragmentSelector'] :: FragmentSelector -> FragmentSelectorType

-- | The range of timestamps to return.
[$sel:timestampRange:FragmentSelector'] :: FragmentSelector -> TimestampRange

-- | Create a value of <a>FragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:FragmentSelector'</a>,
--   <a>fragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:FragmentSelector'</a>,
--   <a>fragmentSelector_timestampRange</a> - The range of timestamps to
--   return.
newFragmentSelector :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
fragmentSelector_fragmentSelectorType :: Lens' FragmentSelector FragmentSelectorType

-- | The range of timestamps to return.
fragmentSelector_timestampRange :: Lens' FragmentSelector TimestampRange
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.Types.FragmentSelector.FragmentSelector


module Network.AWS.KinesisVideoArchivedMedia.Types

-- | API version <tt>2017-09-30</tt> of the Amazon Kinesis Video Streams
--   Archived Media SDK configuration.
defaultService :: Service

-- | One or more frames in the requested clip could not be parsed based on
--   the specified codec.
_InvalidMediaFrameException :: AsError a => Getting (First ServiceError) a ServiceError

-- | Kinesis Video Streams has throttled the request because you have
--   exceeded a limit. Try making the call later. For information about
--   limits, see <a>Kinesis Video Streams Limits</a>.
_ClientLimitExceededException :: AsError a => Getting (First ServiceError) a ServiceError

-- | The codec private data in at least one of the tracks of the video
--   stream is not valid for this operation.
_InvalidCodecPrivateDataException :: AsError a => Getting (First ServiceError) a ServiceError

-- | A streaming session was requested for a stream that does not retain
--   data (that is, has a <tt>DataRetentionInHours</tt> of 0).
_NoDataRetentionException :: AsError a => Getting (First ServiceError) a ServiceError

-- | The type of the media (for example, h.264 or h.265 video or ACC or
--   G.711 audio) could not be determined from the codec IDs of the tracks
--   in the first fragment for a playback session. The codec ID for track 1
--   should be <tt>V_MPEG/ISO/AVC</tt> and, optionally, the codec ID for
--   track 2 should be <tt>A_AAC</tt>.
_UnsupportedStreamMediaTypeException :: AsError a => Getting (First ServiceError) a ServiceError

-- | <tt>GetMedia</tt> throws this error when Kinesis Video Streams can't
--   find the stream that you specified.
--   
--   <tt>GetHLSStreamingSessionURL</tt> and
--   <tt>GetDASHStreamingSessionURL</tt> throw this error if a session with
--   a <tt>PlaybackMode</tt> of <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>is requested for a stream that has no fragments
--   within the requested time range, or if a session with a
--   <tt>PlaybackMode</tt> of <tt>LIVE</tt> is requested for a stream that
--   has no fragments within the last 30 seconds.
_ResourceNotFoundException :: AsError a => Getting (First ServiceError) a ServiceError

-- | No codec private data was found in at least one of tracks of the video
--   stream.
_MissingCodecPrivateDataException :: AsError a => Getting (First ServiceError) a ServiceError

-- | Status Code: 403, The caller is not authorized to perform an operation
--   on the given stream, or the token has expired.
_NotAuthorizedException :: AsError a => Getting (First ServiceError) a ServiceError

-- | A specified parameter exceeds its restrictions, is not supported, or
--   can't be used.
_InvalidArgumentException :: AsError a => Getting (First ServiceError) a ServiceError
newtype ClipFragmentSelectorType
ClipFragmentSelectorType' :: Text -> ClipFragmentSelectorType
[fromClipFragmentSelectorType] :: ClipFragmentSelectorType -> Text
pattern ClipFragmentSelectorType_PRODUCER_TIMESTAMP :: ClipFragmentSelectorType
pattern ClipFragmentSelectorType_SERVER_TIMESTAMP :: ClipFragmentSelectorType
newtype ContainerFormat
ContainerFormat' :: Text -> ContainerFormat
[fromContainerFormat] :: ContainerFormat -> Text
pattern ContainerFormat_FRAGMENTED_MP4 :: ContainerFormat
pattern ContainerFormat_MPEG_TS :: ContainerFormat
newtype DASHDisplayFragmentNumber
DASHDisplayFragmentNumber' :: Text -> DASHDisplayFragmentNumber
[fromDASHDisplayFragmentNumber] :: DASHDisplayFragmentNumber -> Text
pattern DASHDisplayFragmentNumber_ALWAYS :: DASHDisplayFragmentNumber
pattern DASHDisplayFragmentNumber_NEVER :: DASHDisplayFragmentNumber
newtype DASHDisplayFragmentTimestamp
DASHDisplayFragmentTimestamp' :: Text -> DASHDisplayFragmentTimestamp
[fromDASHDisplayFragmentTimestamp] :: DASHDisplayFragmentTimestamp -> Text
pattern DASHDisplayFragmentTimestamp_ALWAYS :: DASHDisplayFragmentTimestamp
pattern DASHDisplayFragmentTimestamp_NEVER :: DASHDisplayFragmentTimestamp
newtype DASHFragmentSelectorType
DASHFragmentSelectorType' :: Text -> DASHFragmentSelectorType
[fromDASHFragmentSelectorType] :: DASHFragmentSelectorType -> Text
pattern DASHFragmentSelectorType_PRODUCER_TIMESTAMP :: DASHFragmentSelectorType
pattern DASHFragmentSelectorType_SERVER_TIMESTAMP :: DASHFragmentSelectorType
newtype DASHPlaybackMode
DASHPlaybackMode' :: Text -> DASHPlaybackMode
[fromDASHPlaybackMode] :: DASHPlaybackMode -> Text
pattern DASHPlaybackMode_LIVE :: DASHPlaybackMode
pattern DASHPlaybackMode_LIVE_REPLAY :: DASHPlaybackMode
pattern DASHPlaybackMode_ON_DEMAND :: DASHPlaybackMode
newtype FragmentSelectorType
FragmentSelectorType' :: Text -> FragmentSelectorType
[fromFragmentSelectorType] :: FragmentSelectorType -> Text
pattern FragmentSelectorType_PRODUCER_TIMESTAMP :: FragmentSelectorType
pattern FragmentSelectorType_SERVER_TIMESTAMP :: FragmentSelectorType
newtype HLSDiscontinuityMode
HLSDiscontinuityMode' :: Text -> HLSDiscontinuityMode
[fromHLSDiscontinuityMode] :: HLSDiscontinuityMode -> Text
pattern HLSDiscontinuityMode_ALWAYS :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_NEVER :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_ON_DISCONTINUITY :: HLSDiscontinuityMode
newtype HLSDisplayFragmentTimestamp
HLSDisplayFragmentTimestamp' :: Text -> HLSDisplayFragmentTimestamp
[fromHLSDisplayFragmentTimestamp] :: HLSDisplayFragmentTimestamp -> Text
pattern HLSDisplayFragmentTimestamp_ALWAYS :: HLSDisplayFragmentTimestamp
pattern HLSDisplayFragmentTimestamp_NEVER :: HLSDisplayFragmentTimestamp
newtype HLSFragmentSelectorType
HLSFragmentSelectorType' :: Text -> HLSFragmentSelectorType
[fromHLSFragmentSelectorType] :: HLSFragmentSelectorType -> Text
pattern HLSFragmentSelectorType_PRODUCER_TIMESTAMP :: HLSFragmentSelectorType
pattern HLSFragmentSelectorType_SERVER_TIMESTAMP :: HLSFragmentSelectorType
newtype HLSPlaybackMode
HLSPlaybackMode' :: Text -> HLSPlaybackMode
[fromHLSPlaybackMode] :: HLSPlaybackMode -> Text
pattern HLSPlaybackMode_LIVE :: HLSPlaybackMode
pattern HLSPlaybackMode_LIVE_REPLAY :: HLSPlaybackMode
pattern HLSPlaybackMode_ON_DEMAND :: HLSPlaybackMode

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the clip will contain all of the fragments within the requested
--   timestamp range. If some fragments are ingested within the same time
--   range and very different points in time, only the oldest ingested
--   collection of fragments are returned.
--   
--   <i>See:</i> <a>newClipFragmentSelector</a> smart constructor.
data ClipFragmentSelector
ClipFragmentSelector' :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
[$sel:fragmentSelectorType:ClipFragmentSelector'] :: ClipFragmentSelector -> ClipFragmentSelectorType

-- | The range of timestamps to return.
[$sel:timestampRange:ClipFragmentSelector'] :: ClipFragmentSelector -> ClipTimestampRange

-- | Create a value of <a>ClipFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_timestampRange</a> - The range of timestamps
--   to return.
newClipFragmentSelector :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
clipFragmentSelector_fragmentSelectorType :: Lens' ClipFragmentSelector ClipFragmentSelectorType

-- | The range of timestamps to return.
clipFragmentSelector_timestampRange :: Lens' ClipFragmentSelector ClipTimestampRange

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newClipTimestampRange</a> smart constructor.
data ClipTimestampRange
ClipTimestampRange' :: POSIX -> POSIX -> ClipTimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:ClipTimestampRange'] :: ClipTimestampRange -> POSIX

-- | The end of the timestamp range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:ClipTimestampRange'] :: ClipTimestampRange -> POSIX

-- | Create a value of <a>ClipTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_startTimestamp</a> - The starting timestamp in
--   the range of timestamps for which to return fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
--   
--   <a>$sel:endTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
newClipTimestampRange :: UTCTime -> UTCTime -> ClipTimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
clipTimestampRange_startTimestamp :: Lens' ClipTimestampRange UTCTime

-- | The end of the timestamp range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
clipTimestampRange_endTimestamp :: Lens' ClipTimestampRange UTCTime

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newDASHFragmentSelector</a> smart constructor.
data DASHFragmentSelector
DASHFragmentSelector' :: Maybe DASHFragmentSelectorType -> Maybe DASHTimestampRange -> DASHFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
[$sel:fragmentSelectorType:DASHFragmentSelector'] :: DASHFragmentSelector -> Maybe DASHFragmentSelectorType

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
[$sel:timestampRange:DASHFragmentSelector'] :: DASHFragmentSelector -> Maybe DASHTimestampRange

-- | Create a value of <a>DASHFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newDASHFragmentSelector :: DASHFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
dASHFragmentSelector_fragmentSelectorType :: Lens' DASHFragmentSelector (Maybe DASHFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
dASHFragmentSelector_timestampRange :: Lens' DASHFragmentSelector (Maybe DASHTimestampRange)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   The values in <tt>DASHimestampRange</tt> are inclusive. Fragments that
--   start exactly at or after the start time are included in the session.
--   Fragments that start before the start time and continue past it are
--   not included in the session.
--   
--   <i>See:</i> <a>newDASHTimestampRange</a> smart constructor.
data DASHTimestampRange
DASHTimestampRange' :: Maybe POSIX -> Maybe POSIX -> DASHTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:DASHTimestampRange'] :: DASHTimestampRange -> Maybe POSIX

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:DASHTimestampRange'] :: DASHTimestampRange -> Maybe POSIX

-- | Create a value of <a>DASHTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media. This value must be within 24 hours of
--   the specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newDASHTimestampRange :: DASHTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
dASHTimestampRange_endTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
dASHTimestampRange_startTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)

-- | Represents a segment of video or other time-delimited data.
--   
--   <i>See:</i> <a>newFragment</a> smart constructor.
data Fragment
Fragment' :: Maybe POSIX -> Maybe POSIX -> Maybe Text -> Maybe Integer -> Maybe Integer -> Fragment

-- | The timestamp from the producer corresponding to the fragment.
[$sel:producerTimestamp:Fragment'] :: Fragment -> Maybe POSIX

-- | The timestamp from the AWS server corresponding to the fragment.
[$sel:serverTimestamp:Fragment'] :: Fragment -> Maybe POSIX

-- | The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
[$sel:fragmentNumber:Fragment'] :: Fragment -> Maybe Text

-- | The total fragment size, including information about the fragment and
--   contained media data.
[$sel:fragmentSizeInBytes:Fragment'] :: Fragment -> Maybe Integer

-- | The playback duration or other time value associated with the
--   fragment.
[$sel:fragmentLengthInMilliseconds:Fragment'] :: Fragment -> Maybe Integer

-- | Create a value of <a>Fragment</a> with all optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:producerTimestamp:Fragment'</a>,
--   <a>fragment_producerTimestamp</a> - The timestamp from the producer
--   corresponding to the fragment.
--   
--   <a>$sel:serverTimestamp:Fragment'</a>, <a>fragment_serverTimestamp</a>
--   - The timestamp from the AWS server corresponding to the fragment.
--   
--   <a>$sel:fragmentNumber:Fragment'</a>, <a>fragment_fragmentNumber</a> -
--   The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
--   
--   <a>$sel:fragmentSizeInBytes:Fragment'</a>,
--   <a>fragment_fragmentSizeInBytes</a> - The total fragment size,
--   including information about the fragment and contained media data.
--   
--   <a>$sel:fragmentLengthInMilliseconds:Fragment'</a>,
--   <a>fragment_fragmentLengthInMilliseconds</a> - The playback duration
--   or other time value associated with the fragment.
newFragment :: Fragment

-- | The timestamp from the producer corresponding to the fragment.
fragment_producerTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The timestamp from the AWS server corresponding to the fragment.
fragment_serverTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
fragment_fragmentNumber :: Lens' Fragment (Maybe Text)

-- | The total fragment size, including information about the fragment and
--   contained media data.
fragment_fragmentSizeInBytes :: Lens' Fragment (Maybe Integer)

-- | The playback duration or other time value associated with the
--   fragment.
fragment_fragmentLengthInMilliseconds :: Lens' Fragment (Maybe Integer)

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Only fragments with a start timestamp greater than or equal to the
--   given start time and less than or equal to the end time are returned.
--   For example, if a stream contains fragments with the following start
--   timestamps:
--   
--   <ul>
--   <li>00:00:00</li>
--   <li>00:00:02</li>
--   <li>00:00:04</li>
--   <li>00:00:06</li>
--   </ul>
--   
--   A fragment selector range with a start time of 00:00:01 and end time
--   of 00:00:04 would return the fragments with start times of 00:00:02
--   and 00:00:04.
--   
--   <i>See:</i> <a>newFragmentSelector</a> smart constructor.
data FragmentSelector
FragmentSelector' :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
[$sel:fragmentSelectorType:FragmentSelector'] :: FragmentSelector -> FragmentSelectorType

-- | The range of timestamps to return.
[$sel:timestampRange:FragmentSelector'] :: FragmentSelector -> TimestampRange

-- | Create a value of <a>FragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:FragmentSelector'</a>,
--   <a>fragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:FragmentSelector'</a>,
--   <a>fragmentSelector_timestampRange</a> - The range of timestamps to
--   return.
newFragmentSelector :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | The origin of the timestamps to use (Server or Producer).
fragmentSelector_fragmentSelectorType :: Lens' FragmentSelector FragmentSelectorType

-- | The range of timestamps to return.
fragmentSelector_timestampRange :: Lens' FragmentSelector TimestampRange

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newHLSFragmentSelector</a> smart constructor.
data HLSFragmentSelector
HLSFragmentSelector' :: Maybe HLSFragmentSelectorType -> Maybe HLSTimestampRange -> HLSFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
[$sel:fragmentSelectorType:HLSFragmentSelector'] :: HLSFragmentSelector -> Maybe HLSFragmentSelectorType

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
[$sel:timestampRange:HLSFragmentSelector'] :: HLSFragmentSelector -> Maybe HLSTimestampRange

-- | Create a value of <a>HLSFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newHLSFragmentSelector :: HLSFragmentSelector

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
hLSFragmentSelector_fragmentSelectorType :: Lens' HLSFragmentSelector (Maybe HLSFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
hLSFragmentSelector_timestampRange :: Lens' HLSFragmentSelector (Maybe HLSTimestampRange)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   <i>See:</i> <a>newHLSTimestampRange</a> smart constructor.
data HLSTimestampRange
HLSTimestampRange' :: Maybe POSIX -> Maybe POSIX -> HLSTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
[$sel:endTimestamp:HLSTimestampRange'] :: HLSTimestampRange -> Maybe POSIX

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
[$sel:startTimestamp:HLSTimestampRange'] :: HLSTimestampRange -> Maybe POSIX

-- | Create a value of <a>HLSTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_endTimestamp</a> - The end of the timestamp range
--   for the requested media. This value must be within 24 hours of the
--   specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newHLSTimestampRange :: HLSTimestampRange

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
hLSTimestampRange_endTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
hLSTimestampRange_startTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newTimestampRange</a> smart constructor.
data TimestampRange
TimestampRange' :: POSIX -> POSIX -> TimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
[$sel:startTimestamp:TimestampRange'] :: TimestampRange -> POSIX

-- | The ending timestamp in the range of timestamps for which to return
--   fragments.
[$sel:endTimestamp:TimestampRange'] :: TimestampRange -> POSIX

-- | Create a value of <a>TimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:TimestampRange'</a>,
--   <a>timestampRange_startTimestamp</a> - The starting timestamp in the
--   range of timestamps for which to return fragments.
--   
--   <a>$sel:endTimestamp:TimestampRange'</a>,
--   <a>timestampRange_endTimestamp</a> - The ending timestamp in the range
--   of timestamps for which to return fragments.
newTimestampRange :: UTCTime -> UTCTime -> TimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_startTimestamp :: Lens' TimestampRange UTCTime

-- | The ending timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_endTimestamp :: Lens' TimestampRange UTCTime


-- | Returns a list of Fragment objects from the specified stream and
--   timestamp range within the archived data.
--   
--   Listing fragments is eventually consistent. This means that even if
--   the producer receives an acknowledgment that a fragment is persisted,
--   the result might not be returned immediately from a request to
--   <tt>ListFragments</tt>. However, results are typically available in
--   less than one second.
--   
--   You must first call the <tt>GetDataEndpoint</tt> API to get an
--   endpoint. Then send the <tt>ListFragments</tt> requests to this
--   endpoint using the <a>--endpoint-url parameter</a>.
--   
--   If an error is thrown after invoking a Kinesis Video Streams archived
--   media API, in addition to the HTTP status code and the response body,
--   it includes the following pieces of information:
--   
--   <ul>
--   <li><tt>x-amz-ErrorType</tt> HTTP header – contains a more specific
--   error type in addition to what the HTTP status code provides.</li>
--   <li><tt>x-amz-RequestId</tt> HTTP header – if you want to report an
--   issue to AWS, the support team can better diagnose the problem if
--   given the Request Id.</li>
--   </ul>
--   
--   Both the HTTP status code and the ErrorType header can be utilized to
--   make programmatic decisions about whether errors are retry-able and
--   under what conditions, as well as provide information on what actions
--   the client programmer might need to take in order to successfully try
--   again.
--   
--   For more information, see the <b>Errors</b> section at the bottom of
--   this topic, as well as <a>Common Errors</a>.
--   
--   This operation returns paginated results.
module Network.AWS.KinesisVideoArchivedMedia.ListFragments

-- | <i>See:</i> <a>newListFragments</a> smart constructor.
data ListFragments
ListFragments' :: Maybe Text -> Maybe Natural -> Maybe Text -> Maybe Text -> Maybe FragmentSelector -> ListFragments

-- | A token to specify where to start paginating. This is the
--   ListFragmentsOutput$NextToken from a previously truncated response.
[$sel:nextToken:ListFragments'] :: ListFragments -> Maybe Text

-- | The total number of fragments to return. If the total number of
--   fragments available is more than the value specified in
--   <tt>max-results</tt>, then a ListFragmentsOutput$NextToken is provided
--   in the output that you can use to resume pagination.
[$sel:maxResults:ListFragments'] :: ListFragments -> Maybe Natural

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve a
--   fragment list. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
[$sel:streamARN:ListFragments'] :: ListFragments -> Maybe Text

-- | The name of the stream from which to retrieve a fragment list. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
[$sel:streamName:ListFragments'] :: ListFragments -> Maybe Text

-- | Describes the timestamp range and timestamp origin for the range of
--   fragments to return.
[$sel:fragmentSelector:ListFragments'] :: ListFragments -> Maybe FragmentSelector

-- | Create a value of <a>ListFragments</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:nextToken:ListFragments'</a>, <a>listFragments_nextToken</a> -
--   A token to specify where to start paginating. This is the
--   ListFragmentsOutput$NextToken from a previously truncated response.
--   
--   <a>$sel:maxResults:ListFragments'</a>, <a>listFragments_maxResults</a>
--   - The total number of fragments to return. If the total number of
--   fragments available is more than the value specified in
--   <tt>max-results</tt>, then a ListFragmentsOutput$NextToken is provided
--   in the output that you can use to resume pagination.
--   
--   <a>$sel:streamARN:ListFragments'</a>, <a>listFragments_streamARN</a> -
--   The Amazon Resource Name (ARN) of the stream from which to retrieve a
--   fragment list. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
--   
--   <a>$sel:streamName:ListFragments'</a>, <a>listFragments_streamName</a>
--   - The name of the stream from which to retrieve a fragment list.
--   Specify either this parameter or the <tt>StreamARN</tt> parameter.
--   
--   <a>$sel:fragmentSelector:ListFragments'</a>,
--   <a>listFragments_fragmentSelector</a> - Describes the timestamp range
--   and timestamp origin for the range of fragments to return.
newListFragments :: ListFragments

-- | A token to specify where to start paginating. This is the
--   ListFragmentsOutput$NextToken from a previously truncated response.
listFragments_nextToken :: Lens' ListFragments (Maybe Text)

-- | The total number of fragments to return. If the total number of
--   fragments available is more than the value specified in
--   <tt>max-results</tt>, then a ListFragmentsOutput$NextToken is provided
--   in the output that you can use to resume pagination.
listFragments_maxResults :: Lens' ListFragments (Maybe Natural)

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve a
--   fragment list. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
listFragments_streamARN :: Lens' ListFragments (Maybe Text)

-- | The name of the stream from which to retrieve a fragment list. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
listFragments_streamName :: Lens' ListFragments (Maybe Text)

-- | Describes the timestamp range and timestamp origin for the range of
--   fragments to return.
listFragments_fragmentSelector :: Lens' ListFragments (Maybe FragmentSelector)

-- | <i>See:</i> <a>newListFragmentsResponse</a> smart constructor.
data ListFragmentsResponse
ListFragmentsResponse' :: Maybe Text -> Maybe [Fragment] -> Int -> ListFragmentsResponse

-- | If the returned list is truncated, the operation returns this token to
--   use to retrieve the next page of results. This value is <tt>null</tt>
--   when there are no more results to return.
[$sel:nextToken:ListFragmentsResponse'] :: ListFragmentsResponse -> Maybe Text

-- | A list of archived Fragment objects from the stream that meet the
--   selector criteria. Results are in no specific order, even across
--   pages.
[$sel:fragments:ListFragmentsResponse'] :: ListFragmentsResponse -> Maybe [Fragment]

-- | The response's http status code.
[$sel:httpStatus:ListFragmentsResponse'] :: ListFragmentsResponse -> Int

-- | Create a value of <a>ListFragmentsResponse</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:nextToken:ListFragments'</a>,
--   <a>listFragmentsResponse_nextToken</a> - If the returned list is
--   truncated, the operation returns this token to use to retrieve the
--   next page of results. This value is <tt>null</tt> when there are no
--   more results to return.
--   
--   <a>$sel:fragments:ListFragmentsResponse'</a>,
--   <a>listFragmentsResponse_fragments</a> - A list of archived Fragment
--   objects from the stream that meet the selector criteria. Results are
--   in no specific order, even across pages.
--   
--   <a>$sel:httpStatus:ListFragmentsResponse'</a>,
--   <a>listFragmentsResponse_httpStatus</a> - The response's http status
--   code.
newListFragmentsResponse :: Int -> ListFragmentsResponse

-- | If the returned list is truncated, the operation returns this token to
--   use to retrieve the next page of results. This value is <tt>null</tt>
--   when there are no more results to return.
listFragmentsResponse_nextToken :: Lens' ListFragmentsResponse (Maybe Text)

-- | A list of archived Fragment objects from the stream that meet the
--   selector criteria. Results are in no specific order, even across
--   pages.
listFragmentsResponse_fragments :: Lens' ListFragmentsResponse (Maybe [Fragment])

-- | The response's http status code.
listFragmentsResponse_httpStatus :: Lens' ListFragmentsResponse Int
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragmentsResponse
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragmentsResponse
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragmentsResponse
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragmentsResponse
instance Network.AWS.Types.AWSRequest Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragmentsResponse
instance Network.AWS.Pager.AWSPager Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Network.AWS.Data.Headers.ToHeaders Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Network.AWS.Data.Path.ToPath Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.ListFragments.ListFragments


-- | Gets media for a list of fragments (specified by fragment number) from
--   the archived data in an Amazon Kinesis video stream.
--   
--   You must first call the <tt>GetDataEndpoint</tt> API to get an
--   endpoint. Then send the <tt>GetMediaForFragmentList</tt> requests to
--   this endpoint using the <a>--endpoint-url parameter</a>.
--   
--   For limits, see <a>Kinesis Video Streams Limits</a>.
--   
--   If an error is thrown after invoking a Kinesis Video Streams archived
--   media API, in addition to the HTTP status code and the response body,
--   it includes the following pieces of information:
--   
--   <ul>
--   <li><tt>x-amz-ErrorType</tt> HTTP header – contains a more specific
--   error type in addition to what the HTTP status code provides.</li>
--   <li><tt>x-amz-RequestId</tt> HTTP header – if you want to report an
--   issue to AWS, the support team can better diagnose the problem if
--   given the Request Id.</li>
--   </ul>
--   
--   Both the HTTP status code and the ErrorType header can be utilized to
--   make programmatic decisions about whether errors are retry-able and
--   under what conditions, as well as provide information on what actions
--   the client programmer might need to take in order to successfully try
--   again.
--   
--   For more information, see the <b>Errors</b> section at the bottom of
--   this topic, as well as <a>Common Errors</a>.
module Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList

-- | <i>See:</i> <a>newGetMediaForFragmentList</a> smart constructor.
data GetMediaForFragmentList
GetMediaForFragmentList' :: Maybe Text -> Maybe Text -> NonEmpty Text -> GetMediaForFragmentList

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve
--   fragment media. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
[$sel:streamARN:GetMediaForFragmentList'] :: GetMediaForFragmentList -> Maybe Text

-- | The name of the stream from which to retrieve fragment media. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
[$sel:streamName:GetMediaForFragmentList'] :: GetMediaForFragmentList -> Maybe Text

-- | A list of the numbers of fragments for which to retrieve media. You
--   retrieve these values with ListFragments.
[$sel:fragments:GetMediaForFragmentList'] :: GetMediaForFragmentList -> NonEmpty Text

-- | Create a value of <a>GetMediaForFragmentList</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:streamARN:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream from which to retrieve fragment media. Specify
--   either this parameter or the <tt>StreamName</tt> parameter.
--   
--   <a>$sel:streamName:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_streamName</a> - The name of the stream
--   from which to retrieve fragment media. Specify either this parameter
--   or the <tt>StreamARN</tt> parameter.
--   
--   <a>$sel:fragments:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_fragments</a> - A list of the numbers of
--   fragments for which to retrieve media. You retrieve these values with
--   ListFragments.
newGetMediaForFragmentList :: NonEmpty Text -> GetMediaForFragmentList

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve
--   fragment media. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
getMediaForFragmentList_streamARN :: Lens' GetMediaForFragmentList (Maybe Text)

-- | The name of the stream from which to retrieve fragment media. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
getMediaForFragmentList_streamName :: Lens' GetMediaForFragmentList (Maybe Text)

-- | A list of the numbers of fragments for which to retrieve media. You
--   retrieve these values with ListFragments.
getMediaForFragmentList_fragments :: Lens' GetMediaForFragmentList (NonEmpty Text)

-- | <i>See:</i> <a>newGetMediaForFragmentListResponse</a> smart
--   constructor.
data GetMediaForFragmentListResponse
GetMediaForFragmentListResponse' :: Maybe Text -> Int -> ResponseBody -> GetMediaForFragmentListResponse

-- | The content type of the requested media.
[$sel:contentType:GetMediaForFragmentListResponse'] :: GetMediaForFragmentListResponse -> Maybe Text

-- | The response's http status code.
[$sel:httpStatus:GetMediaForFragmentListResponse'] :: GetMediaForFragmentListResponse -> Int

-- | The payload that Kinesis Video Streams returns is a sequence of chunks
--   from the specified stream. For information about the chunks, see
--   <a>PutMedia</a>. The chunks that Kinesis Video Streams returns in the
--   <tt>GetMediaForFragmentList</tt> call also include the following
--   additional Matroska (MKV) tags:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
--   chunk.</li>
--   <li>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of
--   the fragment.</li>
--   <li>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp
--   of the fragment.</li>
--   </ul>
--   
--   The following tags will be included if an exception occurs:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that
--   threw the exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
--   exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
--   exception</li>
--   </ul>
[$sel:payload:GetMediaForFragmentListResponse'] :: GetMediaForFragmentListResponse -> ResponseBody

-- | Create a value of <a>GetMediaForFragmentListResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:contentType:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_contentType</a> - The content type
--   of the requested media.
--   
--   <a>$sel:httpStatus:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_httpStatus</a> - The response's
--   http status code.
--   
--   <a>$sel:payload:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_payload</a> - The payload that
--   Kinesis Video Streams returns is a sequence of chunks from the
--   specified stream. For information about the chunks, see
--   <a>PutMedia</a>. The chunks that Kinesis Video Streams returns in the
--   <tt>GetMediaForFragmentList</tt> call also include the following
--   additional Matroska (MKV) tags:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
--   chunk.</li>
--   <li>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of
--   the fragment.</li>
--   <li>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp
--   of the fragment.</li>
--   </ul>
--   
--   The following tags will be included if an exception occurs:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that
--   threw the exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
--   exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
--   exception</li>
--   </ul>
newGetMediaForFragmentListResponse :: Int -> ResponseBody -> GetMediaForFragmentListResponse

-- | The content type of the requested media.
getMediaForFragmentListResponse_contentType :: Lens' GetMediaForFragmentListResponse (Maybe Text)

-- | The response's http status code.
getMediaForFragmentListResponse_httpStatus :: Lens' GetMediaForFragmentListResponse Int

-- | The payload that Kinesis Video Streams returns is a sequence of chunks
--   from the specified stream. For information about the chunks, see
--   <a>PutMedia</a>. The chunks that Kinesis Video Streams returns in the
--   <tt>GetMediaForFragmentList</tt> call also include the following
--   additional Matroska (MKV) tags:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
--   chunk.</li>
--   <li>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of
--   the fragment.</li>
--   <li>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp
--   of the fragment.</li>
--   </ul>
--   
--   The following tags will be included if an exception occurs:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that
--   threw the exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
--   exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
--   exception</li>
--   </ul>
getMediaForFragmentListResponse_payload :: Lens' GetMediaForFragmentListResponse ResponseBody
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentListResponse
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentListResponse
instance Network.AWS.Types.AWSRequest Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Network.AWS.Data.Headers.ToHeaders Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Network.AWS.Data.Path.ToPath Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.GetMediaForFragmentList.GetMediaForFragmentList


-- | Retrieves an HTTP Live Streaming (HLS) URL for the stream. You can
--   then open the URL in a browser or media player to view the stream
--   contents.
--   
--   Both the <tt>StreamName</tt> and the <tt>StreamARN</tt> parameters are
--   optional, but you must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt> when invoking this API operation.
--   
--   An Amazon Kinesis video stream has the following requirements for
--   providing data through HLS:
--   
--   <ul>
--   <li>The media must contain h.264 or h.265 encoded video and,
--   optionally, AAC encoded audio. Specifically, the codec ID of track 1
--   should be <tt>V_MPEG/ISO/AVC</tt> (for h.264) or
--   <tt>V_MPEG/ISO/HEVC</tt> (for h.265). Optionally, the codec ID of
--   track 2 should be <tt>A_AAC</tt>.</li>
--   <li>Data retention must be greater than 0.</li>
--   <li>The video track of each fragment must contain codec private data
--   in the Advanced Video Coding (AVC) for H.264 format or HEVC for H.265
--   format (<a>MPEG-4 specification ISO/IEC 14496-15</a>). For information
--   about adapting stream data to a given format, see <a>NAL Adaptation
--   Flags</a>.</li>
--   <li>The audio track (if present) of each fragment must contain codec
--   private data in the AAC format (<a>AAC specification ISO/IEC
--   13818-7</a>).</li>
--   </ul>
--   
--   Kinesis Video Streams HLS sessions contain fragments in the fragmented
--   MPEG-4 form (also called fMP4 or CMAF) or the MPEG-2 form (also called
--   TS chunks, which the HLS specification also supports). For more
--   information about HLS fragment types, see the <a>HLS
--   specification</a>.
--   
--   The following procedure shows how to use HLS with Kinesis Video
--   Streams:
--   
--   <ol>
--   <li>Get an endpoint using <a>GetDataEndpoint</a>, specifying
--   <tt>GET_HLS_STREAMING_SESSION_URL</tt> for the <tt>APIName</tt>
--   parameter.</li>
--   <li>Retrieve the HLS URL using <tt>GetHLSStreamingSessionURL</tt>.
--   Kinesis Video Streams creates an HLS streaming session to be used for
--   accessing content in a stream using the HLS protocol.
--   <tt>GetHLSStreamingSessionURL</tt> returns an authenticated URL (that
--   includes an encrypted session token) for the session's HLS /master
--   playlist/ (the root resource needed for streaming with HLS).Don't
--   share or store this token where an unauthorized entity could access
--   it. The token provides access to the content of the stream. Safeguard
--   the token with the same measures that you would use with your AWS
--   credentials.The media that is made available through the playlist
--   consists only of the requested stream, time range, and format. No
--   other media data (such as frames outside the requested window or
--   alternate bitrates) is made available.</li>
--   <li>Provide the URL (containing the encrypted session token) for the
--   HLS master playlist to a media player that supports the HLS protocol.
--   Kinesis Video Streams makes the HLS media playlist, initialization
--   fragment, and media fragments available through the master playlist
--   URL. The initialization fragment contains the codec private data for
--   the stream, and other data needed to set up the video or audio decoder
--   and renderer. The media fragments contain H.264-encoded video frames
--   or AAC-encoded audio samples.</li>
--   <li>The media player receives the authenticated URL and requests
--   stream metadata and media data normally. When the media player
--   requests data, it calls the following
--   actions:<ul><li><b>GetHLSMasterPlaylist:</b> Retrieves an HLS master
--   playlist, which contains a URL for the <tt>GetHLSMediaPlaylist</tt>
--   action for each track, and additional metadata for the media player,
--   including estimated bitrate and
--   resolution.</li><li><b>GetHLSMediaPlaylist:</b> Retrieves an HLS media
--   playlist, which contains a URL to access the MP4 initialization
--   fragment with the <tt>GetMP4InitFragment</tt> action, and URLs to
--   access the MP4 media fragments with the <tt>GetMP4MediaFragment</tt>
--   actions. The HLS media playlist also contains metadata about the
--   stream that the player needs to play it, such as whether the
--   <tt>PlaybackMode</tt> is <tt>LIVE</tt> or <tt>ON_DEMAND</tt>. The HLS
--   media playlist is typically static for sessions with a
--   <tt>PlaybackType</tt> of <tt>ON_DEMAND</tt>. The HLS media playlist is
--   continually updated with new fragments for sessions with a
--   <tt>PlaybackType</tt> of <tt>LIVE</tt>. There is a distinct HLS media
--   playlist for the video track and the audio track (if applicable) that
--   contains MP4 media URLs for the specific
--   track.</li><li><b>GetMP4InitFragment:</b> Retrieves the MP4
--   initialization fragment. The media player typically loads the
--   initialization fragment before loading any media fragments. This
--   fragment contains the "<tt>fytp</tt>" and "<tt>moov</tt>" MP4 atoms,
--   and the child atoms that are needed to initialize the media player
--   decoder.The initialization fragment does not correspond to a fragment
--   in a Kinesis video stream. It contains only the codec private data for
--   the stream and respective track, which the media player needs to
--   decode the media frames.</li><li><b>GetMP4MediaFragment:</b> Retrieves
--   MP4 media fragments. These fragments contain the "<tt>moof</tt>" and
--   "<tt>mdat</tt>" MP4 atoms and their child atoms, containing the
--   encoded fragment's media frames and their timestamps.After the first
--   media fragment is made available in a streaming session, any fragments
--   that don't contain the same codec private data cause an error to be
--   returned when those different media fragments are loaded. Therefore,
--   the codec private data should not change between fragments in a
--   session. This also means that the session fails if the fragments in a
--   stream change from having only video to having both audio and
--   video.Data retrieved with this action is billable. See <a>Pricing</a>
--   for details.</li><li><b>GetTSFragment:</b> Retrieves MPEG TS fragments
--   containing both initialization and media data for all tracks in the
--   stream.If the <tt>ContainerFormat</tt> is <tt>MPEG_TS</tt>, this API
--   is used instead of <tt>GetMP4InitFragment</tt> and
--   <tt>GetMP4MediaFragment</tt> to retrieve stream media.Data retrieved
--   with this action is billable. For more information, see <a>Kinesis
--   Video Streams pricing</a>.</li></ul></li>
--   </ol>
--   
--   A streaming session URL must not be shared between players. The
--   service might throttle a session if multiple media players are sharing
--   it. For connection limits, see <a>Kinesis Video Streams Limits</a>.
--   
--   You can monitor the amount of data that the media player consumes by
--   monitoring the <tt>GetMP4MediaFragment.OutgoingBytes</tt> Amazon
--   CloudWatch metric. For information about using CloudWatch to monitor
--   Kinesis Video Streams, see <a>Monitoring Kinesis Video Streams</a>.
--   For pricing information, see <a>Amazon Kinesis Video Streams
--   Pricing</a> and <a>AWS Pricing</a>. Charges for both HLS sessions and
--   outgoing AWS data apply.
--   
--   For more information about HLS, see <a>HTTP Live Streaming</a> on the
--   <a>Apple Developer site</a>.
--   
--   If an error is thrown after invoking a Kinesis Video Streams archived
--   media API, in addition to the HTTP status code and the response body,
--   it includes the following pieces of information:
--   
--   <ul>
--   <li><tt>x-amz-ErrorType</tt> HTTP header – contains a more specific
--   error type in addition to what the HTTP status code provides.</li>
--   <li><tt>x-amz-RequestId</tt> HTTP header – if you want to report an
--   issue to AWS, the support team can better diagnose the problem if
--   given the Request Id.</li>
--   </ul>
--   
--   Both the HTTP status code and the ErrorType header can be utilized to
--   make programmatic decisions about whether errors are retry-able and
--   under what conditions, as well as provide information on what actions
--   the client programmer might need to take in order to successfully try
--   again.
--   
--   For more information, see the <b>Errors</b> section at the bottom of
--   this topic, as well as <a>Common Errors</a>.
module Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL

-- | <i>See:</i> <a>newGetHLSStreamingSessionURL</a> smart constructor.
data GetHLSStreamingSessionURL
GetHLSStreamingSessionURL' :: Maybe Natural -> Maybe ContainerFormat -> Maybe HLSDisplayFragmentTimestamp -> Maybe HLSPlaybackMode -> Maybe Text -> Maybe Text -> Maybe Natural -> Maybe HLSDiscontinuityMode -> Maybe HLSFragmentSelector -> GetHLSStreamingSessionURL

-- | The maximum number of fragments that are returned in the HLS media
--   playlists.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live HLS
--   media playlist, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live HLS media playlist have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 5,000 fragments corresponds to more than 80
--   minutes of video on streams with 1-second fragments, and more than 13
--   hours of video on streams with 10-second fragments.
[$sel:maxMediaPlaylistFragmentResults:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe Natural

-- | Specifies which format should be used for packaging the media.
--   Specifying the <tt>FRAGMENTED_MP4</tt> container format packages the
--   media into MP4 fragments (fMP4 or CMAF). This is the recommended
--   packaging because there is minimal packaging overhead. The other
--   container format option is <tt>MPEG_TS</tt>. HLS has supported MPEG TS
--   chunks since it was released and is sometimes the only supported
--   packaging on older HLS players. MPEG TS typically has a 5-25 percent
--   packaging overhead. This means MPEG TS typically requires 5-25 percent
--   more bandwidth and cost than fMP4.
--   
--   The default is <tt>FRAGMENTED_MP4</tt>.
[$sel:containerFormat:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe ContainerFormat

-- | Specifies when the fragment start timestamps should be included in the
--   HLS media playlist. Typically, media players report the playhead
--   position as a time relative to the start of the first fragment in the
--   playback session. However, when the start timestamps are included in
--   the HLS media playlist, some media players might report the current
--   playhead as an absolute time based on the fragment timestamps. This
--   can be useful for creating a playback experience that shows viewers
--   the wall-clock time of the media.
--   
--   The default is <tt>NEVER</tt>. When HLSFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when HLSFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
[$sel:displayFragmentTimestamp:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe HLSDisplayFragmentTimestamp

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the HLS media
--   playlist is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   playlist on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an HLS media playlist, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the HLS media
--   playlist if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the playlist, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the HLS
--   media playlist is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the media playlist every two
--   seconds. This mode is useful to be able to start playback from when an
--   event is detected and continue live streaming media that has not yet
--   been ingested as of the time of the session creation. This mode is
--   also useful to stream previously archived media without being limited
--   by the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the HLS
--   media playlist contains all the fragments for the session, up to the
--   number that is specified in <tt>MaxMediaPlaylistFragmentResults</tt>.
--   The playlist must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the largest fragment
--   number (that is, the newest fragment) is included in the HLS media
--   playlist. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the HLS media playlist. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
[$sel:playbackMode:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe HLSPlaybackMode

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
[$sel:streamARN:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe Text

-- | The name of the stream for which to retrieve the HLS master playlist
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
[$sel:streamName:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe Text

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetHLSMasterPlaylist</tt>,
--   <tt>GetHLSMediaPlaylist</tt>, <tt>GetMP4InitFragment</tt>,
--   <tt>GetMP4MediaFragment</tt>, or <tt>GetTSFragment</tt> can be made
--   for that session.
--   
--   The default is 300 (5 minutes).
[$sel:expires:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe Natural

-- | Specifies when flags marking discontinuities between fragments are
--   added to the media playlists.
--   
--   Media players typically build a timeline of media content to play,
--   based on the timestamps of each fragment. This means that if there is
--   any overlap or gap between fragments (as is typical if
--   HLSFragmentSelector is set to <tt>SERVER_TIMESTAMP</tt>), the media
--   player timeline will also have small gaps between fragments in some
--   places, and will overwrite frames in other places. Gaps in the media
--   player timeline can cause playback to stall and overlaps can cause
--   playback to be jittery. When there are discontinuity flags between
--   fragments, the media player is expected to reset the timeline,
--   resulting in the next fragment being played immediately after the
--   previous fragment.
--   
--   The following modes are supported:
--   
--   <ul>
--   <li><tt>ALWAYS</tt>: a discontinuity marker is placed between every
--   fragment in the HLS media playlist. It is recommended to use a value
--   of <tt>ALWAYS</tt> if the fragment timestamps are not accurate.</li>
--   <li><tt>NEVER</tt>: no discontinuity markers are placed anywhere. It
--   is recommended to use a value of <tt>NEVER</tt> to ensure the media
--   player timeline most accurately maps to the producer timestamps.</li>
--   <li><tt>ON_DISCONTINUITY</tt>: a discontinuity marker is placed
--   between fragments that have a gap or overlap of more than 50
--   milliseconds. For most playback scenarios, it is recommended to use a
--   value of <tt>ON_DISCONTINUITY</tt> so that the media player timeline
--   is only reset when there is a significant issue with the media
--   timeline (e.g. a missing fragment).</li>
--   </ul>
--   
--   The default is <tt>ALWAYS</tt> when HLSFragmentSelector is set to
--   <tt>SERVER_TIMESTAMP</tt>, and <tt>NEVER</tt> when it is set to
--   <tt>PRODUCER_TIMESTAMP</tt>.
[$sel:discontinuityMode:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe HLSDiscontinuityMode

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
[$sel:hLSFragmentSelector:GetHLSStreamingSessionURL'] :: GetHLSStreamingSessionURL -> Maybe HLSFragmentSelector

-- | Create a value of <a>GetHLSStreamingSessionURL</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   
--   <a>$sel:maxMediaPlaylistFragmentResults:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_maxMediaPlaylistFragmentResults</a> - The
--   maximum number of fragments that are returned in the HLS media
--   playlists.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live HLS
--   media playlist, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live HLS media playlist have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 5,000 fragments corresponds to more than 80
--   minutes of video on streams with 1-second fragments, and more than 13
--   hours of video on streams with 10-second fragments.
--   
--   <a>$sel:containerFormat:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_containerFormat</a> - Specifies which
--   format should be used for packaging the media. Specifying the
--   <tt>FRAGMENTED_MP4</tt> container format packages the media into MP4
--   fragments (fMP4 or CMAF). This is the recommended packaging because
--   there is minimal packaging overhead. The other container format option
--   is <tt>MPEG_TS</tt>. HLS has supported MPEG TS chunks since it was
--   released and is sometimes the only supported packaging on older HLS
--   players. MPEG TS typically has a 5-25 percent packaging overhead. This
--   means MPEG TS typically requires 5-25 percent more bandwidth and cost
--   than fMP4.
--   
--   The default is <tt>FRAGMENTED_MP4</tt>.
--   
--   <a>$sel:displayFragmentTimestamp:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_displayFragmentTimestamp</a> - Specifies
--   when the fragment start timestamps should be included in the HLS media
--   playlist. Typically, media players report the playhead position as a
--   time relative to the start of the first fragment in the playback
--   session. However, when the start timestamps are included in the HLS
--   media playlist, some media players might report the current playhead
--   as an absolute time based on the fragment timestamps. This can be
--   useful for creating a playback experience that shows viewers the
--   wall-clock time of the media.
--   
--   The default is <tt>NEVER</tt>. When HLSFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when HLSFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
--   
--   <a>$sel:playbackMode:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_playbackMode</a> - Whether to retrieve
--   live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the HLS media
--   playlist is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   playlist on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an HLS media playlist, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the HLS media
--   playlist if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the playlist, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the HLS
--   media playlist is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the media playlist every two
--   seconds. This mode is useful to be able to start playback from when an
--   event is detected and continue live streaming media that has not yet
--   been ingested as of the time of the session creation. This mode is
--   also useful to stream previously archived media without being limited
--   by the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the HLS
--   media playlist contains all the fragments for the session, up to the
--   number that is specified in <tt>MaxMediaPlaylistFragmentResults</tt>.
--   The playlist must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the largest fragment
--   number (that is, the newest fragment) is included in the HLS media
--   playlist. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the HLS media playlist. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
--   
--   <a>$sel:streamARN:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream for which to retrieve the HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:streamName:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_streamName</a> - The name of the stream
--   for which to retrieve the HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:expires:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_expires</a> - The time in seconds until
--   the requested session expires. This value can be between 300 (5
--   minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetHLSMasterPlaylist</tt>,
--   <tt>GetHLSMediaPlaylist</tt>, <tt>GetMP4InitFragment</tt>,
--   <tt>GetMP4MediaFragment</tt>, or <tt>GetTSFragment</tt> can be made
--   for that session.
--   
--   The default is 300 (5 minutes).
--   
--   <a>$sel:discontinuityMode:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_discontinuityMode</a> - Specifies when
--   flags marking discontinuities between fragments are added to the media
--   playlists.
--   
--   Media players typically build a timeline of media content to play,
--   based on the timestamps of each fragment. This means that if there is
--   any overlap or gap between fragments (as is typical if
--   HLSFragmentSelector is set to <tt>SERVER_TIMESTAMP</tt>), the media
--   player timeline will also have small gaps between fragments in some
--   places, and will overwrite frames in other places. Gaps in the media
--   player timeline can cause playback to stall and overlaps can cause
--   playback to be jittery. When there are discontinuity flags between
--   fragments, the media player is expected to reset the timeline,
--   resulting in the next fragment being played immediately after the
--   previous fragment.
--   
--   The following modes are supported:
--   
--   <ul>
--   <li><tt>ALWAYS</tt>: a discontinuity marker is placed between every
--   fragment in the HLS media playlist. It is recommended to use a value
--   of <tt>ALWAYS</tt> if the fragment timestamps are not accurate.</li>
--   <li><tt>NEVER</tt>: no discontinuity markers are placed anywhere. It
--   is recommended to use a value of <tt>NEVER</tt> to ensure the media
--   player timeline most accurately maps to the producer timestamps.</li>
--   <li><tt>ON_DISCONTINUITY</tt>: a discontinuity marker is placed
--   between fragments that have a gap or overlap of more than 50
--   milliseconds. For most playback scenarios, it is recommended to use a
--   value of <tt>ON_DISCONTINUITY</tt> so that the media player timeline
--   is only reset when there is a significant issue with the media
--   timeline (e.g. a missing fragment).</li>
--   </ul>
--   
--   The default is <tt>ALWAYS</tt> when HLSFragmentSelector is set to
--   <tt>SERVER_TIMESTAMP</tt>, and <tt>NEVER</tt> when it is set to
--   <tt>PRODUCER_TIMESTAMP</tt>.
--   
--   <a>$sel:hLSFragmentSelector:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_hLSFragmentSelector</a> - The time range
--   of the requested fragment and the source of the timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
newGetHLSStreamingSessionURL :: GetHLSStreamingSessionURL

-- | The maximum number of fragments that are returned in the HLS media
--   playlists.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live HLS
--   media playlist, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live HLS media playlist have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 5,000 fragments corresponds to more than 80
--   minutes of video on streams with 1-second fragments, and more than 13
--   hours of video on streams with 10-second fragments.
getHLSStreamingSessionURL_maxMediaPlaylistFragmentResults :: Lens' GetHLSStreamingSessionURL (Maybe Natural)

-- | Specifies which format should be used for packaging the media.
--   Specifying the <tt>FRAGMENTED_MP4</tt> container format packages the
--   media into MP4 fragments (fMP4 or CMAF). This is the recommended
--   packaging because there is minimal packaging overhead. The other
--   container format option is <tt>MPEG_TS</tt>. HLS has supported MPEG TS
--   chunks since it was released and is sometimes the only supported
--   packaging on older HLS players. MPEG TS typically has a 5-25 percent
--   packaging overhead. This means MPEG TS typically requires 5-25 percent
--   more bandwidth and cost than fMP4.
--   
--   The default is <tt>FRAGMENTED_MP4</tt>.
getHLSStreamingSessionURL_containerFormat :: Lens' GetHLSStreamingSessionURL (Maybe ContainerFormat)

-- | Specifies when the fragment start timestamps should be included in the
--   HLS media playlist. Typically, media players report the playhead
--   position as a time relative to the start of the first fragment in the
--   playback session. However, when the start timestamps are included in
--   the HLS media playlist, some media players might report the current
--   playhead as an absolute time based on the fragment timestamps. This
--   can be useful for creating a playback experience that shows viewers
--   the wall-clock time of the media.
--   
--   The default is <tt>NEVER</tt>. When HLSFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when HLSFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
getHLSStreamingSessionURL_displayFragmentTimestamp :: Lens' GetHLSStreamingSessionURL (Maybe HLSDisplayFragmentTimestamp)

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the HLS media
--   playlist is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   playlist on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an HLS media playlist, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the HLS media
--   playlist if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the playlist, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the HLS
--   media playlist is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the media playlist every two
--   seconds. This mode is useful to be able to start playback from when an
--   event is detected and continue live streaming media that has not yet
--   been ingested as of the time of the session creation. This mode is
--   also useful to stream previously archived media without being limited
--   by the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the HLS
--   media playlist contains all the fragments for the session, up to the
--   number that is specified in <tt>MaxMediaPlaylistFragmentResults</tt>.
--   The playlist must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the largest fragment
--   number (that is, the newest fragment) is included in the HLS media
--   playlist. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the HLS media playlist. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
getHLSStreamingSessionURL_playbackMode :: Lens' GetHLSStreamingSessionURL (Maybe HLSPlaybackMode)

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getHLSStreamingSessionURL_streamARN :: Lens' GetHLSStreamingSessionURL (Maybe Text)

-- | The name of the stream for which to retrieve the HLS master playlist
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getHLSStreamingSessionURL_streamName :: Lens' GetHLSStreamingSessionURL (Maybe Text)

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetHLSMasterPlaylist</tt>,
--   <tt>GetHLSMediaPlaylist</tt>, <tt>GetMP4InitFragment</tt>,
--   <tt>GetMP4MediaFragment</tt>, or <tt>GetTSFragment</tt> can be made
--   for that session.
--   
--   The default is 300 (5 minutes).
getHLSStreamingSessionURL_expires :: Lens' GetHLSStreamingSessionURL (Maybe Natural)

-- | Specifies when flags marking discontinuities between fragments are
--   added to the media playlists.
--   
--   Media players typically build a timeline of media content to play,
--   based on the timestamps of each fragment. This means that if there is
--   any overlap or gap between fragments (as is typical if
--   HLSFragmentSelector is set to <tt>SERVER_TIMESTAMP</tt>), the media
--   player timeline will also have small gaps between fragments in some
--   places, and will overwrite frames in other places. Gaps in the media
--   player timeline can cause playback to stall and overlaps can cause
--   playback to be jittery. When there are discontinuity flags between
--   fragments, the media player is expected to reset the timeline,
--   resulting in the next fragment being played immediately after the
--   previous fragment.
--   
--   The following modes are supported:
--   
--   <ul>
--   <li><tt>ALWAYS</tt>: a discontinuity marker is placed between every
--   fragment in the HLS media playlist. It is recommended to use a value
--   of <tt>ALWAYS</tt> if the fragment timestamps are not accurate.</li>
--   <li><tt>NEVER</tt>: no discontinuity markers are placed anywhere. It
--   is recommended to use a value of <tt>NEVER</tt> to ensure the media
--   player timeline most accurately maps to the producer timestamps.</li>
--   <li><tt>ON_DISCONTINUITY</tt>: a discontinuity marker is placed
--   between fragments that have a gap or overlap of more than 50
--   milliseconds. For most playback scenarios, it is recommended to use a
--   value of <tt>ON_DISCONTINUITY</tt> so that the media player timeline
--   is only reset when there is a significant issue with the media
--   timeline (e.g. a missing fragment).</li>
--   </ul>
--   
--   The default is <tt>ALWAYS</tt> when HLSFragmentSelector is set to
--   <tt>SERVER_TIMESTAMP</tt>, and <tt>NEVER</tt> when it is set to
--   <tt>PRODUCER_TIMESTAMP</tt>.
getHLSStreamingSessionURL_discontinuityMode :: Lens' GetHLSStreamingSessionURL (Maybe HLSDiscontinuityMode)

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
getHLSStreamingSessionURL_hLSFragmentSelector :: Lens' GetHLSStreamingSessionURL (Maybe HLSFragmentSelector)

-- | <i>See:</i> <a>newGetHLSStreamingSessionURLResponse</a> smart
--   constructor.
data GetHLSStreamingSessionURLResponse
GetHLSStreamingSessionURLResponse' :: Maybe Text -> Int -> GetHLSStreamingSessionURLResponse

-- | The URL (containing the session token) that a media player can use to
--   retrieve the HLS master playlist.
[$sel:hLSStreamingSessionURL:GetHLSStreamingSessionURLResponse'] :: GetHLSStreamingSessionURLResponse -> Maybe Text

-- | The response's http status code.
[$sel:httpStatus:GetHLSStreamingSessionURLResponse'] :: GetHLSStreamingSessionURLResponse -> Int

-- | Create a value of <a>GetHLSStreamingSessionURLResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:hLSStreamingSessionURL:GetHLSStreamingSessionURLResponse'</a>,
--   <a>getHLSStreamingSessionURLResponse_hLSStreamingSessionURL</a> - The
--   URL (containing the session token) that a media player can use to
--   retrieve the HLS master playlist.
--   
--   <a>$sel:httpStatus:GetHLSStreamingSessionURLResponse'</a>,
--   <a>getHLSStreamingSessionURLResponse_httpStatus</a> - The response's
--   http status code.
newGetHLSStreamingSessionURLResponse :: Int -> GetHLSStreamingSessionURLResponse

-- | The URL (containing the session token) that a media player can use to
--   retrieve the HLS master playlist.
getHLSStreamingSessionURLResponse_hLSStreamingSessionURL :: Lens' GetHLSStreamingSessionURLResponse (Maybe Text)

-- | The response's http status code.
getHLSStreamingSessionURLResponse_httpStatus :: Lens' GetHLSStreamingSessionURLResponse Int
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURLResponse
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURLResponse
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURLResponse
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURLResponse
instance Network.AWS.Types.AWSRequest Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURLResponse
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Network.AWS.Data.Headers.ToHeaders Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Network.AWS.Data.Path.ToPath Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.GetHLSStreamingSessionURL.GetHLSStreamingSessionURL


-- | Retrieves an MPEG Dynamic Adaptive Streaming over HTTP (DASH) URL for
--   the stream. You can then open the URL in a media player to view the
--   stream contents.
--   
--   Both the <tt>StreamName</tt> and the <tt>StreamARN</tt> parameters are
--   optional, but you must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt> when invoking this API operation.
--   
--   An Amazon Kinesis video stream has the following requirements for
--   providing data through MPEG-DASH:
--   
--   <ul>
--   <li>The media must contain h.264 or h.265 encoded video and,
--   optionally, AAC or G.711 encoded audio. Specifically, the codec ID of
--   track 1 should be <tt>V_MPEG/ISO/AVC</tt> (for h.264) or
--   V_MPEGH/ISO/HEVC (for H.265). Optionally, the codec ID of track 2
--   should be <tt>A_AAC</tt> (for AAC) or A_MS/ACM (for G.711).</li>
--   <li>Data retention must be greater than 0.</li>
--   <li>The video track of each fragment must contain codec private data
--   in the Advanced Video Coding (AVC) for H.264 format and HEVC for H.265
--   format. For more information, see <a>MPEG-4 specification ISO/IEC
--   14496-15</a>. For information about adapting stream data to a given
--   format, see <a>NAL Adaptation Flags</a>.</li>
--   <li>The audio track (if present) of each fragment must contain codec
--   private data in the AAC format (<a>AAC specification ISO/IEC
--   13818-7</a>) or the <a>MS Wave format</a>.</li>
--   </ul>
--   
--   The following procedure shows how to use MPEG-DASH with Kinesis Video
--   Streams:
--   
--   <ol>
--   <li>Get an endpoint using <a>GetDataEndpoint</a>, specifying
--   <tt>GET_DASH_STREAMING_SESSION_URL</tt> for the <tt>APIName</tt>
--   parameter.</li>
--   <li>Retrieve the MPEG-DASH URL using
--   <tt>GetDASHStreamingSessionURL</tt>. Kinesis Video Streams creates an
--   MPEG-DASH streaming session to be used for accessing content in a
--   stream using the MPEG-DASH protocol.
--   <tt>GetDASHStreamingSessionURL</tt> returns an authenticated URL (that
--   includes an encrypted session token) for the session's MPEG-DASH
--   <i>manifest</i> (the root resource needed for streaming with
--   MPEG-DASH).Don't share or store this token where an unauthorized
--   entity can access it. The token provides access to the content of the
--   stream. Safeguard the token with the same measures that you use with
--   your AWS credentials.The media that is made available through the
--   manifest consists only of the requested stream, time range, and
--   format. No other media data (such as frames outside the requested
--   window or alternate bitrates) is made available.</li>
--   <li>Provide the URL (containing the encrypted session token) for the
--   MPEG-DASH manifest to a media player that supports the MPEG-DASH
--   protocol. Kinesis Video Streams makes the initialization fragment and
--   media fragments available through the manifest URL. The initialization
--   fragment contains the codec private data for the stream, and other
--   data needed to set up the video or audio decoder and renderer. The
--   media fragments contain encoded video frames or encoded audio
--   samples.</li>
--   <li>The media player receives the authenticated URL and requests
--   stream metadata and media data normally. When the media player
--   requests data, it calls the following
--   actions:<ul><li><b>GetDASHManifest:</b> Retrieves an MPEG DASH
--   manifest, which contains the metadata for the media that you want to
--   playback.</li><li><b>GetMP4InitFragment:</b> Retrieves the MP4
--   initialization fragment. The media player typically loads the
--   initialization fragment before loading any media fragments. This
--   fragment contains the "<tt>fytp</tt>" and "<tt>moov</tt>" MP4 atoms,
--   and the child atoms that are needed to initialize the media player
--   decoder.The initialization fragment does not correspond to a fragment
--   in a Kinesis video stream. It contains only the codec private data for
--   the stream and respective track, which the media player needs to
--   decode the media frames.</li><li><b>GetMP4MediaFragment:</b> Retrieves
--   MP4 media fragments. These fragments contain the "<tt>moof</tt>" and
--   "<tt>mdat</tt>" MP4 atoms and their child atoms, containing the
--   encoded fragment's media frames and their timestamps.After the first
--   media fragment is made available in a streaming session, any fragments
--   that don't contain the same codec private data cause an error to be
--   returned when those different media fragments are loaded. Therefore,
--   the codec private data should not change between fragments in a
--   session. This also means that the session fails if the fragments in a
--   stream change from having only video to having both audio and
--   video.Data retrieved with this action is billable. See <a>Pricing</a>
--   for details.</li></ul></li>
--   </ol>
--   
--   For restrictions that apply to MPEG-DASH sessions, see <a>Kinesis
--   Video Streams Limits</a>.
--   
--   You can monitor the amount of data that the media player consumes by
--   monitoring the <tt>GetMP4MediaFragment.OutgoingBytes</tt> Amazon
--   CloudWatch metric. For information about using CloudWatch to monitor
--   Kinesis Video Streams, see <a>Monitoring Kinesis Video Streams</a>.
--   For pricing information, see <a>Amazon Kinesis Video Streams
--   Pricing</a> and <a>AWS Pricing</a>. Charges for both HLS sessions and
--   outgoing AWS data apply.
--   
--   For more information about HLS, see <a>HTTP Live Streaming</a> on the
--   <a>Apple Developer site</a>.
--   
--   If an error is thrown after invoking a Kinesis Video Streams archived
--   media API, in addition to the HTTP status code and the response body,
--   it includes the following pieces of information:
--   
--   <ul>
--   <li><tt>x-amz-ErrorType</tt> HTTP header – contains a more specific
--   error type in addition to what the HTTP status code provides.</li>
--   <li><tt>x-amz-RequestId</tt> HTTP header – if you want to report an
--   issue to AWS, the support team can better diagnose the problem if
--   given the Request Id.</li>
--   </ul>
--   
--   Both the HTTP status code and the ErrorType header can be utilized to
--   make programmatic decisions about whether errors are retry-able and
--   under what conditions, as well as provide information on what actions
--   the client programmer might need to take in order to successfully try
--   again.
--   
--   For more information, see the <b>Errors</b> section at the bottom of
--   this topic, as well as <a>Common Errors</a>.
module Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL

-- | <i>See:</i> <a>newGetDASHStreamingSessionURL</a> smart constructor.
data GetDASHStreamingSessionURL
GetDASHStreamingSessionURL' :: Maybe DASHDisplayFragmentTimestamp -> Maybe DASHDisplayFragmentNumber -> Maybe Natural -> Maybe DASHFragmentSelector -> Maybe DASHPlaybackMode -> Maybe Text -> Maybe Text -> Maybe Natural -> GetDASHStreamingSessionURL

-- | Per the MPEG-DASH specification, the wall-clock time of fragments in
--   the manifest file can be derived using attributes in the manifest
--   itself. However, typically, MPEG-DASH compatible media players do not
--   properly handle gaps in the media timeline. Kinesis Video Streams
--   adjusts the media timeline in the manifest file to enable playback of
--   media with discontinuities. Therefore, the wall-clock time derived
--   from the manifest file may be inaccurate. If DisplayFragmentTimestamp
--   is set to <tt>ALWAYS</tt>, the accurate fragment timestamp is added to
--   each S element in the manifest file with the attribute name “kvs:ts”.
--   A custom MPEG-DASH media player is necessary to leverage this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>. When DASHFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when DASHFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
[$sel:displayFragmentTimestamp:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe DASHDisplayFragmentTimestamp

-- | Fragments are identified in the manifest file based on their sequence
--   number in the session. If DisplayFragmentNumber is set to
--   <tt>ALWAYS</tt>, the Kinesis Video Streams fragment number is added to
--   each S element in the manifest file with the attribute name “kvs:fn”.
--   These fragment numbers can be used for logging or for use with other
--   APIs (e.g. <tt>GetMedia</tt> and <tt>GetMediaForFragmentList</tt>). A
--   custom MPEG-DASH media player is necessary to leverage these this
--   custom attribute.
--   
--   The default value is <tt>NEVER</tt>.
[$sel:displayFragmentNumber:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe DASHDisplayFragmentNumber

-- | The maximum number of fragments that are returned in the MPEG-DASH
--   manifest.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live
--   MPEG-DASH manifest, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live MPEG-DASH manifest have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 1,000 fragments corresponds to more than 16
--   minutes of video on streams with 1-second fragments, and more than 2
--   1/2 hours of video on streams with 10-second fragments.
[$sel:maxManifestFragmentResults:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe Natural

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
[$sel:dASHFragmentSelector:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe DASHFragmentSelector

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the MPEG-DASH
--   manifest is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   manifest on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an MPEG-DASH manifest, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the MPEG-DASH
--   manifest if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the manifest, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the manifest every two seconds.
--   This mode is useful to be able to start playback from when an event is
--   detected and continue live streaming media that has not yet been
--   ingested as of the time of the session creation. This mode is also
--   useful to stream previously archived media without being limited by
--   the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest contains all the fragments for the session, up to
--   the number that is specified in <tt>MaxManifestFragmentResults</tt>.
--   The manifest must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the larger fragment
--   number (that is, the newer fragment) is included in the MPEG-DASH
--   manifest. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the MPEG-DASH manifest. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
[$sel:playbackMode:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe DASHPlaybackMode

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
[$sel:streamARN:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe Text

-- | The name of the stream for which to retrieve the MPEG-DASH manifest
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
[$sel:streamName:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe Text

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetDashManifest</tt>,
--   <tt>GetMP4InitFragment</tt>, or <tt>GetMP4MediaFragment</tt> can be
--   made for that session.
--   
--   The default is 300 (5 minutes).
[$sel:expires:GetDASHStreamingSessionURL'] :: GetDASHStreamingSessionURL -> Maybe Natural

-- | Create a value of <a>GetDASHStreamingSessionURL</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:displayFragmentTimestamp:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_displayFragmentTimestamp</a> - Per the
--   MPEG-DASH specification, the wall-clock time of fragments in the
--   manifest file can be derived using attributes in the manifest itself.
--   However, typically, MPEG-DASH compatible media players do not properly
--   handle gaps in the media timeline. Kinesis Video Streams adjusts the
--   media timeline in the manifest file to enable playback of media with
--   discontinuities. Therefore, the wall-clock time derived from the
--   manifest file may be inaccurate. If DisplayFragmentTimestamp is set to
--   <tt>ALWAYS</tt>, the accurate fragment timestamp is added to each S
--   element in the manifest file with the attribute name “kvs:ts”. A
--   custom MPEG-DASH media player is necessary to leverage this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>. When DASHFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when DASHFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
--   
--   <a>$sel:displayFragmentNumber:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_displayFragmentNumber</a> - Fragments
--   are identified in the manifest file based on their sequence number in
--   the session. If DisplayFragmentNumber is set to <tt>ALWAYS</tt>, the
--   Kinesis Video Streams fragment number is added to each S element in
--   the manifest file with the attribute name “kvs:fn”. These fragment
--   numbers can be used for logging or for use with other APIs (e.g.
--   <tt>GetMedia</tt> and <tt>GetMediaForFragmentList</tt>). A custom
--   MPEG-DASH media player is necessary to leverage these this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>.
--   
--   <a>$sel:maxManifestFragmentResults:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_maxManifestFragmentResults</a> - The
--   maximum number of fragments that are returned in the MPEG-DASH
--   manifest.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live
--   MPEG-DASH manifest, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live MPEG-DASH manifest have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 1,000 fragments corresponds to more than 16
--   minutes of video on streams with 1-second fragments, and more than 2
--   1/2 hours of video on streams with 10-second fragments.
--   
--   <a>$sel:dASHFragmentSelector:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_dASHFragmentSelector</a> - The time
--   range of the requested fragment and the source of the timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
--   
--   <a>$sel:playbackMode:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_playbackMode</a> - Whether to retrieve
--   live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the MPEG-DASH
--   manifest is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   manifest on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an MPEG-DASH manifest, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the MPEG-DASH
--   manifest if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the manifest, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the manifest every two seconds.
--   This mode is useful to be able to start playback from when an event is
--   detected and continue live streaming media that has not yet been
--   ingested as of the time of the session creation. This mode is also
--   useful to stream previously archived media without being limited by
--   the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest contains all the fragments for the session, up to
--   the number that is specified in <tt>MaxManifestFragmentResults</tt>.
--   The manifest must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the larger fragment
--   number (that is, the newer fragment) is included in the MPEG-DASH
--   manifest. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the MPEG-DASH manifest. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
--   
--   <a>$sel:streamARN:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream for which to retrieve the MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:streamName:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_streamName</a> - The name of the stream
--   for which to retrieve the MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:expires:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_expires</a> - The time in seconds until
--   the requested session expires. This value can be between 300 (5
--   minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetDashManifest</tt>,
--   <tt>GetMP4InitFragment</tt>, or <tt>GetMP4MediaFragment</tt> can be
--   made for that session.
--   
--   The default is 300 (5 minutes).
newGetDASHStreamingSessionURL :: GetDASHStreamingSessionURL

-- | Per the MPEG-DASH specification, the wall-clock time of fragments in
--   the manifest file can be derived using attributes in the manifest
--   itself. However, typically, MPEG-DASH compatible media players do not
--   properly handle gaps in the media timeline. Kinesis Video Streams
--   adjusts the media timeline in the manifest file to enable playback of
--   media with discontinuities. Therefore, the wall-clock time derived
--   from the manifest file may be inaccurate. If DisplayFragmentTimestamp
--   is set to <tt>ALWAYS</tt>, the accurate fragment timestamp is added to
--   each S element in the manifest file with the attribute name “kvs:ts”.
--   A custom MPEG-DASH media player is necessary to leverage this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>. When DASHFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when DASHFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
getDASHStreamingSessionURL_displayFragmentTimestamp :: Lens' GetDASHStreamingSessionURL (Maybe DASHDisplayFragmentTimestamp)

-- | Fragments are identified in the manifest file based on their sequence
--   number in the session. If DisplayFragmentNumber is set to
--   <tt>ALWAYS</tt>, the Kinesis Video Streams fragment number is added to
--   each S element in the manifest file with the attribute name “kvs:fn”.
--   These fragment numbers can be used for logging or for use with other
--   APIs (e.g. <tt>GetMedia</tt> and <tt>GetMediaForFragmentList</tt>). A
--   custom MPEG-DASH media player is necessary to leverage these this
--   custom attribute.
--   
--   The default value is <tt>NEVER</tt>.
getDASHStreamingSessionURL_displayFragmentNumber :: Lens' GetDASHStreamingSessionURL (Maybe DASHDisplayFragmentNumber)

-- | The maximum number of fragments that are returned in the MPEG-DASH
--   manifest.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live
--   MPEG-DASH manifest, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live MPEG-DASH manifest have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 1,000 fragments corresponds to more than 16
--   minutes of video on streams with 1-second fragments, and more than 2
--   1/2 hours of video on streams with 10-second fragments.
getDASHStreamingSessionURL_maxManifestFragmentResults :: Lens' GetDASHStreamingSessionURL (Maybe Natural)

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
getDASHStreamingSessionURL_dASHFragmentSelector :: Lens' GetDASHStreamingSessionURL (Maybe DASHFragmentSelector)

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the MPEG-DASH
--   manifest is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   manifest on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an MPEG-DASH manifest, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the MPEG-DASH
--   manifest if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the manifest, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the manifest every two seconds.
--   This mode is useful to be able to start playback from when an event is
--   detected and continue live streaming media that has not yet been
--   ingested as of the time of the session creation. This mode is also
--   useful to stream previously archived media without being limited by
--   the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest contains all the fragments for the session, up to
--   the number that is specified in <tt>MaxManifestFragmentResults</tt>.
--   The manifest must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the larger fragment
--   number (that is, the newer fragment) is included in the MPEG-DASH
--   manifest. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the MPEG-DASH manifest. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
getDASHStreamingSessionURL_playbackMode :: Lens' GetDASHStreamingSessionURL (Maybe DASHPlaybackMode)

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getDASHStreamingSessionURL_streamARN :: Lens' GetDASHStreamingSessionURL (Maybe Text)

-- | The name of the stream for which to retrieve the MPEG-DASH manifest
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getDASHStreamingSessionURL_streamName :: Lens' GetDASHStreamingSessionURL (Maybe Text)

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetDashManifest</tt>,
--   <tt>GetMP4InitFragment</tt>, or <tt>GetMP4MediaFragment</tt> can be
--   made for that session.
--   
--   The default is 300 (5 minutes).
getDASHStreamingSessionURL_expires :: Lens' GetDASHStreamingSessionURL (Maybe Natural)

-- | <i>See:</i> <a>newGetDASHStreamingSessionURLResponse</a> smart
--   constructor.
data GetDASHStreamingSessionURLResponse
GetDASHStreamingSessionURLResponse' :: Maybe Text -> Int -> GetDASHStreamingSessionURLResponse

-- | The URL (containing the session token) that a media player can use to
--   retrieve the MPEG-DASH manifest.
[$sel:dASHStreamingSessionURL:GetDASHStreamingSessionURLResponse'] :: GetDASHStreamingSessionURLResponse -> Maybe Text

-- | The response's http status code.
[$sel:httpStatus:GetDASHStreamingSessionURLResponse'] :: GetDASHStreamingSessionURLResponse -> Int

-- | Create a value of <a>GetDASHStreamingSessionURLResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   
--   <a>$sel:dASHStreamingSessionURL:GetDASHStreamingSessionURLResponse'</a>,
--   <a>getDASHStreamingSessionURLResponse_dASHStreamingSessionURL</a> -
--   The URL (containing the session token) that a media player can use to
--   retrieve the MPEG-DASH manifest.
--   
--   <a>$sel:httpStatus:GetDASHStreamingSessionURLResponse'</a>,
--   <a>getDASHStreamingSessionURLResponse_httpStatus</a> - The response's
--   http status code.
newGetDASHStreamingSessionURLResponse :: Int -> GetDASHStreamingSessionURLResponse

-- | The URL (containing the session token) that a media player can use to
--   retrieve the MPEG-DASH manifest.
getDASHStreamingSessionURLResponse_dASHStreamingSessionURL :: Lens' GetDASHStreamingSessionURLResponse (Maybe Text)

-- | The response's http status code.
getDASHStreamingSessionURLResponse_httpStatus :: Lens' GetDASHStreamingSessionURLResponse Int
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURLResponse
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURLResponse
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURLResponse
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURLResponse
instance Network.AWS.Types.AWSRequest Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURLResponse
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Network.AWS.Data.Headers.ToHeaders Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Network.AWS.Data.Path.ToPath Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.GetDASHStreamingSessionURL.GetDASHStreamingSessionURL


-- | Downloads an MP4 file (clip) containing the archived, on-demand media
--   from the specified video stream over the specified time range.
--   
--   Both the StreamName and the StreamARN parameters are optional, but you
--   must specify either the StreamName or the StreamARN when invoking this
--   API operation.
--   
--   As a prerequisite to using GetCLip API, you must obtain an endpoint
--   using <tt>GetDataEndpoint</tt>, specifying GET_CLIP for@<tt> the
--   </tt>APIName@ parameter.
--   
--   An Amazon Kinesis video stream has the following requirements for
--   providing data through MP4:
--   
--   <ul>
--   <li>The media must contain h.264 or h.265 encoded video and,
--   optionally, AAC or G.711 encoded audio. Specifically, the codec ID of
--   track 1 should be <tt>V_MPEG/ISO/AVC</tt> (for h.264) or
--   V_MPEGH/ISO/HEVC (for H.265). Optionally, the codec ID of track 2
--   should be <tt>A_AAC</tt> (for AAC) or A_MS/ACM (for G.711).</li>
--   <li>Data retention must be greater than 0.</li>
--   <li>The video track of each fragment must contain codec private data
--   in the Advanced Video Coding (AVC) for H.264 format and HEVC for H.265
--   format. For more information, see <a>MPEG-4 specification ISO/IEC
--   14496-15</a>. For information about adapting stream data to a given
--   format, see <a>NAL Adaptation Flags</a>.</li>
--   <li>The audio track (if present) of each fragment must contain codec
--   private data in the AAC format (<a>AAC specification ISO/IEC
--   13818-7</a>) or the <a>MS Wave format</a>.</li>
--   </ul>
--   
--   You can monitor the amount of outgoing data by monitoring the
--   <tt>GetClip.OutgoingBytes</tt> Amazon CloudWatch metric. For
--   information about using CloudWatch to monitor Kinesis Video Streams,
--   see <a>Monitoring Kinesis Video Streams</a>. For pricing information,
--   see <a>Amazon Kinesis Video Streams Pricing</a> and <a>AWS
--   Pricing</a>. Charges for outgoing AWS data apply.
module Network.AWS.KinesisVideoArchivedMedia.GetClip

-- | <i>See:</i> <a>newGetClip</a> smart constructor.
data GetClip
GetClip' :: Maybe Text -> Maybe Text -> ClipFragmentSelector -> GetClip

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   media clip.
--   
--   You must specify either the StreamName or the StreamARN.
[$sel:streamARN:GetClip'] :: GetClip -> Maybe Text

-- | The name of the stream for which to retrieve the media clip.
--   
--   You must specify either the StreamName or the StreamARN.
[$sel:streamName:GetClip'] :: GetClip -> Maybe Text

-- | The time range of the requested clip and the source of the timestamps.
[$sel:clipFragmentSelector:GetClip'] :: GetClip -> ClipFragmentSelector

-- | Create a value of <a>GetClip</a> with all optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:streamARN:GetClip'</a>, <a>getClip_streamARN</a> - The Amazon
--   Resource Name (ARN) of the stream for which to retrieve the media
--   clip.
--   
--   You must specify either the StreamName or the StreamARN.
--   
--   <a>$sel:streamName:GetClip'</a>, <a>getClip_streamName</a> - The name
--   of the stream for which to retrieve the media clip.
--   
--   You must specify either the StreamName or the StreamARN.
--   
--   <a>$sel:clipFragmentSelector:GetClip'</a>,
--   <a>getClip_clipFragmentSelector</a> - The time range of the requested
--   clip and the source of the timestamps.
newGetClip :: ClipFragmentSelector -> GetClip

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   media clip.
--   
--   You must specify either the StreamName or the StreamARN.
getClip_streamARN :: Lens' GetClip (Maybe Text)

-- | The name of the stream for which to retrieve the media clip.
--   
--   You must specify either the StreamName or the StreamARN.
getClip_streamName :: Lens' GetClip (Maybe Text)

-- | The time range of the requested clip and the source of the timestamps.
getClip_clipFragmentSelector :: Lens' GetClip ClipFragmentSelector

-- | <i>See:</i> <a>newGetClipResponse</a> smart constructor.
data GetClipResponse
GetClipResponse' :: Maybe Text -> Int -> ResponseBody -> GetClipResponse

-- | The content type of the media in the requested clip.
[$sel:contentType:GetClipResponse'] :: GetClipResponse -> Maybe Text

-- | The response's http status code.
[$sel:httpStatus:GetClipResponse'] :: GetClipResponse -> Int

-- | Traditional MP4 file that contains the media clip from the specified
--   video stream. The output will contain the first 100 MB or the first
--   200 fragments from the specified start timestamp. For more
--   information, see <a>Kinesis Video Streams Limits</a>.
[$sel:payload:GetClipResponse'] :: GetClipResponse -> ResponseBody

-- | Create a value of <a>GetClipResponse</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:contentType:GetClipResponse'</a>,
--   <a>getClipResponse_contentType</a> - The content type of the media in
--   the requested clip.
--   
--   <a>$sel:httpStatus:GetClipResponse'</a>,
--   <a>getClipResponse_httpStatus</a> - The response's http status code.
--   
--   <a>$sel:payload:GetClipResponse'</a>, <a>getClipResponse_payload</a> -
--   Traditional MP4 file that contains the media clip from the specified
--   video stream. The output will contain the first 100 MB or the first
--   200 fragments from the specified start timestamp. For more
--   information, see <a>Kinesis Video Streams Limits</a>.
newGetClipResponse :: Int -> ResponseBody -> GetClipResponse

-- | The content type of the media in the requested clip.
getClipResponse_contentType :: Lens' GetClipResponse (Maybe Text)

-- | The response's http status code.
getClipResponse_httpStatus :: Lens' GetClipResponse Int

-- | Traditional MP4 file that contains the media clip from the specified
--   video stream. The output will contain the first 100 MB or the first
--   200 fragments from the specified start timestamp. For more
--   information, see <a>Kinesis Video Streams Limits</a>.
getClipResponse_payload :: Lens' GetClipResponse ResponseBody
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance GHC.Read.Read Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance GHC.Classes.Eq Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance GHC.Generics.Generic Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClipResponse
instance GHC.Show.Show Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClipResponse
instance Network.AWS.Types.AWSRequest Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Data.Hashable.Class.Hashable Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Control.DeepSeq.NFData Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Network.AWS.Data.Headers.ToHeaders Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Network.AWS.Data.Path.ToPath Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip
instance Network.AWS.Data.Query.ToQuery Network.AWS.KinesisVideoArchivedMedia.GetClip.GetClip


module Network.AWS.KinesisVideoArchivedMedia.Lens

-- | A token to specify where to start paginating. This is the
--   ListFragmentsOutput$NextToken from a previously truncated response.
listFragments_nextToken :: Lens' ListFragments (Maybe Text)

-- | The total number of fragments to return. If the total number of
--   fragments available is more than the value specified in
--   <tt>max-results</tt>, then a ListFragmentsOutput$NextToken is provided
--   in the output that you can use to resume pagination.
listFragments_maxResults :: Lens' ListFragments (Maybe Natural)

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve a
--   fragment list. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
listFragments_streamARN :: Lens' ListFragments (Maybe Text)

-- | The name of the stream from which to retrieve a fragment list. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
listFragments_streamName :: Lens' ListFragments (Maybe Text)

-- | Describes the timestamp range and timestamp origin for the range of
--   fragments to return.
listFragments_fragmentSelector :: Lens' ListFragments (Maybe FragmentSelector)

-- | If the returned list is truncated, the operation returns this token to
--   use to retrieve the next page of results. This value is <tt>null</tt>
--   when there are no more results to return.
listFragmentsResponse_nextToken :: Lens' ListFragmentsResponse (Maybe Text)

-- | A list of archived Fragment objects from the stream that meet the
--   selector criteria. Results are in no specific order, even across
--   pages.
listFragmentsResponse_fragments :: Lens' ListFragmentsResponse (Maybe [Fragment])

-- | The response's http status code.
listFragmentsResponse_httpStatus :: Lens' ListFragmentsResponse Int

-- | The Amazon Resource Name (ARN) of the stream from which to retrieve
--   fragment media. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
getMediaForFragmentList_streamARN :: Lens' GetMediaForFragmentList (Maybe Text)

-- | The name of the stream from which to retrieve fragment media. Specify
--   either this parameter or the <tt>StreamARN</tt> parameter.
getMediaForFragmentList_streamName :: Lens' GetMediaForFragmentList (Maybe Text)

-- | A list of the numbers of fragments for which to retrieve media. You
--   retrieve these values with ListFragments.
getMediaForFragmentList_fragments :: Lens' GetMediaForFragmentList (NonEmpty Text)

-- | The content type of the requested media.
getMediaForFragmentListResponse_contentType :: Lens' GetMediaForFragmentListResponse (Maybe Text)

-- | The response's http status code.
getMediaForFragmentListResponse_httpStatus :: Lens' GetMediaForFragmentListResponse Int

-- | The payload that Kinesis Video Streams returns is a sequence of chunks
--   from the specified stream. For information about the chunks, see
--   <a>PutMedia</a>. The chunks that Kinesis Video Streams returns in the
--   <tt>GetMediaForFragmentList</tt> call also include the following
--   additional Matroska (MKV) tags:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
--   chunk.</li>
--   <li>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of
--   the fragment.</li>
--   <li>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp
--   of the fragment.</li>
--   </ul>
--   
--   The following tags will be included if an exception occurs:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that
--   threw the exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
--   exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
--   exception</li>
--   </ul>
getMediaForFragmentListResponse_payload :: Lens' GetMediaForFragmentListResponse ResponseBody

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   media clip.
--   
--   You must specify either the StreamName or the StreamARN.
getClip_streamARN :: Lens' GetClip (Maybe Text)

-- | The name of the stream for which to retrieve the media clip.
--   
--   You must specify either the StreamName or the StreamARN.
getClip_streamName :: Lens' GetClip (Maybe Text)

-- | The time range of the requested clip and the source of the timestamps.
getClip_clipFragmentSelector :: Lens' GetClip ClipFragmentSelector

-- | The content type of the media in the requested clip.
getClipResponse_contentType :: Lens' GetClipResponse (Maybe Text)

-- | The response's http status code.
getClipResponse_httpStatus :: Lens' GetClipResponse Int

-- | Traditional MP4 file that contains the media clip from the specified
--   video stream. The output will contain the first 100 MB or the first
--   200 fragments from the specified start timestamp. For more
--   information, see <a>Kinesis Video Streams Limits</a>.
getClipResponse_payload :: Lens' GetClipResponse ResponseBody

-- | Per the MPEG-DASH specification, the wall-clock time of fragments in
--   the manifest file can be derived using attributes in the manifest
--   itself. However, typically, MPEG-DASH compatible media players do not
--   properly handle gaps in the media timeline. Kinesis Video Streams
--   adjusts the media timeline in the manifest file to enable playback of
--   media with discontinuities. Therefore, the wall-clock time derived
--   from the manifest file may be inaccurate. If DisplayFragmentTimestamp
--   is set to <tt>ALWAYS</tt>, the accurate fragment timestamp is added to
--   each S element in the manifest file with the attribute name “kvs:ts”.
--   A custom MPEG-DASH media player is necessary to leverage this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>. When DASHFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when DASHFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
getDASHStreamingSessionURL_displayFragmentTimestamp :: Lens' GetDASHStreamingSessionURL (Maybe DASHDisplayFragmentTimestamp)

-- | Fragments are identified in the manifest file based on their sequence
--   number in the session. If DisplayFragmentNumber is set to
--   <tt>ALWAYS</tt>, the Kinesis Video Streams fragment number is added to
--   each S element in the manifest file with the attribute name “kvs:fn”.
--   These fragment numbers can be used for logging or for use with other
--   APIs (e.g. <tt>GetMedia</tt> and <tt>GetMediaForFragmentList</tt>). A
--   custom MPEG-DASH media player is necessary to leverage these this
--   custom attribute.
--   
--   The default value is <tt>NEVER</tt>.
getDASHStreamingSessionURL_displayFragmentNumber :: Lens' GetDASHStreamingSessionURL (Maybe DASHDisplayFragmentNumber)

-- | The maximum number of fragments that are returned in the MPEG-DASH
--   manifest.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live
--   MPEG-DASH manifest, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live MPEG-DASH manifest have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 1,000 fragments corresponds to more than 16
--   minutes of video on streams with 1-second fragments, and more than 2
--   1/2 hours of video on streams with 10-second fragments.
getDASHStreamingSessionURL_maxManifestFragmentResults :: Lens' GetDASHStreamingSessionURL (Maybe Natural)

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
getDASHStreamingSessionURL_dASHFragmentSelector :: Lens' GetDASHStreamingSessionURL (Maybe DASHFragmentSelector)

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the MPEG-DASH
--   manifest is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   manifest on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an MPEG-DASH manifest, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the MPEG-DASH
--   manifest if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the manifest, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the manifest every two seconds.
--   This mode is useful to be able to start playback from when an event is
--   detected and continue live streaming media that has not yet been
--   ingested as of the time of the session creation. This mode is also
--   useful to stream previously archived media without being limited by
--   the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest contains all the fragments for the session, up to
--   the number that is specified in <tt>MaxManifestFragmentResults</tt>.
--   The manifest must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the larger fragment
--   number (that is, the newer fragment) is included in the MPEG-DASH
--   manifest. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the MPEG-DASH manifest. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
getDASHStreamingSessionURL_playbackMode :: Lens' GetDASHStreamingSessionURL (Maybe DASHPlaybackMode)

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getDASHStreamingSessionURL_streamARN :: Lens' GetDASHStreamingSessionURL (Maybe Text)

-- | The name of the stream for which to retrieve the MPEG-DASH manifest
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getDASHStreamingSessionURL_streamName :: Lens' GetDASHStreamingSessionURL (Maybe Text)

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetDashManifest</tt>,
--   <tt>GetMP4InitFragment</tt>, or <tt>GetMP4MediaFragment</tt> can be
--   made for that session.
--   
--   The default is 300 (5 minutes).
getDASHStreamingSessionURL_expires :: Lens' GetDASHStreamingSessionURL (Maybe Natural)

-- | The URL (containing the session token) that a media player can use to
--   retrieve the MPEG-DASH manifest.
getDASHStreamingSessionURLResponse_dASHStreamingSessionURL :: Lens' GetDASHStreamingSessionURLResponse (Maybe Text)

-- | The response's http status code.
getDASHStreamingSessionURLResponse_httpStatus :: Lens' GetDASHStreamingSessionURLResponse Int

-- | The maximum number of fragments that are returned in the HLS media
--   playlists.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live HLS
--   media playlist, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live HLS media playlist have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 5,000 fragments corresponds to more than 80
--   minutes of video on streams with 1-second fragments, and more than 13
--   hours of video on streams with 10-second fragments.
getHLSStreamingSessionURL_maxMediaPlaylistFragmentResults :: Lens' GetHLSStreamingSessionURL (Maybe Natural)

-- | Specifies which format should be used for packaging the media.
--   Specifying the <tt>FRAGMENTED_MP4</tt> container format packages the
--   media into MP4 fragments (fMP4 or CMAF). This is the recommended
--   packaging because there is minimal packaging overhead. The other
--   container format option is <tt>MPEG_TS</tt>. HLS has supported MPEG TS
--   chunks since it was released and is sometimes the only supported
--   packaging on older HLS players. MPEG TS typically has a 5-25 percent
--   packaging overhead. This means MPEG TS typically requires 5-25 percent
--   more bandwidth and cost than fMP4.
--   
--   The default is <tt>FRAGMENTED_MP4</tt>.
getHLSStreamingSessionURL_containerFormat :: Lens' GetHLSStreamingSessionURL (Maybe ContainerFormat)

-- | Specifies when the fragment start timestamps should be included in the
--   HLS media playlist. Typically, media players report the playhead
--   position as a time relative to the start of the first fragment in the
--   playback session. However, when the start timestamps are included in
--   the HLS media playlist, some media players might report the current
--   playhead as an absolute time based on the fragment timestamps. This
--   can be useful for creating a playback experience that shows viewers
--   the wall-clock time of the media.
--   
--   The default is <tt>NEVER</tt>. When HLSFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when HLSFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
getHLSStreamingSessionURL_displayFragmentTimestamp :: Lens' GetHLSStreamingSessionURL (Maybe HLSDisplayFragmentTimestamp)

-- | Whether to retrieve live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the HLS media
--   playlist is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   playlist on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an HLS media playlist, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the HLS media
--   playlist if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the playlist, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the HLS
--   media playlist is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the media playlist every two
--   seconds. This mode is useful to be able to start playback from when an
--   event is detected and continue live streaming media that has not yet
--   been ingested as of the time of the session creation. This mode is
--   also useful to stream previously archived media without being limited
--   by the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the HLS
--   media playlist contains all the fragments for the session, up to the
--   number that is specified in <tt>MaxMediaPlaylistFragmentResults</tt>.
--   The playlist must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the largest fragment
--   number (that is, the newest fragment) is included in the HLS media
--   playlist. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the HLS media playlist. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
getHLSStreamingSessionURL_playbackMode :: Lens' GetHLSStreamingSessionURL (Maybe HLSPlaybackMode)

-- | The Amazon Resource Name (ARN) of the stream for which to retrieve the
--   HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getHLSStreamingSessionURL_streamARN :: Lens' GetHLSStreamingSessionURL (Maybe Text)

-- | The name of the stream for which to retrieve the HLS master playlist
--   URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
getHLSStreamingSessionURL_streamName :: Lens' GetHLSStreamingSessionURL (Maybe Text)

-- | The time in seconds until the requested session expires. This value
--   can be between 300 (5 minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetHLSMasterPlaylist</tt>,
--   <tt>GetHLSMediaPlaylist</tt>, <tt>GetMP4InitFragment</tt>,
--   <tt>GetMP4MediaFragment</tt>, or <tt>GetTSFragment</tt> can be made
--   for that session.
--   
--   The default is 300 (5 minutes).
getHLSStreamingSessionURL_expires :: Lens' GetHLSStreamingSessionURL (Maybe Natural)

-- | Specifies when flags marking discontinuities between fragments are
--   added to the media playlists.
--   
--   Media players typically build a timeline of media content to play,
--   based on the timestamps of each fragment. This means that if there is
--   any overlap or gap between fragments (as is typical if
--   HLSFragmentSelector is set to <tt>SERVER_TIMESTAMP</tt>), the media
--   player timeline will also have small gaps between fragments in some
--   places, and will overwrite frames in other places. Gaps in the media
--   player timeline can cause playback to stall and overlaps can cause
--   playback to be jittery. When there are discontinuity flags between
--   fragments, the media player is expected to reset the timeline,
--   resulting in the next fragment being played immediately after the
--   previous fragment.
--   
--   The following modes are supported:
--   
--   <ul>
--   <li><tt>ALWAYS</tt>: a discontinuity marker is placed between every
--   fragment in the HLS media playlist. It is recommended to use a value
--   of <tt>ALWAYS</tt> if the fragment timestamps are not accurate.</li>
--   <li><tt>NEVER</tt>: no discontinuity markers are placed anywhere. It
--   is recommended to use a value of <tt>NEVER</tt> to ensure the media
--   player timeline most accurately maps to the producer timestamps.</li>
--   <li><tt>ON_DISCONTINUITY</tt>: a discontinuity marker is placed
--   between fragments that have a gap or overlap of more than 50
--   milliseconds. For most playback scenarios, it is recommended to use a
--   value of <tt>ON_DISCONTINUITY</tt> so that the media player timeline
--   is only reset when there is a significant issue with the media
--   timeline (e.g. a missing fragment).</li>
--   </ul>
--   
--   The default is <tt>ALWAYS</tt> when HLSFragmentSelector is set to
--   <tt>SERVER_TIMESTAMP</tt>, and <tt>NEVER</tt> when it is set to
--   <tt>PRODUCER_TIMESTAMP</tt>.
getHLSStreamingSessionURL_discontinuityMode :: Lens' GetHLSStreamingSessionURL (Maybe HLSDiscontinuityMode)

-- | The time range of the requested fragment and the source of the
--   timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
getHLSStreamingSessionURL_hLSFragmentSelector :: Lens' GetHLSStreamingSessionURL (Maybe HLSFragmentSelector)

-- | The URL (containing the session token) that a media player can use to
--   retrieve the HLS master playlist.
getHLSStreamingSessionURLResponse_hLSStreamingSessionURL :: Lens' GetHLSStreamingSessionURLResponse (Maybe Text)

-- | The response's http status code.
getHLSStreamingSessionURLResponse_httpStatus :: Lens' GetHLSStreamingSessionURLResponse Int

-- | The origin of the timestamps to use (Server or Producer).
clipFragmentSelector_fragmentSelectorType :: Lens' ClipFragmentSelector ClipFragmentSelectorType

-- | The range of timestamps to return.
clipFragmentSelector_timestampRange :: Lens' ClipFragmentSelector ClipTimestampRange

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
clipTimestampRange_startTimestamp :: Lens' ClipTimestampRange UTCTime

-- | The end of the timestamp range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
clipTimestampRange_endTimestamp :: Lens' ClipTimestampRange UTCTime

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
dASHFragmentSelector_fragmentSelectorType :: Lens' DASHFragmentSelector (Maybe DASHFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
dASHFragmentSelector_timestampRange :: Lens' DASHFragmentSelector (Maybe DASHTimestampRange)

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
dASHTimestampRange_endTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
dASHTimestampRange_startTimestamp :: Lens' DASHTimestampRange (Maybe UTCTime)

-- | The timestamp from the producer corresponding to the fragment.
fragment_producerTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The timestamp from the AWS server corresponding to the fragment.
fragment_serverTimestamp :: Lens' Fragment (Maybe UTCTime)

-- | The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
fragment_fragmentNumber :: Lens' Fragment (Maybe Text)

-- | The total fragment size, including information about the fragment and
--   contained media data.
fragment_fragmentSizeInBytes :: Lens' Fragment (Maybe Integer)

-- | The playback duration or other time value associated with the
--   fragment.
fragment_fragmentLengthInMilliseconds :: Lens' Fragment (Maybe Integer)

-- | The origin of the timestamps to use (Server or Producer).
fragmentSelector_fragmentSelectorType :: Lens' FragmentSelector FragmentSelectorType

-- | The range of timestamps to return.
fragmentSelector_timestampRange :: Lens' FragmentSelector TimestampRange

-- | The source of the timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
hLSFragmentSelector_fragmentSelectorType :: Lens' HLSFragmentSelector (Maybe HLSFragmentSelectorType)

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
hLSFragmentSelector_timestampRange :: Lens' HLSFragmentSelector (Maybe HLSTimestampRange)

-- | The end of the timestamp range for the requested media. This value
--   must be within 24 hours of the specified <tt>StartTimestamp</tt>, and
--   it must be later than the <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
hLSTimestampRange_endTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)

-- | The start of the timestamp range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
hLSTimestampRange_startTimestamp :: Lens' HLSTimestampRange (Maybe UTCTime)

-- | The starting timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_startTimestamp :: Lens' TimestampRange UTCTime

-- | The ending timestamp in the range of timestamps for which to return
--   fragments.
timestampRange_endTimestamp :: Lens' TimestampRange UTCTime


module Network.AWS.KinesisVideoArchivedMedia.Waiters


-- | Derived from API version <tt>2017-09-30</tt> of the AWS service
--   descriptions, licensed under Apache 2.0.
module Network.AWS.KinesisVideoArchivedMedia

-- | API version <tt>2017-09-30</tt> of the Amazon Kinesis Video Streams
--   Archived Media SDK configuration.
defaultService :: Service

-- | One or more frames in the requested clip could not be parsed based on
--   the specified codec.
_InvalidMediaFrameException :: AsError a => Getting (First ServiceError) a ServiceError

-- | Kinesis Video Streams has throttled the request because you have
--   exceeded a limit. Try making the call later. For information about
--   limits, see <a>Kinesis Video Streams Limits</a>.
_ClientLimitExceededException :: AsError a => Getting (First ServiceError) a ServiceError

-- | The codec private data in at least one of the tracks of the video
--   stream is not valid for this operation.
_InvalidCodecPrivateDataException :: AsError a => Getting (First ServiceError) a ServiceError

-- | A streaming session was requested for a stream that does not retain
--   data (that is, has a <tt>DataRetentionInHours</tt> of 0).
_NoDataRetentionException :: AsError a => Getting (First ServiceError) a ServiceError

-- | The type of the media (for example, h.264 or h.265 video or ACC or
--   G.711 audio) could not be determined from the codec IDs of the tracks
--   in the first fragment for a playback session. The codec ID for track 1
--   should be <tt>V_MPEG/ISO/AVC</tt> and, optionally, the codec ID for
--   track 2 should be <tt>A_AAC</tt>.
_UnsupportedStreamMediaTypeException :: AsError a => Getting (First ServiceError) a ServiceError

-- | <tt>GetMedia</tt> throws this error when Kinesis Video Streams can't
--   find the stream that you specified.
--   
--   <tt>GetHLSStreamingSessionURL</tt> and
--   <tt>GetDASHStreamingSessionURL</tt> throw this error if a session with
--   a <tt>PlaybackMode</tt> of <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>is requested for a stream that has no fragments
--   within the requested time range, or if a session with a
--   <tt>PlaybackMode</tt> of <tt>LIVE</tt> is requested for a stream that
--   has no fragments within the last 30 seconds.
_ResourceNotFoundException :: AsError a => Getting (First ServiceError) a ServiceError

-- | No codec private data was found in at least one of tracks of the video
--   stream.
_MissingCodecPrivateDataException :: AsError a => Getting (First ServiceError) a ServiceError

-- | Status Code: 403, The caller is not authorized to perform an operation
--   on the given stream, or the token has expired.
_NotAuthorizedException :: AsError a => Getting (First ServiceError) a ServiceError

-- | A specified parameter exceeds its restrictions, is not supported, or
--   can't be used.
_InvalidArgumentException :: AsError a => Getting (First ServiceError) a ServiceError

-- | <i>See:</i> <a>newListFragments</a> smart constructor.
data ListFragments
ListFragments' :: Maybe Text -> Maybe Natural -> Maybe Text -> Maybe Text -> Maybe FragmentSelector -> ListFragments

-- | Create a value of <a>ListFragments</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:nextToken:ListFragments'</a>, <a>listFragments_nextToken</a> -
--   A token to specify where to start paginating. This is the
--   ListFragmentsOutput$NextToken from a previously truncated response.
--   
--   <a>$sel:maxResults:ListFragments'</a>, <a>listFragments_maxResults</a>
--   - The total number of fragments to return. If the total number of
--   fragments available is more than the value specified in
--   <tt>max-results</tt>, then a ListFragmentsOutput$NextToken is provided
--   in the output that you can use to resume pagination.
--   
--   <a>$sel:streamARN:ListFragments'</a>, <a>listFragments_streamARN</a> -
--   The Amazon Resource Name (ARN) of the stream from which to retrieve a
--   fragment list. Specify either this parameter or the
--   <tt>StreamName</tt> parameter.
--   
--   <a>$sel:streamName:ListFragments'</a>, <a>listFragments_streamName</a>
--   - The name of the stream from which to retrieve a fragment list.
--   Specify either this parameter or the <tt>StreamARN</tt> parameter.
--   
--   <a>$sel:fragmentSelector:ListFragments'</a>,
--   <a>listFragments_fragmentSelector</a> - Describes the timestamp range
--   and timestamp origin for the range of fragments to return.
newListFragments :: ListFragments

-- | <i>See:</i> <a>newListFragmentsResponse</a> smart constructor.
data ListFragmentsResponse
ListFragmentsResponse' :: Maybe Text -> Maybe [Fragment] -> Int -> ListFragmentsResponse

-- | Create a value of <a>ListFragmentsResponse</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:nextToken:ListFragments'</a>,
--   <a>listFragmentsResponse_nextToken</a> - If the returned list is
--   truncated, the operation returns this token to use to retrieve the
--   next page of results. This value is <tt>null</tt> when there are no
--   more results to return.
--   
--   <a>$sel:fragments:ListFragmentsResponse'</a>,
--   <a>listFragmentsResponse_fragments</a> - A list of archived Fragment
--   objects from the stream that meet the selector criteria. Results are
--   in no specific order, even across pages.
--   
--   <a>$sel:httpStatus:ListFragmentsResponse'</a>,
--   <a>listFragmentsResponse_httpStatus</a> - The response's http status
--   code.
newListFragmentsResponse :: Int -> ListFragmentsResponse

-- | <i>See:</i> <a>newGetMediaForFragmentList</a> smart constructor.
data GetMediaForFragmentList
GetMediaForFragmentList' :: Maybe Text -> Maybe Text -> NonEmpty Text -> GetMediaForFragmentList

-- | Create a value of <a>GetMediaForFragmentList</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:streamARN:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream from which to retrieve fragment media. Specify
--   either this parameter or the <tt>StreamName</tt> parameter.
--   
--   <a>$sel:streamName:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_streamName</a> - The name of the stream
--   from which to retrieve fragment media. Specify either this parameter
--   or the <tt>StreamARN</tt> parameter.
--   
--   <a>$sel:fragments:GetMediaForFragmentList'</a>,
--   <a>getMediaForFragmentList_fragments</a> - A list of the numbers of
--   fragments for which to retrieve media. You retrieve these values with
--   ListFragments.
newGetMediaForFragmentList :: NonEmpty Text -> GetMediaForFragmentList

-- | <i>See:</i> <a>newGetMediaForFragmentListResponse</a> smart
--   constructor.
data GetMediaForFragmentListResponse
GetMediaForFragmentListResponse' :: Maybe Text -> Int -> ResponseBody -> GetMediaForFragmentListResponse

-- | Create a value of <a>GetMediaForFragmentListResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:contentType:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_contentType</a> - The content type
--   of the requested media.
--   
--   <a>$sel:httpStatus:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_httpStatus</a> - The response's
--   http status code.
--   
--   <a>$sel:payload:GetMediaForFragmentListResponse'</a>,
--   <a>getMediaForFragmentListResponse_payload</a> - The payload that
--   Kinesis Video Streams returns is a sequence of chunks from the
--   specified stream. For information about the chunks, see
--   <a>PutMedia</a>. The chunks that Kinesis Video Streams returns in the
--   <tt>GetMediaForFragmentList</tt> call also include the following
--   additional Matroska (MKV) tags:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the
--   chunk.</li>
--   <li>AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side timestamp of
--   the fragment.</li>
--   <li>AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side timestamp
--   of the fragment.</li>
--   </ul>
--   
--   The following tags will be included if an exception occurs:
--   
--   <ul>
--   <li>AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that
--   threw the exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the
--   exception</li>
--   <li>AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the
--   exception</li>
--   </ul>
newGetMediaForFragmentListResponse :: Int -> ResponseBody -> GetMediaForFragmentListResponse

-- | <i>See:</i> <a>newGetClip</a> smart constructor.
data GetClip
GetClip' :: Maybe Text -> Maybe Text -> ClipFragmentSelector -> GetClip

-- | Create a value of <a>GetClip</a> with all optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:streamARN:GetClip'</a>, <a>getClip_streamARN</a> - The Amazon
--   Resource Name (ARN) of the stream for which to retrieve the media
--   clip.
--   
--   You must specify either the StreamName or the StreamARN.
--   
--   <a>$sel:streamName:GetClip'</a>, <a>getClip_streamName</a> - The name
--   of the stream for which to retrieve the media clip.
--   
--   You must specify either the StreamName or the StreamARN.
--   
--   <a>$sel:clipFragmentSelector:GetClip'</a>,
--   <a>getClip_clipFragmentSelector</a> - The time range of the requested
--   clip and the source of the timestamps.
newGetClip :: ClipFragmentSelector -> GetClip

-- | <i>See:</i> <a>newGetClipResponse</a> smart constructor.
data GetClipResponse
GetClipResponse' :: Maybe Text -> Int -> ResponseBody -> GetClipResponse

-- | Create a value of <a>GetClipResponse</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:contentType:GetClipResponse'</a>,
--   <a>getClipResponse_contentType</a> - The content type of the media in
--   the requested clip.
--   
--   <a>$sel:httpStatus:GetClipResponse'</a>,
--   <a>getClipResponse_httpStatus</a> - The response's http status code.
--   
--   <a>$sel:payload:GetClipResponse'</a>, <a>getClipResponse_payload</a> -
--   Traditional MP4 file that contains the media clip from the specified
--   video stream. The output will contain the first 100 MB or the first
--   200 fragments from the specified start timestamp. For more
--   information, see <a>Kinesis Video Streams Limits</a>.
newGetClipResponse :: Int -> ResponseBody -> GetClipResponse

-- | <i>See:</i> <a>newGetDASHStreamingSessionURL</a> smart constructor.
data GetDASHStreamingSessionURL
GetDASHStreamingSessionURL' :: Maybe DASHDisplayFragmentTimestamp -> Maybe DASHDisplayFragmentNumber -> Maybe Natural -> Maybe DASHFragmentSelector -> Maybe DASHPlaybackMode -> Maybe Text -> Maybe Text -> Maybe Natural -> GetDASHStreamingSessionURL

-- | Create a value of <a>GetDASHStreamingSessionURL</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:displayFragmentTimestamp:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_displayFragmentTimestamp</a> - Per the
--   MPEG-DASH specification, the wall-clock time of fragments in the
--   manifest file can be derived using attributes in the manifest itself.
--   However, typically, MPEG-DASH compatible media players do not properly
--   handle gaps in the media timeline. Kinesis Video Streams adjusts the
--   media timeline in the manifest file to enable playback of media with
--   discontinuities. Therefore, the wall-clock time derived from the
--   manifest file may be inaccurate. If DisplayFragmentTimestamp is set to
--   <tt>ALWAYS</tt>, the accurate fragment timestamp is added to each S
--   element in the manifest file with the attribute name “kvs:ts”. A
--   custom MPEG-DASH media player is necessary to leverage this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>. When DASHFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when DASHFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
--   
--   <a>$sel:displayFragmentNumber:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_displayFragmentNumber</a> - Fragments
--   are identified in the manifest file based on their sequence number in
--   the session. If DisplayFragmentNumber is set to <tt>ALWAYS</tt>, the
--   Kinesis Video Streams fragment number is added to each S element in
--   the manifest file with the attribute name “kvs:fn”. These fragment
--   numbers can be used for logging or for use with other APIs (e.g.
--   <tt>GetMedia</tt> and <tt>GetMediaForFragmentList</tt>). A custom
--   MPEG-DASH media player is necessary to leverage these this custom
--   attribute.
--   
--   The default value is <tt>NEVER</tt>.
--   
--   <a>$sel:maxManifestFragmentResults:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_maxManifestFragmentResults</a> - The
--   maximum number of fragments that are returned in the MPEG-DASH
--   manifest.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live
--   MPEG-DASH manifest, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live MPEG-DASH manifest have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 1,000 fragments corresponds to more than 16
--   minutes of video on streams with 1-second fragments, and more than 2
--   1/2 hours of video on streams with 10-second fragments.
--   
--   <a>$sel:dASHFragmentSelector:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_dASHFragmentSelector</a> - The time
--   range of the requested fragment and the source of the timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
--   
--   <a>$sel:playbackMode:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_playbackMode</a> - Whether to retrieve
--   live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the MPEG-DASH
--   manifest is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   manifest on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an MPEG-DASH manifest, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the MPEG-DASH
--   manifest if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the manifest, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the manifest every two seconds.
--   This mode is useful to be able to start playback from when an event is
--   detected and continue live streaming media that has not yet been
--   ingested as of the time of the session creation. This mode is also
--   useful to stream previously archived media without being limited by
--   the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the
--   MPEG-DASH manifest contains all the fragments for the session, up to
--   the number that is specified in <tt>MaxManifestFragmentResults</tt>.
--   The manifest must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the larger fragment
--   number (that is, the newer fragment) is included in the MPEG-DASH
--   manifest. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the MPEG-DASH manifest. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
--   
--   <a>$sel:streamARN:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream for which to retrieve the MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:streamName:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_streamName</a> - The name of the stream
--   for which to retrieve the MPEG-DASH manifest URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:expires:GetDASHStreamingSessionURL'</a>,
--   <a>getDASHStreamingSessionURL_expires</a> - The time in seconds until
--   the requested session expires. This value can be between 300 (5
--   minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetDashManifest</tt>,
--   <tt>GetMP4InitFragment</tt>, or <tt>GetMP4MediaFragment</tt> can be
--   made for that session.
--   
--   The default is 300 (5 minutes).
newGetDASHStreamingSessionURL :: GetDASHStreamingSessionURL

-- | <i>See:</i> <a>newGetDASHStreamingSessionURLResponse</a> smart
--   constructor.
data GetDASHStreamingSessionURLResponse
GetDASHStreamingSessionURLResponse' :: Maybe Text -> Int -> GetDASHStreamingSessionURLResponse

-- | Create a value of <a>GetDASHStreamingSessionURLResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   
--   <a>$sel:dASHStreamingSessionURL:GetDASHStreamingSessionURLResponse'</a>,
--   <a>getDASHStreamingSessionURLResponse_dASHStreamingSessionURL</a> -
--   The URL (containing the session token) that a media player can use to
--   retrieve the MPEG-DASH manifest.
--   
--   <a>$sel:httpStatus:GetDASHStreamingSessionURLResponse'</a>,
--   <a>getDASHStreamingSessionURLResponse_httpStatus</a> - The response's
--   http status code.
newGetDASHStreamingSessionURLResponse :: Int -> GetDASHStreamingSessionURLResponse

-- | <i>See:</i> <a>newGetHLSStreamingSessionURL</a> smart constructor.
data GetHLSStreamingSessionURL
GetHLSStreamingSessionURL' :: Maybe Natural -> Maybe ContainerFormat -> Maybe HLSDisplayFragmentTimestamp -> Maybe HLSPlaybackMode -> Maybe Text -> Maybe Text -> Maybe Natural -> Maybe HLSDiscontinuityMode -> Maybe HLSFragmentSelector -> GetHLSStreamingSessionURL

-- | Create a value of <a>GetHLSStreamingSessionURL</a> with all optional
--   fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   
--   <a>$sel:maxMediaPlaylistFragmentResults:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_maxMediaPlaylistFragmentResults</a> - The
--   maximum number of fragments that are returned in the HLS media
--   playlists.
--   
--   When the <tt>PlaybackMode</tt> is <tt>LIVE</tt>, the most recent
--   fragments are returned up to this value. When the
--   <tt>PlaybackMode</tt> is <tt>ON_DEMAND</tt>, the oldest fragments are
--   returned, up to this maximum number.
--   
--   When there are a higher number of fragments available in a live HLS
--   media playlist, video players often buffer content before starting
--   playback. Increasing the buffer size increases the playback latency,
--   but it decreases the likelihood that rebuffering will occur during
--   playback. We recommend that a live HLS media playlist have a minimum
--   of 3 fragments and a maximum of 10 fragments.
--   
--   The default is 5 fragments if <tt>PlaybackMode</tt> is <tt>LIVE</tt>
--   or <tt>LIVE_REPLAY</tt>, and 1,000 if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt>.
--   
--   The maximum value of 5,000 fragments corresponds to more than 80
--   minutes of video on streams with 1-second fragments, and more than 13
--   hours of video on streams with 10-second fragments.
--   
--   <a>$sel:containerFormat:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_containerFormat</a> - Specifies which
--   format should be used for packaging the media. Specifying the
--   <tt>FRAGMENTED_MP4</tt> container format packages the media into MP4
--   fragments (fMP4 or CMAF). This is the recommended packaging because
--   there is minimal packaging overhead. The other container format option
--   is <tt>MPEG_TS</tt>. HLS has supported MPEG TS chunks since it was
--   released and is sometimes the only supported packaging on older HLS
--   players. MPEG TS typically has a 5-25 percent packaging overhead. This
--   means MPEG TS typically requires 5-25 percent more bandwidth and cost
--   than fMP4.
--   
--   The default is <tt>FRAGMENTED_MP4</tt>.
--   
--   <a>$sel:displayFragmentTimestamp:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_displayFragmentTimestamp</a> - Specifies
--   when the fragment start timestamps should be included in the HLS media
--   playlist. Typically, media players report the playhead position as a
--   time relative to the start of the first fragment in the playback
--   session. However, when the start timestamps are included in the HLS
--   media playlist, some media players might report the current playhead
--   as an absolute time based on the fragment timestamps. This can be
--   useful for creating a playback experience that shows viewers the
--   wall-clock time of the media.
--   
--   The default is <tt>NEVER</tt>. When HLSFragmentSelector is
--   <tt>SERVER_TIMESTAMP</tt>, the timestamps will be the server start
--   timestamps. Similarly, when HLSFragmentSelector is
--   <tt>PRODUCER_TIMESTAMP</tt>, the timestamps will be the producer start
--   timestamps.
--   
--   <a>$sel:playbackMode:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_playbackMode</a> - Whether to retrieve
--   live, live replay, or archived, on-demand data.
--   
--   Features of the three types of sessions include the following:
--   
--   <ul>
--   <li><b><tt>LIVE</tt></b> : For sessions of this type, the HLS media
--   playlist is continually updated with the latest fragments as they
--   become available. We recommend that the media player retrieve a new
--   playlist on a one-second interval. When this type of session is played
--   in a media player, the user interface typically displays a "live"
--   notification, with no scrubber control for choosing the position in
--   the playback window to display.In <tt>LIVE</tt> mode, the newest
--   available fragments are included in an HLS media playlist, even if
--   there is a gap between fragments (that is, if a fragment is missing).
--   A gap like this might cause a media player to halt or cause a jump in
--   playback. In this mode, fragments are not added to the HLS media
--   playlist if they are older than the newest fragment in the playlist.
--   If the missing fragment becomes available after a subsequent fragment
--   is added to the playlist, the older fragment is not added, and the gap
--   is not filled.</li>
--   <li><b><tt>LIVE_REPLAY</tt></b> : For sessions of this type, the HLS
--   media playlist is updated similarly to how it is updated for
--   <tt>LIVE</tt> mode except that it starts by including fragments from a
--   given start time. Instead of fragments being added as they are
--   ingested, fragments are added as the duration of the next fragment
--   elapses. For example, if the fragments in the session are two seconds
--   long, then a new fragment is added to the media playlist every two
--   seconds. This mode is useful to be able to start playback from when an
--   event is detected and continue live streaming media that has not yet
--   been ingested as of the time of the session creation. This mode is
--   also useful to stream previously archived media without being limited
--   by the 1,000 fragment limit in the <tt>ON_DEMAND</tt> mode.</li>
--   <li><b><tt>ON_DEMAND</tt></b> : For sessions of this type, the HLS
--   media playlist contains all the fragments for the session, up to the
--   number that is specified in <tt>MaxMediaPlaylistFragmentResults</tt>.
--   The playlist must be retrieved only once for each session. When this
--   type of session is played in a media player, the user interface
--   typically displays a scrubber control for choosing the position in the
--   playback window to display.</li>
--   </ul>
--   
--   In all playback modes, if <tt>FragmentSelectorType</tt> is
--   <tt>PRODUCER_TIMESTAMP</tt>, and if there are multiple fragments with
--   the same start timestamp, the fragment that has the largest fragment
--   number (that is, the newest fragment) is included in the HLS media
--   playlist. The other fragments are not included. Fragments that have
--   different timestamps but have overlapping durations are still included
--   in the HLS media playlist. This can lead to unexpected behavior in the
--   media player.
--   
--   The default is <tt>LIVE</tt>.
--   
--   <a>$sel:streamARN:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_streamARN</a> - The Amazon Resource Name
--   (ARN) of the stream for which to retrieve the HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:streamName:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_streamName</a> - The name of the stream
--   for which to retrieve the HLS master playlist URL.
--   
--   You must specify either the <tt>StreamName</tt> or the
--   <tt>StreamARN</tt>.
--   
--   <a>$sel:expires:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_expires</a> - The time in seconds until
--   the requested session expires. This value can be between 300 (5
--   minutes) and 43200 (12 hours).
--   
--   When a session expires, no new calls to <tt>GetHLSMasterPlaylist</tt>,
--   <tt>GetHLSMediaPlaylist</tt>, <tt>GetMP4InitFragment</tt>,
--   <tt>GetMP4MediaFragment</tt>, or <tt>GetTSFragment</tt> can be made
--   for that session.
--   
--   The default is 300 (5 minutes).
--   
--   <a>$sel:discontinuityMode:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_discontinuityMode</a> - Specifies when
--   flags marking discontinuities between fragments are added to the media
--   playlists.
--   
--   Media players typically build a timeline of media content to play,
--   based on the timestamps of each fragment. This means that if there is
--   any overlap or gap between fragments (as is typical if
--   HLSFragmentSelector is set to <tt>SERVER_TIMESTAMP</tt>), the media
--   player timeline will also have small gaps between fragments in some
--   places, and will overwrite frames in other places. Gaps in the media
--   player timeline can cause playback to stall and overlaps can cause
--   playback to be jittery. When there are discontinuity flags between
--   fragments, the media player is expected to reset the timeline,
--   resulting in the next fragment being played immediately after the
--   previous fragment.
--   
--   The following modes are supported:
--   
--   <ul>
--   <li><tt>ALWAYS</tt>: a discontinuity marker is placed between every
--   fragment in the HLS media playlist. It is recommended to use a value
--   of <tt>ALWAYS</tt> if the fragment timestamps are not accurate.</li>
--   <li><tt>NEVER</tt>: no discontinuity markers are placed anywhere. It
--   is recommended to use a value of <tt>NEVER</tt> to ensure the media
--   player timeline most accurately maps to the producer timestamps.</li>
--   <li><tt>ON_DISCONTINUITY</tt>: a discontinuity marker is placed
--   between fragments that have a gap or overlap of more than 50
--   milliseconds. For most playback scenarios, it is recommended to use a
--   value of <tt>ON_DISCONTINUITY</tt> so that the media player timeline
--   is only reset when there is a significant issue with the media
--   timeline (e.g. a missing fragment).</li>
--   </ul>
--   
--   The default is <tt>ALWAYS</tt> when HLSFragmentSelector is set to
--   <tt>SERVER_TIMESTAMP</tt>, and <tt>NEVER</tt> when it is set to
--   <tt>PRODUCER_TIMESTAMP</tt>.
--   
--   <a>$sel:hLSFragmentSelector:GetHLSStreamingSessionURL'</a>,
--   <a>getHLSStreamingSessionURL_hLSFragmentSelector</a> - The time range
--   of the requested fragment and the source of the timestamps.
--   
--   This parameter is required if <tt>PlaybackMode</tt> is
--   <tt>ON_DEMAND</tt> or <tt>LIVE_REPLAY</tt>. This parameter is optional
--   if PlaybackMode is@<tt> </tt>LIVE<tt>. If </tt>PlaybackMode<tt> is
--   </tt>LIVE<tt>, the </tt>FragmentSelectorType<tt> can be set, but the
--   </tt>TimestampRange<tt> should not be set. If </tt>PlaybackMode<tt> is
--   </tt>ON_DEMAND<tt> or </tt>LIVE_REPLAY<tt>, both
--   </tt>FragmentSelectorType<tt> and </tt>TimestampRange@ must be set.
newGetHLSStreamingSessionURL :: GetHLSStreamingSessionURL

-- | <i>See:</i> <a>newGetHLSStreamingSessionURLResponse</a> smart
--   constructor.
data GetHLSStreamingSessionURLResponse
GetHLSStreamingSessionURLResponse' :: Maybe Text -> Int -> GetHLSStreamingSessionURLResponse

-- | Create a value of <a>GetHLSStreamingSessionURLResponse</a> with all
--   optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:hLSStreamingSessionURL:GetHLSStreamingSessionURLResponse'</a>,
--   <a>getHLSStreamingSessionURLResponse_hLSStreamingSessionURL</a> - The
--   URL (containing the session token) that a media player can use to
--   retrieve the HLS master playlist.
--   
--   <a>$sel:httpStatus:GetHLSStreamingSessionURLResponse'</a>,
--   <a>getHLSStreamingSessionURLResponse_httpStatus</a> - The response's
--   http status code.
newGetHLSStreamingSessionURLResponse :: Int -> GetHLSStreamingSessionURLResponse
newtype ClipFragmentSelectorType
ClipFragmentSelectorType' :: Text -> ClipFragmentSelectorType
[fromClipFragmentSelectorType] :: ClipFragmentSelectorType -> Text
pattern ClipFragmentSelectorType_PRODUCER_TIMESTAMP :: ClipFragmentSelectorType
pattern ClipFragmentSelectorType_SERVER_TIMESTAMP :: ClipFragmentSelectorType
newtype ContainerFormat
ContainerFormat' :: Text -> ContainerFormat
[fromContainerFormat] :: ContainerFormat -> Text
pattern ContainerFormat_FRAGMENTED_MP4 :: ContainerFormat
pattern ContainerFormat_MPEG_TS :: ContainerFormat
newtype DASHDisplayFragmentNumber
DASHDisplayFragmentNumber' :: Text -> DASHDisplayFragmentNumber
[fromDASHDisplayFragmentNumber] :: DASHDisplayFragmentNumber -> Text
pattern DASHDisplayFragmentNumber_ALWAYS :: DASHDisplayFragmentNumber
pattern DASHDisplayFragmentNumber_NEVER :: DASHDisplayFragmentNumber
newtype DASHDisplayFragmentTimestamp
DASHDisplayFragmentTimestamp' :: Text -> DASHDisplayFragmentTimestamp
[fromDASHDisplayFragmentTimestamp] :: DASHDisplayFragmentTimestamp -> Text
pattern DASHDisplayFragmentTimestamp_ALWAYS :: DASHDisplayFragmentTimestamp
pattern DASHDisplayFragmentTimestamp_NEVER :: DASHDisplayFragmentTimestamp
newtype DASHFragmentSelectorType
DASHFragmentSelectorType' :: Text -> DASHFragmentSelectorType
[fromDASHFragmentSelectorType] :: DASHFragmentSelectorType -> Text
pattern DASHFragmentSelectorType_PRODUCER_TIMESTAMP :: DASHFragmentSelectorType
pattern DASHFragmentSelectorType_SERVER_TIMESTAMP :: DASHFragmentSelectorType
newtype DASHPlaybackMode
DASHPlaybackMode' :: Text -> DASHPlaybackMode
[fromDASHPlaybackMode] :: DASHPlaybackMode -> Text
pattern DASHPlaybackMode_LIVE :: DASHPlaybackMode
pattern DASHPlaybackMode_LIVE_REPLAY :: DASHPlaybackMode
pattern DASHPlaybackMode_ON_DEMAND :: DASHPlaybackMode
newtype FragmentSelectorType
FragmentSelectorType' :: Text -> FragmentSelectorType
[fromFragmentSelectorType] :: FragmentSelectorType -> Text
pattern FragmentSelectorType_PRODUCER_TIMESTAMP :: FragmentSelectorType
pattern FragmentSelectorType_SERVER_TIMESTAMP :: FragmentSelectorType
newtype HLSDiscontinuityMode
HLSDiscontinuityMode' :: Text -> HLSDiscontinuityMode
[fromHLSDiscontinuityMode] :: HLSDiscontinuityMode -> Text
pattern HLSDiscontinuityMode_ALWAYS :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_NEVER :: HLSDiscontinuityMode
pattern HLSDiscontinuityMode_ON_DISCONTINUITY :: HLSDiscontinuityMode
newtype HLSDisplayFragmentTimestamp
HLSDisplayFragmentTimestamp' :: Text -> HLSDisplayFragmentTimestamp
[fromHLSDisplayFragmentTimestamp] :: HLSDisplayFragmentTimestamp -> Text
pattern HLSDisplayFragmentTimestamp_ALWAYS :: HLSDisplayFragmentTimestamp
pattern HLSDisplayFragmentTimestamp_NEVER :: HLSDisplayFragmentTimestamp
newtype HLSFragmentSelectorType
HLSFragmentSelectorType' :: Text -> HLSFragmentSelectorType
[fromHLSFragmentSelectorType] :: HLSFragmentSelectorType -> Text
pattern HLSFragmentSelectorType_PRODUCER_TIMESTAMP :: HLSFragmentSelectorType
pattern HLSFragmentSelectorType_SERVER_TIMESTAMP :: HLSFragmentSelectorType
newtype HLSPlaybackMode
HLSPlaybackMode' :: Text -> HLSPlaybackMode
[fromHLSPlaybackMode] :: HLSPlaybackMode -> Text
pattern HLSPlaybackMode_LIVE :: HLSPlaybackMode
pattern HLSPlaybackMode_LIVE_REPLAY :: HLSPlaybackMode
pattern HLSPlaybackMode_ON_DEMAND :: HLSPlaybackMode

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the clip will contain all of the fragments within the requested
--   timestamp range. If some fragments are ingested within the same time
--   range and very different points in time, only the oldest ingested
--   collection of fragments are returned.
--   
--   <i>See:</i> <a>newClipFragmentSelector</a> smart constructor.
data ClipFragmentSelector
ClipFragmentSelector' :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | Create a value of <a>ClipFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:ClipFragmentSelector'</a>,
--   <a>clipFragmentSelector_timestampRange</a> - The range of timestamps
--   to return.
newClipFragmentSelector :: ClipFragmentSelectorType -> ClipTimestampRange -> ClipFragmentSelector

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newClipTimestampRange</a> smart constructor.
data ClipTimestampRange
ClipTimestampRange' :: POSIX -> POSIX -> ClipTimestampRange

-- | Create a value of <a>ClipTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_startTimestamp</a> - The starting timestamp in
--   the range of timestamps for which to return fragments.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
--   
--   <a>$sel:endTimestamp:ClipTimestampRange'</a>,
--   <a>clipTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media.
--   
--   This value must be within 24 hours of the specified
--   <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value. If <tt>FragmentSelectorType</tt> for
--   the request is <tt>SERVER_TIMESTAMP</tt>, this value must be in the
--   past.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
newClipTimestampRange :: UTCTime -> UTCTime -> ClipTimestampRange

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newDASHFragmentSelector</a> smart constructor.
data DASHFragmentSelector
DASHFragmentSelector' :: Maybe DASHFragmentSelectorType -> Maybe DASHTimestampRange -> DASHFragmentSelector

-- | Create a value of <a>DASHFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetDASHStreamingSessionURLInput$MaxManifestFragmentResults value) are
--   included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the MPEG-DASH manifest will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetDASHStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the MPEG-DASH manifest. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:DASHFragmentSelector'</a>,
--   <a>dASHFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newDASHFragmentSelector :: DASHFragmentSelector

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   The values in <tt>DASHimestampRange</tt> are inclusive. Fragments that
--   start exactly at or after the start time are included in the session.
--   Fragments that start before the start time and continue past it are
--   not included in the session.
--   
--   <i>See:</i> <a>newDASHTimestampRange</a> smart constructor.
data DASHTimestampRange
DASHTimestampRange' :: Maybe POSIX -> Maybe POSIX -> DASHTimestampRange

-- | Create a value of <a>DASHTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_endTimestamp</a> - The end of the timestamp
--   range for the requested media. This value must be within 24 hours of
--   the specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:DASHTimestampRange'</a>,
--   <a>dASHTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>DASHTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newDASHTimestampRange :: DASHTimestampRange

-- | Represents a segment of video or other time-delimited data.
--   
--   <i>See:</i> <a>newFragment</a> smart constructor.
data Fragment
Fragment' :: Maybe POSIX -> Maybe POSIX -> Maybe Text -> Maybe Integer -> Maybe Integer -> Fragment

-- | Create a value of <a>Fragment</a> with all optional fields omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:producerTimestamp:Fragment'</a>,
--   <a>fragment_producerTimestamp</a> - The timestamp from the producer
--   corresponding to the fragment.
--   
--   <a>$sel:serverTimestamp:Fragment'</a>, <a>fragment_serverTimestamp</a>
--   - The timestamp from the AWS server corresponding to the fragment.
--   
--   <a>$sel:fragmentNumber:Fragment'</a>, <a>fragment_fragmentNumber</a> -
--   The unique identifier of the fragment. This value monotonically
--   increases based on the ingestion order.
--   
--   <a>$sel:fragmentSizeInBytes:Fragment'</a>,
--   <a>fragment_fragmentSizeInBytes</a> - The total fragment size,
--   including information about the fragment and contained media data.
--   
--   <a>$sel:fragmentLengthInMilliseconds:Fragment'</a>,
--   <a>fragment_fragmentLengthInMilliseconds</a> - The playback duration
--   or other time value associated with the fragment.
newFragment :: Fragment

-- | Describes the timestamp range and timestamp origin of a range of
--   fragments.
--   
--   Only fragments with a start timestamp greater than or equal to the
--   given start time and less than or equal to the end time are returned.
--   For example, if a stream contains fragments with the following start
--   timestamps:
--   
--   <ul>
--   <li>00:00:00</li>
--   <li>00:00:02</li>
--   <li>00:00:04</li>
--   <li>00:00:06</li>
--   </ul>
--   
--   A fragment selector range with a start time of 00:00:01 and end time
--   of 00:00:04 would return the fragments with start times of 00:00:02
--   and 00:00:04.
--   
--   <i>See:</i> <a>newFragmentSelector</a> smart constructor.
data FragmentSelector
FragmentSelector' :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | Create a value of <a>FragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:FragmentSelector'</a>,
--   <a>fragmentSelector_fragmentSelectorType</a> - The origin of the
--   timestamps to use (Server or Producer).
--   
--   <a>$sel:timestampRange:FragmentSelector'</a>,
--   <a>fragmentSelector_timestampRange</a> - The range of timestamps to
--   return.
newFragmentSelector :: FragmentSelectorType -> TimestampRange -> FragmentSelector

-- | Contains the range of timestamps for the requested media, and the
--   source of the timestamps.
--   
--   <i>See:</i> <a>newHLSFragmentSelector</a> smart constructor.
data HLSFragmentSelector
HLSFragmentSelector' :: Maybe HLSFragmentSelectorType -> Maybe HLSTimestampRange -> HLSFragmentSelector

-- | Create a value of <a>HLSFragmentSelector</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:fragmentSelectorType:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_fragmentSelectorType</a> - The source of the
--   timestamps for the requested media.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>ON_DEMAND</tt> or
--   <tt>LIVE_REPLAY</tt>, the first fragment ingested with a producer
--   timestamp within the specified FragmentSelector$TimestampRange is
--   included in the media playlist. In addition, the fragments with
--   producer timestamps within the <tt>TimestampRange</tt> ingested
--   immediately following the first fragment (up to the
--   GetHLSStreamingSessionURLInput$MaxMediaPlaylistFragmentResults value)
--   are included.
--   
--   Fragments that have duplicate producer timestamps are deduplicated.
--   This means that if producers are producing a stream of fragments with
--   producer timestamps that are approximately equal to the true clock
--   time, the HLS media playlists will contain all of the fragments within
--   the requested timestamp range. If some fragments are ingested within
--   the same time range and very different points in time, only the oldest
--   ingested collection of fragments are returned.
--   
--   When <tt>FragmentSelectorType</tt> is set to
--   <tt>PRODUCER_TIMESTAMP</tt> and
--   GetHLSStreamingSessionURLInput$PlaybackMode is <tt>LIVE</tt>, the
--   producer timestamps are used in the MP4 fragments and for
--   deduplication. But the most recently ingested fragments based on
--   server timestamps are included in the HLS media playlist. This means
--   that even if fragments ingested in the past have producer timestamps
--   with values now, they are not included in the HLS media playlist.
--   
--   The default is <tt>SERVER_TIMESTAMP</tt>.
--   
--   <a>$sel:timestampRange:HLSFragmentSelector'</a>,
--   <a>hLSFragmentSelector_timestampRange</a> - The start and end of the
--   timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
newHLSFragmentSelector :: HLSFragmentSelector

-- | The start and end of the timestamp range for the requested media.
--   
--   This value should not be present if <tt>PlaybackType</tt> is
--   <tt>LIVE</tt>.
--   
--   <i>See:</i> <a>newHLSTimestampRange</a> smart constructor.
data HLSTimestampRange
HLSTimestampRange' :: Maybe POSIX -> Maybe POSIX -> HLSTimestampRange

-- | Create a value of <a>HLSTimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:endTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_endTimestamp</a> - The end of the timestamp range
--   for the requested media. This value must be within 24 hours of the
--   specified <tt>StartTimestamp</tt>, and it must be later than the
--   <tt>StartTimestamp</tt> value.
--   
--   If <tt>FragmentSelectorType</tt> for the request is
--   <tt>SERVER_TIMESTAMP</tt>, this value must be in the past.
--   
--   The <tt>EndTimestamp</tt> value is required for <tt>ON_DEMAND</tt>
--   mode, but optional for <tt>LIVE_REPLAY</tt> mode. If the
--   <tt>EndTimestamp</tt> is not set for <tt>LIVE_REPLAY</tt> mode then
--   the session will continue to include newly ingested fragments until
--   the session expires.
--   
--   This value is inclusive. The <tt>EndTimestamp</tt> is compared to the
--   (starting) timestamp of the fragment. Fragments that start before the
--   <tt>EndTimestamp</tt> value and continue past it are included in the
--   session.
--   
--   <a>$sel:startTimestamp:HLSTimestampRange'</a>,
--   <a>hLSTimestampRange_startTimestamp</a> - The start of the timestamp
--   range for the requested media.
--   
--   If the <tt>HLSTimestampRange</tt> value is specified, the
--   <tt>StartTimestamp</tt> value is required.
--   
--   Only fragments that start exactly at or after <tt>StartTimestamp</tt>
--   are included in the session. Fragments that start before
--   <tt>StartTimestamp</tt> and continue past it aren't included in the
--   session. If <tt>FragmentSelectorType</tt> is
--   <tt>SERVER_TIMESTAMP</tt>, the <tt>StartTimestamp</tt> must be later
--   than the stream head.
newHLSTimestampRange :: HLSTimestampRange

-- | The range of timestamps for which to return fragments.
--   
--   <i>See:</i> <a>newTimestampRange</a> smart constructor.
data TimestampRange
TimestampRange' :: POSIX -> POSIX -> TimestampRange

-- | Create a value of <a>TimestampRange</a> with all optional fields
--   omitted.
--   
--   Use <a>generic-lens</a> or <a>optics</a> to modify other optional
--   fields.
--   
--   The following record fields are available, with the corresponding
--   lenses provided for backwards compatibility:
--   
--   <a>$sel:startTimestamp:TimestampRange'</a>,
--   <a>timestampRange_startTimestamp</a> - The starting timestamp in the
--   range of timestamps for which to return fragments.
--   
--   <a>$sel:endTimestamp:TimestampRange'</a>,
--   <a>timestampRange_endTimestamp</a> - The ending timestamp in the range
--   of timestamps for which to return fragments.
newTimestampRange :: UTCTime -> UTCTime -> TimestampRange
