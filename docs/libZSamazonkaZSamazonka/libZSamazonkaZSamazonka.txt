-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package libZSamazonkaZSamazonka
@version 1.6.1


module Network.AWS.Lens

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice (p :: Type -> Type -> Type)

-- | A variant of <a>throwing</a> that can only be used within the
--   <tt>IO</tt> <a>Monad</a> (or any other <a>MonadCatch</a> instance) to
--   throw an <a>Exception</a> described by a <a>Prism</a>.
--   
--   Although <a>throwingM</a> has a type that is a specialization of the
--   type of <a>throwing</a>, the two functions are subtly different:
--   
--   <pre>
--   <a>throwing</a> l e `seq` x  ≡ <a>throwing</a> e
--   <a>throwingM</a> l e `seq` x ≡ x
--   </pre>
--   
--   The first example will cause the <a>Exception</a> <tt>e</tt> to be
--   raised, whereas the second one won't. In fact, <a>throwingM</a> will
--   only cause an <a>Exception</a> to be raised when it is used within the
--   <a>MonadCatch</a> instance. The <a>throwingM</a> variant should be
--   used in preference to <a>throwing</a> to raise an <a>Exception</a>
--   within the <a>Monad</a> because it guarantees ordering with respect to
--   other monadic operations, whereas <a>throwing</a> does not.
--   
--   <pre>
--   <a>throwingM</a> l ≡ <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m r
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m r
--   </pre>
throwingM :: MonadThrow m => AReview SomeException b -> b -> m r

-- | A variant of <a>try</a> that takes a <a>Prism</a> (or any <a>Fold</a>)
--   to select which exceptions are caught (c.f. <a>tryJust</a>,
--   <a>catchJust</a>). If the <a>Exception</a> does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particularly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   &gt;&gt;&gt; catching_ _AssertionFailed (assert False (return "uncaught")) $ return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any <a>Fold</a>,
--   really).
--   
--   <pre>
--   &gt;&gt;&gt; catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -&gt; return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | Traverse the strongly typed <a>Exception</a> contained in
--   <a>SomeException</a> where the type of your function matches the
--   desired <a>Exception</a>.
--   
--   <pre>
--   <a>exception</a> :: (<a>Applicative</a> f, <a>Exception</a> a)
--             =&gt; (a -&gt; f a) -&gt; <a>SomeException</a> -&gt; f <a>SomeException</a>
--   </pre>
exception :: Exception a => Prism' SomeException a

-- | Unfortunately the name <tt>ioException</tt> is taken by <tt>base</tt>
--   for throwing IOExceptions.
--   
--   <pre>
--   <a>_IOException</a> :: <a>Prism'</a> <a>IOException</a> <a>IOException</a>
--   <a>_IOException</a> :: <a>Prism'</a> <a>SomeException</a> <a>IOException</a>
--   </pre>
--   
--   Many combinators for working with an <a>IOException</a> are available
--   in <a>System.IO.Error.Lens</a>.
_IOException :: AsIOException t => Prism' t IOException

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList "abcde" &amp; _last .~ 'Q') == Vector.fromList "abcdQ"
--   True
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a

-- | Data types that are representationally equal are isomorphic.
--   
--   This is only available on GHC 7.8+
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: forall (f :: Type -> Type) (g :: Type -> Type) s t a b. (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g) ≡ f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g)) ≡ g
--   <a>over</a> (<a>iso</a> f g) h ≡ g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h ≡ f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees. This is because <a>^?</a> works by using the
--   <a>First</a> monoid, which can occasionally cause space leaks.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   This operator works as an infix version of <a>preview</a>.
--   
--   <pre>
--   (<a>^?</a>) ≡ <a>flip</a> <a>preview</a>
--   </pre>
--   
--   It may be helpful to think of <a>^?</a> as having one of the following
--   more specialized types:
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a
infixl 8 ^?

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a> ≡ <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a> ≡ <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l ≡ <a>anyOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..id
--   [[[1,2],[3]]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse
--   [[1,2],[3]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs ≡ xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>a</a> :: s -&gt; <a>Fold</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Lens'</a> s a      -&gt; <a>a</a> :: s -&gt; <a>Iso'</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Traversal'</a> s a -&gt; <a>a</a> :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | Obtain a <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that fails the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding tail
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a> ≡ m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x ≡ f x
--   l # x ≡ x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = a -> Const r a -> s -> Const r s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Modify the target of a <a>Semigroup</a> value by using
--   <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
infixr 4 <>~

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t ≡ <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <a>?~</a> can be used type-changily:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', ('b', 'c')) &amp; _2.both ?~ 'x'
--   ('a',(Just 'x',Just 'x'))
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged :: Type -> Type -> Type Identity t b

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall (f :: Type -> Type). (Contravariant f, Functor f) => a -> f a -> s -> f s

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall (f :: Type -> Type). (Contravariant f, Applicative f) => a -> f a -> s -> f s

-- | <pre>
--   type <a>Optic'</a> p f s a = <a>Simple</a> (<a>Optic</a> p f) s a
--   </pre>
type Optic' (p :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optic p f s s a a


-- | An intentionally limited set of prelude exports to control backward
--   compatibility and simplify code generation.
--   
--   Please consider long and hard before adding any addtional types
--   exports to this module - they should either be in pervasive use
--   throughout the project or have zero ambiguity. If you ever are forced
--   to disambiguate at any point, it's a bad export.
--   
--   Try and avoid any value, operator, or symbol exports, if possible.
--   Most of the ones here exist to ease legacy code-migration.
module Network.AWS.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall (r :: RuntimeRep) a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
--   
--   This function is runtime-representation polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt>coerce @Int @Age 42</tt>.
coerce :: forall (k :: RuntimeRep) (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type family Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `mod`
infixl 7 `div`
infixl 7 `rem`
infixl 7 `quot`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | Using <tt>ApplicativeDo</tt>: '<tt><a>fmap</a> f as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      pure (f a)
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>a <a>&lt;$</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do bs
--      pure a
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >
infix 4 >=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>fs <a>&lt;*&gt;</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do f &lt;- fs
--      a &lt;- as
--      pure (f a)
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
--   
--   '<tt>as <a>*&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
--   
--   This is a tad complicated for our <tt>ApplicativeDo</tt> extension
--   which will give it a <tt>Monad</tt> constraint. For an
--   <tt>Applicative</tt> constraint we write it of the form
--   
--   <pre>
--   do _ &lt;- as
--      b &lt;- bs
--      pure b
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>&lt;*</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      bs
--      pure a
--   </pre>
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   A result of the naturality law is a purity law for <a>traverse</a>
--   
--   <pre>
--   <a>traverse</a> <a>pure</a> = <a>pure</a>
--   </pre>
--   
--   (The naturality law is implied by parametricity and thus so is the
--   purity law [1, p15].)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
--   
--   References: [1] The Essence of the Iterator Pattern, Jeremy Gibbons
--   and Bruno C. d. S. Oliveira
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = Type

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | (Kind) This is the kind of type-level symbols. Declared here because
--   class IP needs it
data Symbol

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant (f :: Type -> Type)

-- | Uninhabited data type
data Void

-- | The <a>Item</a> type function returns the type of items of the
--   structure <tt>l</tt>.
type family Item l

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bifoldMapDefault</a> f g ≡
--       <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
bifoldMapDefault :: (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bimapDefault</a> f g ≡
--        <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   </pre>
bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | The <a>bimapAccumR</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from right
--   to left, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The <a>bimapAccumL</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from left to
--   right, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | Alias for <a>bifor</a>.
biforM :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | Alias for <a>bitraverse</a>.
bimapM :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Alias for <a>bisequence</a>.
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>bitraverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t .
--   <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>Compose</a> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡
--   <a>bitraverse</a> (<a>Compose</a> . <a>fmap</a> g1 . f1)
--   (<a>Compose</a> . <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   Some simple examples are <a>Either</a> and <tt>(,)</tt>:
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable (t :: Type -> Type -> Type)

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the results produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a

-- | <a>binotElem</a> is the negation of <a>bielem</a>.
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | Determines whether all elements of the structure satisfy their
--   appropriate predicate argument.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether any element of the structure satisfies its
--   appropriate predicate argument.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
bior :: Bifoldable t => t Bool Bool -> Bool

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
biand :: Bifoldable t => t Bool Bool -> Bool

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | The <a>biproduct</a> function computes the product of the numbers of a
--   structure.
biproduct :: (Bifoldable t, Num a) => t a a -> a

-- | The <a>bisum</a> function computes the sum of the numbers of a
--   structure.
bisum :: (Bifoldable t, Num a) => t a a -> a

-- | The least element of a non-empty structure.
biminimum :: (Bifoldable t, Ord a) => t a a -> a

-- | The largest element of a non-empty structure.
bimaximum :: (Bifoldable t, Ord a) => t a a -> a

-- | Reduces a structure of lists to the concatenation of those lists.
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Does the element occur in the structure?
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
bilength :: Bifoldable t => t a b -> Int

-- | Test whether the structure is empty.
binull :: Bifoldable t => t a b -> Bool

-- | Collects the list of elements of a structure, from left to right.
biList :: Bifoldable t => t a a -> [a]

-- | Alias for <a>biasum</a>.
bimsum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | Alias for <a>bisequence_</a>.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | Alias for <a>bifor_</a>.
biforM_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Alias for <a>bitraverse_</a>.
bimapM_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <pre>
--   &gt;&gt;&gt; &gt; bifor_ ('a', "bc") print (print . reverse)
--   'a'
--   "cb"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | A variant of <a>bifoldl</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | A variant of <a>bifoldr</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and
--   <tt>(,)</tt>:
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <a>Bifunctor</a> instance, it should satisfy:
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifold</a> . <a>bimap</a> f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   <a>bifoldMap</a> f g . <a>bimap</a> h i ≡ <a>bifoldMap</a> (f . h) (g . i)
--   </pre>
class Bifoldable (p :: Type -> Type -> Type)

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g
--        ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elements of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z
--        ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z . toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>replicateM</a> 5 as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a1 &lt;- as
--      a2 &lt;- as
--      a3 &lt;- as
--      a4 &lt;- as
--      a5 &lt;- as
--      pure [a1,a2,a3,a4,a5]
--   </pre>
--   
--   Note the <tt>Applicative</tt> constraint.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>forever</a> as</tt>' can be
--   understood as the pseudo-<tt>do</tt> expression
--   
--   <pre>
--   do as
--      as
--      ..
--   </pre>
--   
--   with <tt>as</tt> repeating.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.First x === Maybe (Data.Semigroup.First x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
data First a

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
tail :: [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>void</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure ()
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a
infixl 3 <|>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A class of types that can be fully evaluated.
class NFData a

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hashWithSalt</a>.
class Hashable a

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | An arbitrary-precision number represented using <a>scientific
--   notation</a>.
--   
--   This type describes the set of all <tt><a>Real</a>s</tt> which have a
--   finite decimal expansion.
--   
--   A scientific number with <a>coefficient</a> <tt>c</tt> and
--   <a>base10Exponent</a> <tt>e</tt> corresponds to the <a>Fractional</a>
--   number: <tt><a>fromInteger</a> c * 10 <a>^^</a> e</tt>
data Scientific

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions will treat it as seconds. For example, <tt>(0.010
--   :: NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data NominalDiffTime

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime

-- | The Modified Julian Day is a standard count of days, with zero being
--   the day 1858-11-17.
data Day

-- | A set of values. A set cannot contain duplicate values.
data HashSet a

-- | A map from keys to values. A map cannot contain duplicate keys; each
--   key can map to at most one value.
data HashMap k v

-- | A <tt>CI s</tt> provides <i>C</i>ase <i>I</i>nsensitive comparison for
--   the string-like type <tt>s</tt> (for example: <tt>String</tt>,
--   <a>Text</a>, <a>ByteString</a>, etc.).
--   
--   Note that <tt>CI s</tt> has an instance for <a>IsString</a> which
--   together with the <tt>OverloadedStrings</tt> language extension allows
--   you to write case insensitive string literals as in:
--   
--   <pre>
--   &gt; ("Content-Type" :: <a>CI</a> <a>Text</a>) == ("CONTENT-TYPE" :: <a>CI</a> <a>Text</a>)
--   True
--   </pre>
data CI s

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack which includes a <tt>ResourceT</tt> can be
--   an instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a <tt>MonadUnliftIO
--   m</tt> monad, which allows control operations to be lifted. A
--   <tt>MonadResource</tt> does not have this requirement. This means that
--   transformers such as <tt>ContT</tt> can be an instance of
--   <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will need
--   to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class MonadIO m => MonadResource (m :: Type -> Type)

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a
type TextLazy = Text
type TextBuilder = Builder
type ByteStringLazy = ByteString
type ByteStringBuilder = Builder


module Network.AWS.Crypto
type Key = ByteString
hmacSHA1 :: ByteArrayAccess a => Key -> a -> HMAC SHA1
hmacSHA256 :: ByteArrayAccess a => Key -> a -> HMAC SHA256
hashSHA256 :: ByteArrayAccess a => a -> Digest SHA256
hashMD5 :: ByteArrayAccess a => a -> Digest MD5

-- | Hash a strict bytestring into a digest.
hash :: (ByteArrayAccess ba, HashAlgorithm a) => ba -> Digest a

-- | Incrementally calculate a <tt>SHA256</tt> <tt>Digest</tt>.
sinkSHA256 :: Monad m => ConduitM ByteString o m (Digest SHA256)

-- | Incrementally calculate a <tt>MD5</tt> <tt>Digest</tt>.
sinkMD5 :: Monad m => ConduitM ByteString o m (Digest MD5)

-- | Class representing hashing algorithms.
--   
--   The interface presented here is update in place and lowlevel. the Hash
--   module takes care of hidding the mutable interface properly.
class HashAlgorithm a

-- | Represent a digest for a given hash algorithm.
--   
--   This type is an instance of <a>ByteArrayAccess</a> from package
--   <a>memory</a>. Module <a>Data.ByteArray</a> provides many primitives
--   to work with those values including conversion to other types.
--   
--   Creating a digest from a bytearray is also possible with function
--   <a>digestFromByteString</a>.
data Digest a

-- | SHA256 cryptographic hash algorithm
data SHA256

-- | MD5 cryptographic hash algorithm
data MD5


module Network.AWS.Bytes

-- | Convert a bytearray to another type of bytearray
convert :: (ByteArrayAccess bin, ByteArray bout) => bin -> bout
encodeBase16 :: ByteArrayAccess a => a -> ByteString
decodeBase16 :: ByteArrayAccess a => a -> Either String ByteString
encodeBase64 :: ByteArrayAccess a => a -> ByteString
decodeBase64 :: ByteArrayAccess a => a -> Either String ByteString


module Network.AWS.Data.Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text
class FromText a
fromText :: FromText a => Text -> Either String a
class ToText a
toText :: ToText a => a -> Text
toTextCI :: ToText a => a -> CI Text
showText :: ToText a => a -> String
instance Network.AWS.Data.Text.ToText a => Network.AWS.Data.Text.ToText (Data.CaseInsensitive.Internal.CI a)
instance Network.AWS.Data.Text.ToText Data.Text.Internal.Text
instance Network.AWS.Data.Text.ToText Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Text.ToText GHC.Types.Char
instance Network.AWS.Data.Text.ToText GHC.Base.String
instance Network.AWS.Data.Text.ToText GHC.Types.Int
instance Network.AWS.Data.Text.ToText GHC.Int.Int64
instance Network.AWS.Data.Text.ToText GHC.Integer.Type.Integer
instance Network.AWS.Data.Text.ToText GHC.Natural.Natural
instance Network.AWS.Data.Text.ToText Data.Scientific.Scientific
instance Network.AWS.Data.Text.ToText GHC.Types.Double
instance Network.AWS.Data.Text.ToText Network.HTTP.Types.Method.StdMethod
instance Network.AWS.Data.Text.ToText (Crypto.Hash.Types.Digest a)
instance Network.AWS.Data.Text.ToText GHC.Types.Bool
instance Network.AWS.Data.Text.FromText Data.Text.Internal.Text
instance Network.AWS.Data.Text.FromText GHC.Base.String
instance Network.AWS.Data.Text.FromText Data.ByteString.Internal.ByteString
instance (Data.CaseInsensitive.Internal.FoldCase a, Network.AWS.Data.Text.FromText a) => Network.AWS.Data.Text.FromText (Data.CaseInsensitive.Internal.CI a)
instance Network.AWS.Data.Text.FromText GHC.Types.Char
instance Network.AWS.Data.Text.FromText GHC.Types.Int
instance Network.AWS.Data.Text.FromText GHC.Int.Int64
instance Network.AWS.Data.Text.FromText GHC.Integer.Type.Integer
instance Network.AWS.Data.Text.FromText Data.Scientific.Scientific
instance Network.AWS.Data.Text.FromText GHC.Natural.Natural
instance Network.AWS.Data.Text.FromText GHC.Types.Double
instance Network.AWS.Data.Text.FromText GHC.Types.Bool
instance Network.AWS.Data.Text.FromText Network.HTTP.Types.Method.StdMethod


module Network.AWS.Data.JSON

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]

-- | Read the docs for <tt>ToJSONKey</tt> first. This class is a conversion
--   in the opposite direction. If you have a newtype wrapper around
--   <a>Text</a>, the recommended way to define instances is with
--   generalized newtype deriving:
--   
--   <pre>
--   newtype SomeId = SomeId { getSomeId :: Text }
--     deriving (Eq,Ord,Hashable,FromJSONKey)
--   </pre>
--   
--   If you have a sum of nullary constructors, you may use the generic
--   implementation:
--   
--   <pre>
--   data Color = Red | Green | Blue
--     deriving Generic
--   
--   instance <a>FromJSONKey</a> Color where
--     <a>fromJSONKey</a> = <a>genericFromJSONKey</a> <a>defaultJSONKeyOptions</a>
--   </pre>
class FromJSONKey a

-- | Strategy for parsing the key of a map-like container.
fromJSONKey :: FromJSONKey a => FromJSONKeyFunction a

-- | This is similar in spirit to the <a>readList</a> method of
--   <a>Read</a>. It makes it possible to give <a>String</a> keys special
--   treatment without using <tt>OverlappingInstances</tt>. End users
--   should always be able to use the default implementation of this
--   method.
fromJSONKeyList :: FromJSONKey a => FromJSONKeyFunction [a]
parseJSONText :: FromText a => String -> Value -> Parser a

-- | Like <a>decode</a> but returns an error message when decoding fails.
eitherDecode :: FromJSON a => ByteString -> Either String a

-- | Like <a>decode'</a> but returns an error message when decoding fails.
eitherDecode' :: FromJSON a => ByteString -> Either String a

-- | <tt><a>withObject</a> name f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <a>Object</a> and fails
--   otherwise.
--   
--   <h4>Error message example</h4>
--   
--   <pre>
--   withObject "MyType" f (String "oops")
--   -- Error: "parsing MyType failed, expected Object, but encountered String"
--   </pre>
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present or if its value
--   is <a>Null</a>, or <tt>empty</tt> if the value cannot be converted to
--   the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use <a>.:</a> instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use
--   <a>.:</a> instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a
eitherParseJSON :: FromJSON a => Object -> Either String a
(.:>) :: FromJSON a => Object -> Text -> Either String a
(.?>) :: FromJSON a => Object -> Text -> Either String (Maybe a)

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding

-- | Typeclass for types that can be used as the key of a map-like
--   container (like <tt>Map</tt> or <tt>HashMap</tt>). For example, since
--   <a>Text</a> has a <a>ToJSONKey</a> instance and <a>Char</a> has a
--   <a>ToJSON</a> instance, we can encode a value of type <tt>Map</tt>
--   <a>Text</a> <a>Char</a>:
--   
--   <pre>
--   &gt;&gt;&gt; LBC8.putStrLn $ encode $ Map.fromList [("foo" :: Text, 'a')]
--   {"foo":"a"}
--   </pre>
--   
--   Since <a>Int</a> also has a <a>ToJSONKey</a> instance, we can
--   similarly write:
--   
--   <pre>
--   &gt;&gt;&gt; LBC8.putStrLn $ encode $ Map.fromList [(5 :: Int, 'a')]
--   {"5":"a"}
--   </pre>
--   
--   JSON documents only accept strings as object keys. For any type from
--   <tt>base</tt> that has a natural textual representation, it can be
--   expected that its <a>ToJSONKey</a> instance will choose that
--   representation.
--   
--   For data types that lack a natural textual representation, an
--   alternative is provided. The map-like container is represented as a
--   JSON array instead of a JSON object. Each value in the array is an
--   array with exactly two values. The first is the key and the second is
--   the value.
--   
--   For example, values of type '[Text]' cannot be encoded to a string, so
--   a <tt>Map</tt> with keys of type '[Text]' is encoded as follows:
--   
--   <pre>
--   &gt;&gt;&gt; LBC8.putStrLn $ encode $ Map.fromList [(["foo","bar","baz" :: Text], 'a')]
--   [[["foo","bar","baz"],"a"]]
--   </pre>
--   
--   The default implementation of <a>ToJSONKey</a> chooses this method of
--   encoding a key, using the <a>ToJSON</a> instance of the type.
--   
--   To use your own data type as the key in a map, all that is needed is
--   to write a <a>ToJSONKey</a> (and possibly a <tt>FromJSONKey</tt>)
--   instance for it. If the type cannot be trivially converted to and from
--   <a>Text</a>, it is recommended that <a>ToJSONKeyValue</a> is used.
--   Since the default implementations of the typeclass methods can build
--   this from a <a>ToJSON</a> instance, there is nothing that needs to be
--   written:
--   
--   <pre>
--   data Foo = Foo { fooAge :: Int, fooName :: Text }
--     deriving (Eq,Ord,Generic)
--   instance ToJSON Foo
--   instance ToJSONKey Foo
--   </pre>
--   
--   That's it. We can now write:
--   
--   <pre>
--   &gt;&gt;&gt; let m = Map.fromList [(Foo 4 "bar",'a'),(Foo 6 "arg",'b')]
--   
--   &gt;&gt;&gt; LBC8.putStrLn $ encode m
--   [[{"fooName":"bar","fooAge":4},"a"],[{"fooName":"arg","fooAge":6},"b"]]
--   </pre>
--   
--   The next case to consider is if we have a type that is a newtype
--   wrapper around <a>Text</a>. The recommended approach is to use
--   generalized newtype deriving:
--   
--   <pre>
--   newtype RecordId = RecordId { getRecordId :: Text }
--     deriving (Eq,Ord,ToJSONKey)
--   </pre>
--   
--   Then we may write:
--   
--   <pre>
--   &gt;&gt;&gt; LBC8.putStrLn $ encode $ Map.fromList [(RecordId "abc",'a')]
--   {"abc":"a"}
--   </pre>
--   
--   Simple sum types are a final case worth considering. Suppose we have:
--   
--   <pre>
--   data Color = Red | Green | Blue
--     deriving (Show,Read,Eq,Ord)
--   </pre>
--   
--   It is possible to get the <a>ToJSONKey</a> instance for free as we did
--   with <tt>Foo</tt>. However, in this case, we have a natural way to go
--   to and from <a>Text</a> that does not require any escape sequences. So
--   <a>ToJSONKeyText</a> can be used instead of <a>ToJSONKeyValue</a> to
--   encode maps as objects instead of arrays of pairs. This instance may
--   be implemented using generics as follows:
--   
--   <pre>
--   instance <a>ToJSONKey</a> Color where
--     <a>toJSONKey</a> = <a>genericToJSONKey</a> <a>defaultJSONKeyOptions</a>
--   </pre>
--   
--   <h3><b>Low-level implementations</b></h3>
--   
--   The <a>Show</a> instance can be used to help write <a>ToJSONKey</a>:
--   
--   <pre>
--   instance ToJSONKey Color where
--     toJSONKey = ToJSONKeyText f g
--       where f = Text.pack . show
--             g = text . Text.pack . show
--             -- text function is from Data.Aeson.Encoding
--   </pre>
--   
--   The situation of needing to turning function <tt>a -&gt; Text</tt>
--   into a <a>ToJSONKeyFunction</a> is common enough that a special
--   combinator is provided for it. The above instance can be rewritten as:
--   
--   <pre>
--   instance ToJSONKey Color where
--     toJSONKey = toJSONKeyText (Text.pack . show)
--   </pre>
--   
--   The performance of the above instance can be improved by not using
--   <a>String</a> as an intermediate step when converting to <a>Text</a>.
--   One option for improving performance would be to use template haskell
--   machinery from the <tt>text-show</tt> package. However, even with the
--   approach, the <a>Encoding</a> (a wrapper around a bytestring builder)
--   is generated by encoding the <a>Text</a> to a <tt>ByteString</tt>, an
--   intermediate step that could be avoided. The fastest possible
--   implementation would be:
--   
--   <pre>
--   -- Assuming that OverloadedStrings is enabled
--   instance ToJSONKey Color where
--     toJSONKey = ToJSONKeyText f g
--       where f x = case x of {Red -&gt; "Red";Green -&gt;"Green";Blue -&gt; "Blue"}
--             g x = case x of {Red -&gt; text "Red";Green -&gt; text "Green";Blue -&gt; text "Blue"}
--             -- text function is from Data.Aeson.Encoding
--   </pre>
--   
--   This works because GHC can lift the encoded values out of the case
--   statements, which means that they are only evaluated once. This
--   approach should only be used when there is a serious need to maximize
--   performance.
class ToJSONKey a

-- | Strategy for rendering the key for a map-like container.
toJSONKey :: ToJSONKey a => ToJSONKeyFunction a

-- | This is similar in spirit to the <tt>showsList</tt> method of
--   <a>Show</a>. It makes it possible to give <a>String</a> keys special
--   treatment without using <tt>OverlappingInstances</tt>. End users
--   should always be able to use the default implementation of this
--   method.
toJSONKeyList :: ToJSONKey a => ToJSONKeyFunction [a]
toJSONText :: ToText a => a -> Value

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv
infixr 8 .=


module Network.AWS.Data.ByteString

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString
type ByteStringLazy = ByteString
class ToByteString a
toBS :: ToByteString a => a -> ByteString
toBS :: (ToByteString a, ToText a) => a -> ByteString
showBS :: ToByteString a => a -> String
stripBS :: ByteString -> ByteString
instance Network.AWS.Data.ByteString.ToByteString Data.ByteString.Internal.ByteString
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Prelude.ByteStringBuilder
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Prelude.ByteStringLazy
instance Network.AWS.Data.ByteString.ToByteString Data.Text.Internal.Text
instance Network.AWS.Data.ByteString.ToByteString GHC.Base.String
instance Network.AWS.Data.ByteString.ToByteString GHC.Types.Int
instance Network.AWS.Data.ByteString.ToByteString GHC.Integer.Type.Integer
instance Network.AWS.Data.ByteString.ToByteString GHC.Natural.Natural
instance Network.AWS.Data.ByteString.ToByteString GHC.Types.Double
instance Network.AWS.Data.ByteString.ToByteString Network.HTTP.Types.Method.StdMethod
instance Network.AWS.Data.ByteString.ToByteString Data.Time.Clock.Internal.UTCTime.UTCTime
instance Network.AWS.Data.ByteString.ToByteString a => Network.AWS.Data.ByteString.ToByteString (Data.CaseInsensitive.Internal.CI a)


module Network.AWS.Data.XML
(.@) :: FromXML a => [Node] -> Text -> Either String a
infixl 7 .@
(.@?) :: FromXML a => [Node] -> Text -> Either String (Maybe a)
infixl 7 .@?
(@=) :: ToXML a => Name -> a -> XML
infixr 7 @=
(@@=) :: ToText a => Name -> a -> XML
infixr 7 @@=
decodeXML :: FromXML a => ByteStringLazy -> Either String a
encodeXML :: ToElement a => a -> ByteStringLazy
class FromXML a
parseXML :: FromXML a => [Node] -> Either String a
class ToElement a
toElement :: ToElement a => a -> Element

-- | Convert to an <a>Element</a>, only if the resulting element contains
--   <tt>&gt; 0</tt> nodes.
maybeElement :: ToElement a => a -> Maybe Element

-- | Provides a way to make the operators for ToXML instance declaration be
--   consistent WRT to single nodes or lists of nodes.
data XML
XNull :: XML
XAttr :: Name -> Text -> XML
XOne :: Node -> XML
XMany :: [(Name, Text)] -> [Node] -> XML
listXMLNodes :: XML -> [Node]
listXMLAttributes :: XML -> [(Name, Text)]
class ToXML a
toXML :: ToXML a => a -> XML
parseXMLMap :: (Eq k, Hashable k, FromText k, FromXML v) => Text -> Text -> Text -> [Node] -> Either String (HashMap k v)
parseXMLList1 :: FromXML a => Text -> [Node] -> Either String (NonEmpty a)
parseXMLList :: FromXML a => Text -> [Node] -> Either String [a]
parseXMLText :: FromText a => String -> [Node] -> Either String a
toXMLList :: (IsList a, ToXML (Item a)) => Name -> a -> XML
toXMLText :: ToText a => a -> XML
mkElement :: ToXML a => Name -> a -> Element
withContent :: String -> [Node] -> Either String (Maybe Text)

-- | Find a specific named NodeElement, at the current depth in the node
--   tree.
--   
--   Fails if absent.
findElement :: Text -> [Node] -> Either String [Node]

-- | Find the first specific named NodeElement, at any depth in the node
--   tree.
--   
--   Fails if absent.
firstElement :: Text -> [Node] -> Either String [Node]
childNodesOf :: Text -> Node -> Maybe [Node]
childrenOf :: Element -> [Node]
localName :: Node -> Maybe Text

-- | An inefficient mechanism for retreiving the root element name of an
--   XML document.
rootElementName :: ByteStringLazy -> Maybe Text
missingElement :: Text -> [Node] -> Maybe a -> Either String a
instance GHC.Show.Show Network.AWS.Data.XML.XML
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.XML.XML
instance Network.AWS.Data.XML.ToXML a => Network.AWS.Data.XML.ToXML (GHC.Maybe.Maybe a)
instance Network.AWS.Data.XML.ToXML Data.Text.Internal.Text
instance Network.AWS.Data.XML.ToXML Data.ByteString.Internal.ByteString
instance Network.AWS.Data.XML.ToXML GHC.Types.Int
instance Network.AWS.Data.XML.ToXML GHC.Integer.Type.Integer
instance Network.AWS.Data.XML.ToXML GHC.Natural.Natural
instance Network.AWS.Data.XML.ToXML GHC.Types.Double
instance Network.AWS.Data.XML.ToXML GHC.Types.Bool
instance GHC.Base.Semigroup Network.AWS.Data.XML.XML
instance GHC.Base.Monoid Network.AWS.Data.XML.XML
instance Network.AWS.Data.XML.ToElement Text.XML.Element
instance Network.AWS.Data.XML.FromXML [Text.XML.Node]
instance Network.AWS.Data.XML.FromXML a => Network.AWS.Data.XML.FromXML (GHC.Maybe.Maybe a)
instance Network.AWS.Data.XML.FromXML Data.Text.Internal.Text
instance Network.AWS.Data.XML.FromXML GHC.Types.Char
instance Network.AWS.Data.XML.FromXML Data.ByteString.Internal.ByteString
instance Network.AWS.Data.XML.FromXML GHC.Types.Int
instance Network.AWS.Data.XML.FromXML GHC.Integer.Type.Integer
instance Network.AWS.Data.XML.FromXML GHC.Natural.Natural
instance Network.AWS.Data.XML.FromXML GHC.Types.Double
instance Network.AWS.Data.XML.FromXML GHC.Types.Bool


module Network.AWS.Data.Query
data QueryString
QList :: [QueryString] -> QueryString
QPair :: ByteString -> QueryString -> QueryString
QValue :: Maybe ByteString -> QueryString
parseQueryString :: ByteString -> QueryString
pair :: ToQuery a => ByteString -> a -> QueryString -> QueryString
(=:) :: ToQuery a => ByteString -> a -> QueryString
infixr 7 =:
toQueryList :: (IsList a, ToQuery (Item a)) => ByteString -> a -> QueryString
toQueryMap :: (ToQuery k, ToQuery v) => ByteString -> ByteString -> ByteString -> HashMap k v -> QueryString
class ToQuery a
toQuery :: ToQuery a => a -> QueryString
toQuery :: (ToQuery a, ToText a) => a -> QueryString
instance GHC.Show.Show Network.AWS.Data.Query.QueryString
instance GHC.Classes.Eq Network.AWS.Data.Query.QueryString
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Query.QueryString
instance (Network.AWS.Data.ByteString.ToByteString k, Network.AWS.Data.Query.ToQuery v) => Network.AWS.Data.Query.ToQuery (k, v)
instance Network.AWS.Data.Query.ToQuery GHC.Types.Char
instance Network.AWS.Data.Query.ToQuery Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Query.ToQuery Data.Text.Internal.Text
instance Network.AWS.Data.Query.ToQuery GHC.Types.Int
instance Network.AWS.Data.Query.ToQuery GHC.Integer.Type.Integer
instance Network.AWS.Data.Query.ToQuery GHC.Types.Double
instance Network.AWS.Data.Query.ToQuery GHC.Natural.Natural
instance Network.AWS.Data.Query.ToQuery a => Network.AWS.Data.Query.ToQuery (GHC.Maybe.Maybe a)
instance Network.AWS.Data.Query.ToQuery GHC.Types.Bool
instance GHC.Base.Semigroup Network.AWS.Data.Query.QueryString
instance GHC.Base.Monoid Network.AWS.Data.Query.QueryString
instance Data.String.IsString Network.AWS.Data.Query.QueryString
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Query.QueryString


module Network.AWS.Data.Time
data Format
RFC822Format :: Format
ISO8601Format :: Format
BasicFormat :: Format
AWSFormat :: Format
POSIXFormat :: Format
newtype Time (a :: Format)
Time :: UTCTime -> Time (a :: Format)
[$sel:fromTime:Time] :: Time (a :: Format) -> UTCTime
_Time :: Iso' (Time a) UTCTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime
type RFC822 = Time 'RFC822Format
type ISO8601 = Time 'ISO8601Format
type BasicTime = Time 'BasicFormat
type AWSTime = Time 'AWSFormat
type POSIX = Time 'POSIXFormat
instance GHC.Generics.Generic Network.AWS.Data.Time.Format
instance GHC.Show.Show Network.AWS.Data.Time.Format
instance GHC.Read.Read Network.AWS.Data.Time.Format
instance GHC.Classes.Eq Network.AWS.Data.Time.Format
instance Control.DeepSeq.NFData (Network.AWS.Data.Time.Time a)
instance GHC.Generics.Generic (Network.AWS.Data.Time.Time a)
instance GHC.Classes.Ord (Network.AWS.Data.Time.Time a)
instance GHC.Classes.Eq (Network.AWS.Data.Time.Time a)
instance GHC.Read.Read (Network.AWS.Data.Time.Time a)
instance GHC.Show.Show (Network.AWS.Data.Time.Time a)
instance Network.AWS.Data.Time.TimeFormat Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.Time.TimeFormat Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.Time.TimeFormat Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.Time.TimeFormat Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Time.POSIX
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Time.POSIX
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Time.POSIX
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Time.POSIX
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Time.POSIX
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.XML.FromXML Network.AWS.Data.Time.AWSTime
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.Time.AWSTime
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Time.AWSTime
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.XML.FromXML Network.AWS.Data.Time.BasicTime
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.Time.BasicTime
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Time.BasicTime
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.XML.FromXML Network.AWS.Data.Time.ISO8601
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.Time.ISO8601
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Time.ISO8601
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.XML.FromXML Network.AWS.Data.Time.RFC822
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Time.RFC822
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.Time.RFC822
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Time.RFC822
instance Data.Hashable.Class.Hashable (Network.AWS.Data.Time.Time a)


module Network.AWS.Data.Path
data Path :: Encoding -> *
[Raw] :: [ByteString] -> Path 'NoEncoding
[Encoded] :: [ByteString] -> Path 'Percent
type RawPath = Path 'NoEncoding
type EscapedPath = Path 'Percent
class ToPath a
toPath :: ToPath a => a -> ByteString
rawPath :: ToPath a => a -> Path 'NoEncoding
escapePath :: Path a -> EscapedPath
collapsePath :: Path a -> Path a
instance GHC.Show.Show Network.AWS.Data.Path.Encoding
instance GHC.Classes.Eq Network.AWS.Data.Path.Encoding
instance GHC.Show.Show (Network.AWS.Data.Path.Path a)
instance GHC.Classes.Eq (Network.AWS.Data.Path.Path a)
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Path.EscapedPath
instance GHC.Base.Semigroup Network.AWS.Data.Path.RawPath
instance GHC.Base.Monoid Network.AWS.Data.Path.RawPath
instance Network.AWS.Data.Path.ToPath Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Path.ToPath Data.Text.Internal.Text


module Network.AWS.Data.Headers
class ToHeader a
toHeader :: ToHeader a => HeaderName -> a -> [Header]
toHeader :: (ToHeader a, ToText a) => HeaderName -> a -> [Header]
class ToHeaders a
toHeaders :: ToHeaders a => a -> [Header]
(.#) :: FromText a => ResponseHeaders -> HeaderName -> Either String a
infixl 7 .#
(.#?) :: FromText a => ResponseHeaders -> HeaderName -> Either String (Maybe a)
infixl 7 .#?
(=#) :: ToHeader a => HeaderName -> a -> [Header]
infixr 7 =#
hdr :: HeaderName -> ByteString -> [Header] -> [Header]
parseHeadersMap :: FromText a => ByteString -> ResponseHeaders -> Either String (HashMap Text a)
hHost :: HeaderName
hExpect :: HeaderName
hAMZToken :: HeaderName
hAMZTarget :: HeaderName
hAMZAlgorithm :: HeaderName
hAMZCredential :: HeaderName
hAMZExpires :: HeaderName
hAMZSignedHeaders :: HeaderName
hAMZContentSHA256 :: HeaderName
hAMZDate :: HeaderName
hMetaPrefix :: HeaderName
hAMZRequestId :: HeaderName
hAMZNRequestId :: HeaderName
hAMZNErrorType :: HeaderName
hAMZNAuth :: HeaderName
hAMZDecodedContentLength :: HeaderName
hTransferEncoding :: HeaderName
hFormEncoded :: ByteString

-- | Header name
type HeaderName = CI ByteString

-- | Header
type Header = (HeaderName, ByteString)

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentType :: HeaderName
instance Network.AWS.Data.Headers.ToHeader Data.Text.Internal.Text
instance Network.AWS.Data.Headers.ToHeader Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Text.ToText a => Network.AWS.Data.Headers.ToHeader (GHC.Maybe.Maybe a)
instance (Network.AWS.Data.ByteString.ToByteString k, Network.AWS.Data.ByteString.ToByteString v) => Network.AWS.Data.Headers.ToHeader (Data.HashMap.Internal.HashMap k v)
instance (Network.AWS.Data.ByteString.ToByteString k, Network.AWS.Data.ByteString.ToByteString v) => Network.AWS.Data.Headers.ToHeaders (Data.HashMap.Internal.HashMap k v)


module Network.AWS.Data.Log
class ToLog a

-- | Convert a value to a loggable builder.
build :: ToLog a => a -> ByteStringBuilder

-- | Intercalate a list of <a>ByteStringBuilder</a>s with newlines.
buildLines :: [ByteStringBuilder] -> ByteStringBuilder
instance Network.AWS.Data.Log.ToLog Network.AWS.Prelude.ByteStringBuilder
instance Network.AWS.Data.Log.ToLog Network.AWS.Prelude.ByteStringLazy
instance Network.AWS.Data.Log.ToLog Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Log.ToLog GHC.Types.Int
instance Network.AWS.Data.Log.ToLog GHC.Int.Int8
instance Network.AWS.Data.Log.ToLog GHC.Int.Int16
instance Network.AWS.Data.Log.ToLog GHC.Int.Int32
instance Network.AWS.Data.Log.ToLog GHC.Int.Int64
instance Network.AWS.Data.Log.ToLog GHC.Integer.Type.Integer
instance Network.AWS.Data.Log.ToLog GHC.Types.Word
instance Network.AWS.Data.Log.ToLog GHC.Word.Word8
instance Network.AWS.Data.Log.ToLog GHC.Word.Word16
instance Network.AWS.Data.Log.ToLog GHC.Word.Word32
instance Network.AWS.Data.Log.ToLog GHC.Word.Word64
instance Network.AWS.Data.Log.ToLog Data.Time.Clock.Internal.UTCTime.UTCTime
instance Network.AWS.Data.Log.ToLog GHC.Types.Float
instance Network.AWS.Data.Log.ToLog GHC.Types.Double
instance Network.AWS.Data.Log.ToLog Data.Text.Internal.Text
instance Network.AWS.Data.Log.ToLog Network.AWS.Prelude.TextLazy
instance Network.AWS.Data.Log.ToLog GHC.Types.Char
instance Network.AWS.Data.Log.ToLog [GHC.Types.Char]
instance Network.AWS.Data.Log.ToLog Network.HTTP.Types.Method.StdMethod
instance Network.AWS.Data.Log.ToLog Network.AWS.Data.Query.QueryString
instance Network.AWS.Data.Log.ToLog Network.AWS.Data.Path.EscapedPath
instance Network.AWS.Data.Log.ToLog a => Network.AWS.Data.Log.ToLog (Data.CaseInsensitive.Internal.CI a)
instance Network.AWS.Data.Log.ToLog a => Network.AWS.Data.Log.ToLog (GHC.Maybe.Maybe a)
instance Network.AWS.Data.Log.ToLog GHC.Types.Bool
instance Network.AWS.Data.Log.ToLog Network.HTTP.Types.Status.Status
instance Network.AWS.Data.Log.ToLog [Network.HTTP.Types.Header.Header]
instance Network.AWS.Data.Log.ToLog Network.HTTP.Types.Version.HttpVersion
instance Network.AWS.Data.Log.ToLog Network.HTTP.Client.Types.RequestBody
instance Network.AWS.Data.Log.ToLog Network.HTTP.Client.Types.HttpException
instance Network.AWS.Data.Log.ToLog Network.HTTP.Client.Types.HttpExceptionContent
instance Network.AWS.Data.Log.ToLog Network.HTTP.Client.Types.Request
instance Network.AWS.Data.Log.ToLog (Network.HTTP.Client.Types.Response a)


module Network.AWS.Data.Sensitive

-- | <i>Note</i>: read . show /= isomorphic
newtype Sensitive a
Sensitive :: a -> Sensitive a
[$sel:fromSensitive:Sensitive] :: Sensitive a -> a
_Sensitive :: Iso' (Sensitive a) a
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Network.AWS.Data.Sensitive.Sensitive a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.Headers.ToHeader a => Network.AWS.Data.Headers.ToHeader (Network.AWS.Data.Sensitive.Sensitive a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Network.AWS.Data.Sensitive.Sensitive a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.Query.ToQuery a => Network.AWS.Data.Query.ToQuery (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.XML.ToXML a => Network.AWS.Data.XML.ToXML (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.XML.FromXML a => Network.AWS.Data.XML.FromXML (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.Text.ToText a => Network.AWS.Data.Text.ToText (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.Text.FromText a => Network.AWS.Data.Text.FromText (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.ByteString.ToByteString a => Network.AWS.Data.ByteString.ToByteString (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Network.AWS.Data.Sensitive.Sensitive a)
instance Data.String.IsString a => Data.String.IsString (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Generics.Generic (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Network.AWS.Data.Sensitive.Sensitive a)
instance GHC.Show.Show (Network.AWS.Data.Sensitive.Sensitive a)
instance Network.AWS.Data.Log.ToLog (Network.AWS.Data.Sensitive.Sensitive a)


module Network.AWS.Data.Body

-- | Convenience function for obtaining the size of a file.
getFileSize :: MonadIO m => FilePath -> m Integer

-- | A streaming, exception safe response body.
newtype ResponseBody
ResponseBody :: ConduitM () ByteString (ResourceT IO) () -> ResponseBody
[$sel:_streamBody:ResponseBody] :: ResponseBody -> ConduitM () ByteString (ResourceT IO) ()
fuseStream :: ResponseBody -> ConduitM ByteString ByteString (ResourceT IO) () -> ResponseBody

-- | Connect a <tt>Sink</tt> to a response stream.
sinkBody :: MonadIO m => ResponseBody -> ConduitM ByteString Void (ResourceT IO) a -> m a

-- | Specifies the transmitted size of the 'Transfer-Encoding' chunks.
--   
--   <i>See:</i> <tt>defaultChunk</tt>.
newtype ChunkSize
ChunkSize :: Int -> ChunkSize

-- | The default chunk size of 128 KB. The minimum chunk size accepted by
--   AWS is 8 KB, unless the entirety of the request is below this
--   threshold.
--   
--   A chunk size of 64 KB or higher is recommended for performance
--   reasons.
defaultChunkSize :: ChunkSize

-- | An opaque request body which will be transmitted via
--   <tt>Transfer-Encoding: chunked</tt>.
--   
--   <i>Invariant:</i> Only services that support chunked encoding can
--   accept a <a>ChunkedBody</a>. (Currently S3.) This is enforced by the
--   type signatures emitted by the generator.
data ChunkedBody
ChunkedBody :: ChunkSize -> Integer -> ConduitM () ByteString (ResourceT IO) () -> ChunkedBody
[$sel:_chunkedSize:ChunkedBody] :: ChunkedBody -> ChunkSize
[$sel:_chunkedLength:ChunkedBody] :: ChunkedBody -> Integer
[$sel:_chunkedBody:ChunkedBody] :: ChunkedBody -> ConduitM () ByteString (ResourceT IO) ()
chunkedLength :: Lens' ChunkedBody Integer
fuseChunks :: ChunkedBody -> ConduitM ByteString ByteString (ResourceT IO) () -> ChunkedBody
fullChunks :: ChunkedBody -> Integer
remainderBytes :: ChunkedBody -> Maybe Integer

-- | Construct a <a>ChunkedBody</a> from a <a>FilePath</a>, where the
--   contents will be read and signed incrementally in chunks if the target
--   service supports it.
--   
--   Will intelligently revert to <a>HashedBody</a> if the file is smaller
--   than the specified <a>ChunkSize</a>.
--   
--   <i>See:</i> <a>ToBody</a>.
chunkedFile :: MonadIO m => ChunkSize -> FilePath -> m RequestBody

-- | Construct a <a>ChunkedBody</a> from a <a>FilePath</a>, specifying the
--   range of bytes to read. This can be useful for constructing multiple
--   requests from a single file, say for S3 multipart uploads.
--   
--   <i>See:</i> <a>chunkedFile</a>.
chunkedFileRange :: MonadIO m => ChunkSize -> FilePath -> Integer -> Integer -> m RequestBody

-- | Unsafely construct a <a>ChunkedBody</a>.
--   
--   This function is marked unsafe because it does nothing to enforce the
--   chunk size. Typically for conduit <a>IO</a> functions, it's whatever
--   ByteString's <tt>defaultBufferSize</tt> is, around 32 KB. If the chunk
--   size is less than 8 KB, the request will error. 64 KB or higher chunk
--   size is recommended for performance reasons.
--   
--   Note that it will always create a chunked body even if the request is
--   too small.
--   
--   <i>See:</i> <a>ToBody</a>.
unsafeChunkedBody :: ChunkSize -> Integer -> ConduitM () ByteString (ResourceT IO) () -> RequestBody
sourceFileChunks :: MonadResource m => ChunkSize -> FilePath -> ConduitM () ByteString m ()
sourceFileRangeChunks :: MonadResource m => ChunkSize -> FilePath -> Integer -> Integer -> ConduitM () ByteString m ()

-- | An opaque request body containing a <a>SHA256</a> hash.
data HashedBody
HashedStream :: Digest SHA256 -> !Integer -> ConduitM () ByteString (ResourceT IO) () -> HashedBody
HashedBytes :: Digest SHA256 -> ByteString -> HashedBody
sha256Base16 :: HashedBody -> ByteString

-- | Construct a <a>HashedBody</a> from a <a>FilePath</a>, calculating the
--   <a>SHA256</a> hash and file size.
--   
--   <i>Note:</i> While this function will perform in constant space, it
--   will enumerate the entirety of the file contents _twice_. Firstly to
--   calculate the SHA256 and lastly to stream the contents to the socket
--   during sending.
--   
--   <i>See:</i> <a>ToHashedBody</a>.
hashedFile :: MonadIO m => FilePath -> m HashedBody

-- | Construct a <a>HashedBody</a> from a <a>FilePath</a>, specifying the
--   range of bytes to read. This can be useful for constructing multiple
--   requests from a single file, say for S3 multipart uploads.
--   
--   <i>See:</i> <a>hashedFile</a>, <a>sourceFileRange</a>.
hashedFileRange :: MonadIO m => FilePath -> Integer -> Integer -> m HashedBody

-- | Construct a <a>HashedBody</a> from a <tt>Source</tt>, manually
--   specifying the <a>SHA256</a> hash and file size. It's left up to the
--   caller to calculate these correctly, otherwise AWS will return signing
--   errors.
--   
--   <i>See:</i> <a>ToHashedBody</a>.
hashedBody :: Digest SHA256 -> Integer -> ConduitM () ByteString (ResourceT IO) () -> HashedBody

-- | Invariant: only services that support _both_ standard and chunked
--   signing expose <a>RequestBody</a> as a parameter.
data RequestBody
Chunked :: ChunkedBody -> RequestBody
Hashed :: HashedBody -> RequestBody
md5Base64 :: RequestBody -> Maybe ByteString
isStreaming :: RequestBody -> Bool
toRequestBody :: RequestBody -> RequestBody
contentLength :: RequestBody -> Integer

-- | Anything that can be safely converted to a <a>HashedBody</a>.
class ToHashedBody a

-- | Convert a value to a hashed request body.
toHashed :: ToHashedBody a => a -> HashedBody

-- | Anything that can be converted to a streaming request <tt>Body</tt>.
class ToBody a

-- | Convert a value to a request body.
toBody :: ToBody a => a -> RequestBody

-- | Convert a value to a request body.
toBody :: (ToBody a, ToHashedBody a) => a -> RequestBody
_Body :: ToBody a => AReview RequestBody a
instance GHC.Real.Integral Network.AWS.Data.Body.ChunkSize
instance GHC.Real.Real Network.AWS.Data.Body.ChunkSize
instance GHC.Num.Num Network.AWS.Data.Body.ChunkSize
instance GHC.Enum.Enum Network.AWS.Data.Body.ChunkSize
instance GHC.Show.Show Network.AWS.Data.Body.ChunkSize
instance GHC.Classes.Ord Network.AWS.Data.Body.ChunkSize
instance GHC.Classes.Eq Network.AWS.Data.Body.ChunkSize
instance GHC.Show.Show Network.AWS.Data.Body.RequestBody
instance Network.AWS.Data.Body.ToBody Network.AWS.Data.Body.RequestBody
instance Network.AWS.Data.Body.ToBody Network.AWS.Data.Body.HashedBody
instance Network.AWS.Data.Body.ToBody Network.AWS.Data.Body.ChunkedBody
instance Network.AWS.Data.Body.ToHashedBody a => Network.AWS.Data.Body.ToBody (GHC.Maybe.Maybe a)
instance Network.AWS.Data.Body.ToBody GHC.Base.String
instance Network.AWS.Data.Body.ToBody Network.AWS.Prelude.ByteStringLazy
instance Network.AWS.Data.Body.ToBody Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Body.ToBody Data.Text.Internal.Text
instance Network.AWS.Data.Body.ToBody Network.AWS.Prelude.TextLazy
instance Network.AWS.Data.Body.ToBody (Data.HashMap.Internal.HashMap Data.Text.Internal.Text Data.Aeson.Types.Internal.Value)
instance Network.AWS.Data.Body.ToBody Data.Aeson.Types.Internal.Value
instance Network.AWS.Data.Body.ToBody Text.XML.Element
instance Network.AWS.Data.Body.ToBody Network.AWS.Data.Query.QueryString
instance Data.String.IsString Network.AWS.Data.Body.HashedBody
instance Network.AWS.Data.Body.ToHashedBody Data.ByteString.Internal.ByteString
instance Network.AWS.Data.Body.ToHashedBody Network.AWS.Data.Body.HashedBody
instance Network.AWS.Data.Body.ToHashedBody GHC.Base.String
instance Network.AWS.Data.Body.ToHashedBody Network.AWS.Prelude.ByteStringLazy
instance Network.AWS.Data.Body.ToHashedBody Data.Text.Internal.Text
instance Network.AWS.Data.Body.ToHashedBody Network.AWS.Prelude.TextLazy
instance Network.AWS.Data.Body.ToHashedBody Data.Aeson.Types.Internal.Value
instance Network.AWS.Data.Body.ToHashedBody Text.XML.Element
instance Network.AWS.Data.Body.ToHashedBody Network.AWS.Data.Query.QueryString
instance Network.AWS.Data.Body.ToHashedBody (Data.HashMap.Internal.HashMap Data.Text.Internal.Text Data.Aeson.Types.Internal.Value)
instance Data.String.IsString Network.AWS.Data.Body.RequestBody
instance GHC.Show.Show Network.AWS.Data.Body.HashedBody
instance GHC.Show.Show Network.AWS.Data.Body.ChunkedBody
instance Network.AWS.Data.Log.ToLog Network.AWS.Data.Body.ChunkSize
instance GHC.Show.Show Network.AWS.Data.Body.ResponseBody


module Network.AWS.Data.Base64

-- | Base64 encoded binary data.
--   
--   Encoding/decoding is automatically deferred to serialisation and
--   deserialisation respectively.
newtype Base64
Base64 :: ByteString -> Base64
[$sel:unBase64:Base64] :: Base64 -> ByteString
_Base64 :: Iso' Base64 ByteString
instance GHC.Generics.Generic Network.AWS.Data.Base64.Base64
instance GHC.Classes.Ord Network.AWS.Data.Base64.Base64
instance GHC.Read.Read Network.AWS.Data.Base64.Base64
instance GHC.Classes.Eq Network.AWS.Data.Base64.Base64
instance Data.Hashable.Class.Hashable Network.AWS.Data.Base64.Base64
instance Control.DeepSeq.NFData Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.Text.FromText Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Data.Base64.Base64
instance GHC.Show.Show Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.Text.ToText Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.Query.ToQuery Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.XML.FromXML Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.XML.ToXML Network.AWS.Data.Base64.Base64
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Data.Base64.Base64
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.Body.ToHashedBody Network.AWS.Data.Base64.Base64
instance Network.AWS.Data.Body.ToBody Network.AWS.Data.Base64.Base64


module Network.AWS.Data


-- | This module provides auxiliary functions necessary for the AWS
--   compliant V2 Header request signer. <i>See</i>:
--   <a>Network.AWS.Sign.V2Header</a>
module Network.AWS.Sign.V2Header.Base

-- | Construct a full header signer following the V2 Header scheme
newSigner :: RequestHeaders -> ByteString -> ByteString -> QueryString -> ByteString

-- | The following function mostly follows the toBS in amazonka QueryString
--   except for single QValue or single QPair keys not being suffixed with
--   an equals.
toSignerQueryBS :: QueryString -> ByteString

-- | Construct a header string for signing
constructSigningHeader :: Header -> ByteString

-- | Constructs a query string for signing
constructSigningQuery :: QueryString -> QueryString
constructFullPath :: ByteString -> ByteString -> ByteString
unionNecessaryHeaders :: [Header] -> [Header]


module Network.AWS.Types

-- | An access key ID.
--   
--   For example: <tt>AKIAIOSFODNN7EXAMPLE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype AccessKey
AccessKey :: ByteString -> AccessKey

-- | Secret access key credential.
--   
--   For example: <tt>wJalrXUtnFEMI<i>K7MDENG</i>bPxRfiCYEXAMPLEKE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype SecretKey
SecretKey :: ByteString -> SecretKey

-- | A session token used by STS to temporarily authorise access to an AWS
--   resource.
--   
--   <i>See:</i> <a>Temporary Security Credentials</a>.
newtype SessionToken
SessionToken :: ByteString -> SessionToken

-- | An authorisation environment containing AWS credentials, and
--   potentially a reference which can be refreshed out-of-band as
--   temporary credentials expire.
data Auth
Ref :: ThreadId -> IORef AuthEnv -> Auth
Auth :: AuthEnv -> Auth
withAuth :: MonadIO m => Auth -> (AuthEnv -> m a) -> m a

-- | The AuthN/AuthZ credential environment.
data AuthEnv
AuthEnv :: AccessKey -> Sensitive SecretKey -> Maybe (Sensitive SessionToken) -> Maybe ISO8601 -> AuthEnv
[$sel:_authAccessKeyId:AuthEnv] :: AuthEnv -> AccessKey
[$sel:_authSecretAccessKey:AuthEnv] :: AuthEnv -> Sensitive SecretKey
[$sel:_authSessionToken:AuthEnv] :: AuthEnv -> Maybe (Sensitive SessionToken)
[$sel:_authExpiration:AuthEnv] :: AuthEnv -> Maybe ISO8601

-- | The access key ID that identifies the temporary security credentials.
authAccessKeyId :: Lens' AuthEnv AccessKey

-- | The secret access key that can be used to sign requests.
authSecretAccessKey :: Lens' AuthEnv SecretKey

-- | The token that users must pass to the service API to use the temporary
--   credentials.
authSessionToken :: Lens' AuthEnv (Maybe SessionToken)

-- | The date on which the current credentials expire.
authExpiration :: Lens' AuthEnv (Maybe UTCTime)
data LogLevel

-- | Info messages supplied by the user - this level is not emitted by the
--   library.
Info :: LogLevel

-- | Error messages only.
Error :: LogLevel

-- | Useful debug information + info + error levels.
Debug :: LogLevel

-- | Includes potentially sensitive signing metadata, and non-streaming
--   response bodies.
Trace :: LogLevel

-- | A function threaded through various request and serialisation routines
--   to log informational and debug messages.
type Logger = LogLevel -> ByteStringBuilder -> IO ()
type Algorithm a = Request a -> AuthEnv -> Region -> UTCTime -> Signed a

-- | Signing algorithm specific metadata.
data Meta
[Meta] :: ToLog a => a -> Meta
data Signer
Signer :: (forall a. Algorithm a) -> (forall a. Seconds -> Algorithm a) -> Signer
[$sel:signerSign:Signer] :: Signer -> forall a. Algorithm a
[$sel:signerPresign:Signer] :: Signer -> forall a. Seconds -> Algorithm a

-- | A signed <a>ClientRequest</a> and associated metadata specific to the
--   signing algorithm, tagged with the initial request type to be able to
--   obtain the associated response, 'Rs a'.
data Signed a
Signed :: Meta -> ClientRequest -> Signed a
[$sel:signedMeta:Signed] :: Signed a -> Meta
[$sel:signedRequest:Signed] :: Signed a -> ClientRequest

-- | Abbreviated service name.
data Abbrev

-- | Attributes and functions specific to an AWS service.
data Service
Service :: Abbrev -> Signer -> ByteString -> ByteString -> ByteString -> (Region -> Endpoint) -> Maybe Seconds -> (Status -> Bool) -> (Status -> [Header] -> ByteStringLazy -> Error) -> Retry -> Service
[$sel:_serviceAbbrev:Service] :: Service -> Abbrev
[$sel:_serviceSigner:Service] :: Service -> Signer
[$sel:_serviceSigningName:Service] :: Service -> ByteString
[$sel:_serviceVersion:Service] :: Service -> ByteString
[$sel:_serviceEndpointPrefix:Service] :: Service -> ByteString
[$sel:_serviceEndpoint:Service] :: Service -> Region -> Endpoint
[$sel:_serviceTimeout:Service] :: Service -> Maybe Seconds
[$sel:_serviceCheck:Service] :: Service -> Status -> Bool
[$sel:_serviceError:Service] :: Service -> Status -> [Header] -> ByteStringLazy -> Error
[$sel:_serviceRetry:Service] :: Service -> Retry
serviceSigner :: Lens' Service Signer
serviceEndpoint :: Setter' Service Endpoint
serviceTimeout :: Lens' Service (Maybe Seconds)
serviceCheck :: Lens' Service (Status -> Bool)
serviceRetry :: Lens' Service Retry

-- | Specify how a request can be de/serialised.
class AWSRequest a where {
    
    -- | The successful, expected response associated with a request.
    type family AWSResponse a :: *;
}
request :: AWSRequest a => a -> Request a
response :: (AWSRequest a, MonadResource m) => Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))

-- | An unsigned request.
data Request a
Request :: Service -> StdMethod -> RawPath -> QueryString -> [Header] -> RequestBody -> Request a
[$sel:_requestService:Request] :: Request a -> Service
[$sel:_requestMethod:Request] :: Request a -> StdMethod
[$sel:_requestPath:Request] :: Request a -> RawPath
[$sel:_requestQuery:Request] :: Request a -> QueryString
[$sel:_requestHeaders:Request] :: Request a -> [Header]
[$sel:_requestBody:Request] :: Request a -> RequestBody
requestService :: Lens' (Request a) Service
requestMethod :: Lens' (Request a) StdMethod
requestHeaders :: Lens' (Request a) [Header]
requestPath :: Lens' (Request a) RawPath
requestQuery :: Lens' (Request a) QueryString
requestBody :: Lens' (Request a) RequestBody
requestSign :: Algorithm a
requestPresign :: Seconds -> Algorithm a

-- | Constants and predicates used to create a <tt>RetryPolicy</tt>.
data Retry
Exponential :: Double -> Int -> Int -> (ServiceError -> Maybe Text) -> Retry
[$sel:_retryBase:Exponential] :: Retry -> Double
[$sel:_retryGrowth:Exponential] :: Retry -> Int
[$sel:_retryAttempts:Exponential] :: Retry -> Int

-- | Returns a descriptive name for logging if the request should be
--   retried.
[$sel:_retryCheck:Exponential] :: Retry -> ServiceError -> Maybe Text
exponentBase :: Lens' Retry Double
exponentGrowth :: Lens' Retry Int
retryAttempts :: Lens' Retry Int
retryCheck :: Lens' Retry (ServiceError -> Maybe Text)
class AsError a

-- | A general Amazonka error.
_Error :: AsError a => Prism' a Error

-- | An error occured while communicating over HTTP with a remote service.
_TransportError :: AsError a => Prism' a HttpException

-- | A serialisation error occured when attempting to deserialise a
--   response.
_SerializeError :: AsError a => Prism' a SerializeError

-- | A service specific error returned by the remote service.
_ServiceError :: AsError a => Prism' a ServiceError

-- | An error type representing errors that can be attributed to this
--   library.
data Error
TransportError :: HttpException -> Error
SerializeError :: SerializeError -> Error
ServiceError :: ServiceError -> Error

-- | An exception which may be generated by this library
data HttpException
data SerializeError
SerializeError' :: Abbrev -> Status -> Maybe ByteStringLazy -> String -> SerializeError
[$sel:_serializeErrorAbbrev:SerializeError'] :: SerializeError -> Abbrev
[$sel:_serializeErrorStatus:SerializeError'] :: SerializeError -> Status

-- | The response body, if the response was not streaming.
[$sel:_serializeErrorBody:SerializeError'] :: SerializeError -> Maybe ByteStringLazy
[$sel:_serializeErrorMessage:SerializeError'] :: SerializeError -> String
serializeAbbrev :: Lens' SerializeError Abbrev
serializeStatus :: Lens' SerializeError Status
serializeMessage :: Lens' SerializeError String
data ServiceError
ServiceError' :: Abbrev -> Status -> [Header] -> ErrorCode -> Maybe ErrorMessage -> Maybe RequestId -> ServiceError
[$sel:_serviceErrorAbbrev:ServiceError'] :: ServiceError -> Abbrev
[$sel:_serviceErrorStatus:ServiceError'] :: ServiceError -> Status
[$sel:_serviceErrorHeaders:ServiceError'] :: ServiceError -> [Header]
[$sel:_serviceErrorCode:ServiceError'] :: ServiceError -> ErrorCode
[$sel:_serviceErrorMessage:ServiceError'] :: ServiceError -> Maybe ErrorMessage
[$sel:_serviceErrorRequestId:ServiceError'] :: ServiceError -> Maybe RequestId
serviceAbbrev :: Lens' ServiceError Abbrev
serviceStatus :: Lens' ServiceError Status
serviceHeaders :: Lens' ServiceError [Header]
serviceCode :: Lens' ServiceError ErrorCode
serviceMessage :: Lens' ServiceError (Maybe ErrorMessage)
serviceRequestId :: Lens' ServiceError (Maybe RequestId)
newtype ErrorCode
ErrorCode :: Text -> ErrorCode

-- | Construct an <a>ErrorCode</a>.
newErrorCode :: Text -> ErrorCode
newtype ErrorMessage
ErrorMessage :: Text -> ErrorMessage
[$sel:fromErrorMessage:ErrorMessage] :: ErrorMessage -> Text
newtype RequestId
RequestId :: Text -> RequestId
[$sel:fromRequestId:RequestId] :: RequestId -> Text

-- | The available AWS regions.
newtype Region
Region' :: Text -> Region
[$sel:fromRegion:Region'] :: Region -> Text
pattern NorthVirginia :: Region
pattern Ohio :: Region
pattern NorthCalifornia :: Region
pattern Oregon :: Region
pattern GovCloudWest :: Region
pattern GovCloudEast :: Region
pattern Montreal :: Region
pattern SaoPaulo :: Region
pattern Frankfurt :: Region
pattern Ireland :: Region
pattern London :: Region
pattern Milan :: Region
pattern Paris :: Region
pattern Stockholm :: Region
pattern Bahrain :: Region
pattern CapeTown :: Region
pattern Beijing :: Region
pattern Ningxia :: Region
pattern HongKong :: Region
pattern Tokyo :: Region
pattern Seoul :: Region
pattern Osaka :: Region
pattern Singapore :: Region
pattern Sydney :: Region
pattern Mumbai :: Region
data Endpoint
Endpoint :: ByteString -> Bool -> Int -> ByteString -> Endpoint
[$sel:_endpointHost:Endpoint] :: Endpoint -> ByteString
[$sel:_endpointSecure:Endpoint] :: Endpoint -> Bool
[$sel:_endpointPort:Endpoint] :: Endpoint -> Int
[$sel:_endpointScope:Endpoint] :: Endpoint -> ByteString
endpointHost :: Lens' Endpoint ByteString
endpointPort :: Lens' Endpoint Int
endpointSecure :: Lens' Endpoint Bool
endpointScope :: Lens' Endpoint ByteString

-- | A convenience alias to avoid type ambiguity.
type ClientRequest = Request

-- | A convenience alias encapsulating the common <tt>Response</tt>.
type ClientResponse = Response

-- | A convenience alias encapsulating the common <tt>Response</tt> body.
type ClientBody = ConduitM () ByteString (ResourceT IO) ()

-- | Construct a <a>ClientRequest</a> using common parameters such as TLS
--   and prevent throwing errors when receiving erroneous status codes in
--   respones.
newClientRequest :: Endpoint -> Maybe Seconds -> ClientRequest

-- | An integral value representing seconds.
newtype Seconds
Seconds :: Int -> Seconds
toSeconds :: Seconds -> Int
toMicroseconds :: Seconds -> Int
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Abbrev
instance Network.AWS.Data.Text.ToText Network.AWS.Types.Abbrev
instance Network.AWS.Data.Text.FromText Network.AWS.Types.Abbrev
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.Abbrev
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.Abbrev
instance Data.String.IsString Network.AWS.Types.Abbrev
instance GHC.Generics.Generic Network.AWS.Types.Abbrev
instance GHC.Show.Show Network.AWS.Types.Abbrev
instance GHC.Classes.Ord Network.AWS.Types.Abbrev
instance GHC.Classes.Eq Network.AWS.Types.Abbrev
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.ErrorCode
instance Network.AWS.Data.Text.ToText Network.AWS.Types.ErrorCode
instance GHC.Show.Show Network.AWS.Types.ErrorCode
instance GHC.Classes.Ord Network.AWS.Types.ErrorCode
instance GHC.Classes.Eq Network.AWS.Types.ErrorCode
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.ErrorMessage
instance Network.AWS.Data.Text.ToText Network.AWS.Types.ErrorMessage
instance Network.AWS.Data.Text.FromText Network.AWS.Types.ErrorMessage
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.ErrorMessage
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.ErrorMessage
instance Data.String.IsString Network.AWS.Types.ErrorMessage
instance GHC.Generics.Generic Network.AWS.Types.ErrorMessage
instance GHC.Show.Show Network.AWS.Types.ErrorMessage
instance GHC.Classes.Ord Network.AWS.Types.ErrorMessage
instance GHC.Classes.Eq Network.AWS.Types.ErrorMessage
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.RequestId
instance Network.AWS.Data.Text.ToText Network.AWS.Types.RequestId
instance Network.AWS.Data.Text.FromText Network.AWS.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.RequestId
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.RequestId
instance Data.String.IsString Network.AWS.Types.RequestId
instance GHC.Generics.Generic Network.AWS.Types.RequestId
instance GHC.Show.Show Network.AWS.Types.RequestId
instance GHC.Classes.Ord Network.AWS.Types.RequestId
instance GHC.Classes.Eq Network.AWS.Types.RequestId
instance GHC.Generics.Generic Network.AWS.Types.SerializeError
instance GHC.Show.Show Network.AWS.Types.SerializeError
instance GHC.Classes.Eq Network.AWS.Types.SerializeError
instance GHC.Generics.Generic Network.AWS.Types.ServiceError
instance GHC.Show.Show Network.AWS.Types.ServiceError
instance GHC.Classes.Eq Network.AWS.Types.ServiceError
instance GHC.Generics.Generic Network.AWS.Types.Error
instance GHC.Show.Show Network.AWS.Types.Error
instance GHC.Show.Show Network.AWS.Types.Endpoint
instance GHC.Classes.Eq Network.AWS.Types.Endpoint
instance GHC.Generics.Generic Network.AWS.Types.LogLevel
instance GHC.Show.Show Network.AWS.Types.LogLevel
instance GHC.Enum.Enum Network.AWS.Types.LogLevel
instance GHC.Classes.Ord Network.AWS.Types.LogLevel
instance GHC.Classes.Eq Network.AWS.Types.LogLevel
instance GHC.Generics.Generic Network.AWS.Types.Retry
instance Control.DeepSeq.NFData Network.AWS.Types.AccessKey
instance Data.Hashable.Class.Hashable Network.AWS.Types.AccessKey
instance Network.AWS.Data.XML.ToXML Network.AWS.Types.AccessKey
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.AccessKey
instance Network.AWS.Data.Query.ToQuery Network.AWS.Types.AccessKey
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.AccessKey
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.AccessKey
instance Network.AWS.Data.Text.FromText Network.AWS.Types.AccessKey
instance Network.AWS.Data.Text.ToText Network.AWS.Types.AccessKey
instance Data.String.IsString Network.AWS.Types.AccessKey
instance GHC.Generics.Generic Network.AWS.Types.AccessKey
instance GHC.Read.Read Network.AWS.Types.AccessKey
instance GHC.Show.Show Network.AWS.Types.AccessKey
instance GHC.Classes.Eq Network.AWS.Types.AccessKey
instance Control.DeepSeq.NFData Network.AWS.Types.SecretKey
instance Data.Hashable.Class.Hashable Network.AWS.Types.SecretKey
instance Network.AWS.Data.XML.ToXML Network.AWS.Types.SecretKey
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.SecretKey
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.SecretKey
instance Network.AWS.Data.Text.FromText Network.AWS.Types.SecretKey
instance Network.AWS.Data.Text.ToText Network.AWS.Types.SecretKey
instance Data.String.IsString Network.AWS.Types.SecretKey
instance GHC.Generics.Generic Network.AWS.Types.SecretKey
instance GHC.Classes.Eq Network.AWS.Types.SecretKey
instance Control.DeepSeq.NFData Network.AWS.Types.SessionToken
instance Data.Hashable.Class.Hashable Network.AWS.Types.SessionToken
instance Network.AWS.Data.XML.ToXML Network.AWS.Types.SessionToken
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.SessionToken
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.SessionToken
instance Network.AWS.Data.Text.FromText Network.AWS.Types.SessionToken
instance Network.AWS.Data.Text.ToText Network.AWS.Types.SessionToken
instance Data.String.IsString Network.AWS.Types.SessionToken
instance GHC.Generics.Generic Network.AWS.Types.SessionToken
instance GHC.Classes.Eq Network.AWS.Types.SessionToken
instance Control.DeepSeq.NFData Network.AWS.Types.AuthEnv
instance GHC.Generics.Generic Network.AWS.Types.AuthEnv
instance GHC.Show.Show Network.AWS.Types.AuthEnv
instance GHC.Classes.Eq Network.AWS.Types.AuthEnv
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Region
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.Region
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.Region
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Types.Region
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.Region
instance Network.AWS.Data.XML.ToXML Network.AWS.Types.Region
instance Network.AWS.Data.Query.ToQuery Network.AWS.Types.Region
instance Network.AWS.Data.Text.FromText Network.AWS.Types.Region
instance Network.AWS.Data.Text.ToText Network.AWS.Types.Region
instance Control.DeepSeq.NFData Network.AWS.Types.Region
instance Data.Hashable.Class.Hashable Network.AWS.Types.Region
instance Data.String.IsString Network.AWS.Types.Region
instance GHC.Generics.Generic Network.AWS.Types.Region
instance GHC.Classes.Ord Network.AWS.Types.Region
instance GHC.Classes.Eq Network.AWS.Types.Region
instance GHC.Read.Read Network.AWS.Types.Region
instance GHC.Show.Show Network.AWS.Types.Region
instance Control.DeepSeq.NFData Network.AWS.Types.Seconds
instance Data.Hashable.Class.Hashable Network.AWS.Types.Seconds
instance Network.AWS.Data.Text.FromText Network.AWS.Types.Seconds
instance Network.AWS.Data.Text.ToText Network.AWS.Types.Seconds
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.Seconds
instance Network.AWS.Data.Query.ToQuery Network.AWS.Types.Seconds
instance GHC.Real.Real Network.AWS.Types.Seconds
instance GHC.Real.Integral Network.AWS.Types.Seconds
instance GHC.Enum.Bounded Network.AWS.Types.Seconds
instance GHC.Num.Num Network.AWS.Types.Seconds
instance GHC.Enum.Enum Network.AWS.Types.Seconds
instance GHC.Generics.Generic Network.AWS.Types.Seconds
instance GHC.Show.Show Network.AWS.Types.Seconds
instance GHC.Read.Read Network.AWS.Types.Seconds
instance GHC.Classes.Ord Network.AWS.Types.Seconds
instance GHC.Classes.Eq Network.AWS.Types.Seconds
instance GHC.Generics.Generic Network.AWS.Types.Service
instance GHC.Generics.Generic (Network.AWS.Types.Request a)
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Seconds
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Auth
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.AuthEnv
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.AuthEnv
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.AuthEnv
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Types.SessionToken
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.SessionToken
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Types.SecretKey
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.SecretKey
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.Types.AccessKey
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.AccessKey
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Meta
instance Network.AWS.Data.Text.FromText Network.AWS.Types.LogLevel
instance Network.AWS.Data.Text.ToText Network.AWS.Types.LogLevel
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Types.LogLevel
instance Network.AWS.Types.AsError GHC.Exception.Type.SomeException
instance Network.AWS.Types.AsError Network.AWS.Types.Error
instance GHC.Exception.Type.Exception Network.AWS.Types.Error
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.Error
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.ServiceError
instance Network.AWS.Data.Log.ToLog Network.AWS.Types.SerializeError
instance Data.String.IsString Network.AWS.Types.ErrorCode
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.Types.ErrorCode
instance Network.AWS.Data.XML.FromXML Network.AWS.Types.ErrorCode
instance Network.AWS.Data.Text.FromText Network.AWS.Types.ErrorCode


-- | This module provides an AWS compliant V2 Header request signer. It is
--   based heavily on <a>boto</a>, specifically boto's
--   <tt>HmacAuthV1Handler</tt> AWS capable signer. AWS documentation is
--   available <a>here</a>.
--   
--   Notice: Limitations include an inability to sign with a security token
--   and inability to overwrite the <tt>Date</tt> header with an expiry.
module Network.AWS.Sign.V2Header
v2Header :: Signer
instance Network.AWS.Data.Log.ToLog Network.AWS.Sign.V2Header.V2Header


module Network.AWS.Sign.V2
v2 :: Signer
instance Network.AWS.Data.Log.ToLog Network.AWS.Sign.V2.V2


-- | Functions contained in this module fully consume the body and thus
--   close the connection. This is needed to avoid hitting this issue:
--   <a>https://github.com/brendanhay/amazonka/issues/490</a>.
--   
--   The only exception is <a>receiveBody</a>, which passes a streaming
--   response body to a callback and thus is not allowed to close the
--   connection. Users of streaming functions are advised to be careful and
--   consume the response body manually if they want the connection to be
--   closed promptly.
--   
--   Note that using <tt>runResourceT</tt> will always close the
--   connection.
module Network.AWS.Response
receiveNull :: MonadResource m => AWSResponse a -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveEmpty :: MonadResource m => (Int -> ResponseHeaders -> () -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveXMLWrapper :: MonadResource m => Text -> (Int -> ResponseHeaders -> [Node] -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveXML :: MonadResource m => (Int -> ResponseHeaders -> [Node] -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveJSON :: MonadResource m => (Int -> ResponseHeaders -> Object -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveBytes :: MonadResource m => (Int -> ResponseHeaders -> ByteString -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))
receiveBody :: MonadResource m => (Int -> ResponseHeaders -> ResponseBody -> Either String (AWSResponse a)) -> Logger -> Service -> Proxy a -> ClientResponse ClientBody -> m (Either Error (ClientResponse (AWSResponse a)))


module Network.AWS.Pager

-- | Specify how an <a>AWSRequest</a> and it's associated <tt>Rs</tt>
--   response can generate a subsequent request, if available.
class AWSRequest a => AWSPager a
page :: AWSPager a => a -> AWSResponse a -> Maybe a

-- | Generalise IsTruncated and other optional/required response pagination
--   fields.
class AWSTruncated a
truncated :: AWSTruncated a => a -> Bool
stop :: AWSTruncated a => a -> Bool
choice :: (Alternative f, ToText a, ToText b) => (s -> f a) -> (s -> f b) -> Getter s (f Text)
instance Network.AWS.Pager.AWSTruncated GHC.Types.Bool
instance Network.AWS.Pager.AWSTruncated [a]
instance Network.AWS.Pager.AWSTruncated (Data.HashMap.Internal.HashMap k v)
instance Network.AWS.Pager.AWSTruncated (GHC.Maybe.Maybe a)
instance Network.AWS.Pager.AWSTruncated (GHC.Maybe.Maybe GHC.Types.Bool)


-- | Types and functions for constructing loggers and emitting log
--   messages.
module Network.AWS.Logger

-- | A function threaded through various request and serialisation routines
--   to log informational and debug messages.
type Logger = LogLevel -> ByteStringBuilder -> IO ()

-- | This is a primitive logger which can be used to log builds to a
--   <tt>Handle</tt>.
--   
--   <i>Note:</i> A more sophisticated logging library such as
--   <a>tinylog</a> or <a>fast-logger</a> should be used in production
--   code.
newLogger :: MonadIO m => LogLevel -> Handle -> m Logger
data LogLevel

-- | Info messages supplied by the user - this level is not emitted by the
--   library.
Info :: LogLevel

-- | Error messages only.
Error :: LogLevel

-- | Useful debug information + info + error levels.
Debug :: LogLevel

-- | Includes potentially sensitive signing metadata, and non-streaming
--   response bodies.
Trace :: LogLevel
logError :: (MonadIO m, ToLog a) => Logger -> a -> m ()
logInfo :: (MonadIO m, ToLog a) => Logger -> a -> m ()
logDebug :: (MonadIO m, ToLog a) => Logger -> a -> m ()
logTrace :: (MonadIO m, ToLog a) => Logger -> a -> m ()
class ToLog a

-- | Convert a value to a loggable builder.
build :: ToLog a => a -> ByteStringBuilder

-- | Intercalate a list of <a>ByteStringBuilder</a>s with newlines.
buildLines :: [ByteStringBuilder] -> ByteStringBuilder


module Network.AWS.Error

-- | Provides a generalised prism for catching a specific service error
--   identified by the opaque service abbreviation and error code.
--   
--   This can be used if the generated error prisms provided by
--   <tt>Network.AWS.<a>ServiceName</a>.Types</tt> do not cover all the
--   thrown error codes. For example to define a new error prism:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Network.AWS.S3 (ServiceError, s3)
--   
--   _NoSuchBucketPolicy :: AsError a =&gt; Getting (First ServiceError) a ServiceError
--   _NoSuchBucketPolicy = _MatchServiceError s3 "NoSuchBucketPolicy"
--   </pre>
--   
--   With example usage being:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Exception.Lens (trying)
--   
--   &gt;&gt;&gt; :t trying _NoSuchBucketPolicy
--   MonadCatch m =&gt; m a -&gt; m (Either ServiceError a)
--   </pre>
_MatchServiceError :: AsError a => Service -> ErrorCode -> Getting (First ServiceError) a ServiceError
statusSuccess :: Status -> Bool
_HttpStatus :: AsError a => Getting (First Status) a Status
hasService :: (Applicative f, Choice p) => Service -> Optic' p f ServiceError ServiceError
hasStatus :: (Applicative f, Choice p) => Int -> Optic' p f ServiceError ServiceError
hasCode :: (Applicative f, Choice p) => ErrorCode -> Optic' p f ServiceError ServiceError
serviceError :: Abbrev -> Status -> [Header] -> Maybe ErrorCode -> Maybe ErrorMessage -> Maybe RequestId -> ServiceError
getRequestId :: [Header] -> Maybe RequestId
getErrorCode :: Status -> [Header] -> ErrorCode
parseJSONError :: Abbrev -> Status -> [Header] -> ByteStringLazy -> Error
parseXMLError :: Abbrev -> Status -> [Header] -> ByteStringLazy -> Error
parseRESTError :: Abbrev -> Status -> [Header] -> a -> Error
decodeError :: Abbrev -> Status -> [Header] -> ByteStringLazy -> Either String ServiceError -> Error


module Network.AWS.Endpoint

-- | A convenience function for overriding the <a>Service</a>
--   <a>Endpoint</a>.
--   
--   <i>See:</i> <a>serviceEndpoint</a>.
setEndpoint :: Bool -> ByteString -> Int -> Service -> Service

-- | Determine the full host address and credential scope within the
--   specified <a>Region</a>.
defaultEndpoint :: Service -> Region -> Endpoint


-- | This module contains functions for retrieving various EC2 metadata
--   from an instance's local metadata endpoint.
--   
--   It is intended to be used when you need to make metadata calls prior
--   to initialisation of the <a>Env</a>.
module Network.AWS.EC2.Metadata

-- | Test whether the underlying host is running on EC2 by making an HTTP
--   request to <tt><a>http://instance-data/latest</a></tt>.
isEC2 :: MonadIO m => Manager -> m Bool

-- | Retrieve the specified <a>Dynamic</a> data.
--   
--   Throws <tt>HttpException</tt> if HTTP communication fails.
dynamic :: MonadIO m => Manager -> Dynamic -> m ByteString

-- | Retrieve the specified <a>Metadata</a>.
--   
--   Throws <tt>HttpException</tt> if HTTP communication fails.
metadata :: MonadIO m => Manager -> Metadata -> m ByteString

-- | Retrieve the user data. Returns <a>Nothing</a> if no user data is
--   assigned to the instance.
--   
--   Throws <tt>HttpException</tt> if HTTP communication fails.
userdata :: MonadIO m => Manager -> m (Maybe ByteString)

-- | Retrieve the instance's identity document, detailing various EC2
--   metadata.
--   
--   You can alternatively retrieve the raw unparsed identity document by
--   using <a>dynamic</a> and the <a>Document</a> path.
--   
--   <i>See:</i> <a>AWS Instance Identity Documents</a>.
identity :: MonadIO m => Manager -> m (Either String IdentityDocument)
data Dynamic

-- | Value showing whether the customer has enabled detailed one-minute
--   monitoring in CloudWatch.
--   
--   Valid values: enabled | disabled.
FWS :: Dynamic

-- | JSON containing instance attributes, such as instance-id, private IP
--   address, etc. <i>See:</i> <a>identity</a>, <tt>InstanceDocument</tt>.
Document :: Dynamic

-- | Used to verify the document's authenticity and content against the
--   signature.
PKCS7 :: Dynamic
Signature :: Dynamic
data Metadata

-- | The AMI ID used to launch the instance.
AMIId :: Metadata

-- | If you started more than one instance at the same time, this value
--   indicates the order in which the instance was launched. The value of
--   the first instance launched is 0.
AMILaunchIndex :: Metadata

-- | The path to the AMI's manifest file in Amazon S3. If you used an
--   Amazon EBS-backed AMI to launch the instance, the returned result is
--   unknown.
AMIManifestPath :: Metadata

-- | The AMI IDs of any instances that were rebundled to create this AMI.
--   This value will only exist if the AMI manifest file contained an
--   ancestor-amis key.
AncestorAMIIds :: Metadata

-- | See: <a>Mapping</a>
BlockDevice :: !Mapping -> Metadata

-- | The private hostname of the instance. In cases where multiple network
--   interfaces are present, this refers to the eth0 device (the device for
--   which the device number is 0).
Hostname :: Metadata

-- | See: <a>Info</a>
IAM :: !Info -> Metadata

-- | Notifies the instance that it should reboot in preparation for
--   bundling. Valid values: none | shutdown | bundle-pending.
InstanceAction :: Metadata

-- | The ID of this instance.
InstanceId :: Metadata

-- | The type of instance.
--   
--   See: <tt>InstanceType</tt>
InstanceType :: Metadata

-- | The ID of the kernel launched with this instance, if applicable.
KernelId :: Metadata

-- | The private DNS hostname of the instance. In cases where multiple
--   network interfaces are present, this refers to the eth0 device (the
--   device for which the device number is 0).
LocalHostname :: Metadata

-- | The private IP address of the instance. In cases where multiple
--   network interfaces are present, this refers to the eth0 device (the
--   device for which the device number is 0).
LocalIPV4 :: Metadata

-- | The instance's media access control (MAC) address. In cases where
--   multiple network interfaces are present, this refers to the eth0
--   device (the device for which the device number is 0).
MAC :: Metadata

-- | See: <a>Interface</a>
Network :: !Text -> !Interface -> Metadata

-- | The Availability Zone in which the instance launched.
AvailabilityZone :: Metadata

-- | Product codes associated with the instance, if any.
ProductCodes :: Metadata

-- | The instance's public DNS. If the instance is in a VPC, this category
--   is only returned if the enableDnsHostnames attribute is set to true.
--   For more information, see Using DNS with Your VPC.
PublicHostname :: Metadata

-- | The public IP address. If an Elastic IP address is associated with the
--   instance, the value returned is the Elastic IP address.
PublicIPV4 :: Metadata

-- | Public key. Only available if supplied at instance launch time.
OpenSSHKey :: Metadata

-- | The ID of the RAM disk specified at launch time, if applicable.
RAMDiskId :: Metadata

-- | ID of the reservation.
ReservationId :: Metadata

-- | The names of the security groups applied to the instance.
SecurityGroups :: Metadata
data Mapping

-- | The virtual device that contains the root/boot file system.
AMI :: Mapping

-- | The virtual devices associated with Amazon EBS volumes, if present.
--   This value is only available in metadata if it is present at launch
--   time. The N indicates the index of the Amazon EBS volume (such as ebs1
--   or ebs2).
EBS :: !Int -> Mapping

-- | The virtual devices associated with ephemeral devices, if present. The
--   N indicates the index of the ephemeral volume.
Ephemeral :: !Int -> Mapping

-- | The virtual devices or partitions associated with the root devices, or
--   partitions on the virtual device, where the root (/ or C:) file system
--   is associated with the given instance.
Root :: Mapping

-- | The virtual devices associated with swap. Not always present.
Swap :: Mapping
data Info

-- | Returns information about the last time the instance profile was
--   updated, including the instance's LastUpdated date,
--   InstanceProfileArn, and InstanceProfileId.
Info' :: Info

-- | Where role-name is the name of the IAM role associated with the
--   instance. Returns the temporary security credentials.
--   
--   See: <tt>Auth</tt> for JSON deserialisation.
SecurityCredentials :: Maybe Text -> Info
data Interface

-- | The device number associated with that interface. Each interface must
--   have a unique device number. The device number serves as a hint to
--   device naming in the instance; for example, device-number is 2 for the
--   eth2 device.
IDeviceNumber :: Interface

-- | The private IPv4 addresses that are associated with each public-ip
--   address and assigned to that interface.
IIPV4Associations :: !Text -> Interface

-- | The interface's local hostname.
ILocalHostname :: Interface

-- | The private IP addresses associated with the interface.
ILocalIPV4s :: Interface

-- | The instance's MAC address.
IMAC :: Interface

-- | The ID of the owner of the network interface. In multiple-interface
--   environments, an interface can be attached by a third party, such as
--   Elastic Load Balancing. Traffic on an interface is always billed to
--   the interface owner.
IOwnerId :: Interface

-- | The interface's public DNS. If the instance is in a VPC, this category
--   is only returned if the enableDnsHostnames attribute is set to true.
--   For more information, see Using DNS with Your VPC.
IPublicHostname :: Interface

-- | The Elastic IP addresses associated with the interface. There may be
--   multiple IP addresses on an instance.
IPublicIPV4s :: Interface

-- | Security groups to which the network interface belongs. Returned only
--   for instances launched into a VPC.
ISecurityGroups :: Interface

-- | IDs of the security groups to which the network interface belongs.
--   Returned only for instances launched into a VPC. For more information
--   on security groups in the EC2-VPC platform, see Security Groups for
--   Your VPC.
ISecurityGroupIds :: Interface

-- | The ID of the subnet in which the interface resides. Returned only for
--   instances launched into a VPC.
ISubnetId :: Interface

-- | The CIDR block of the subnet in which the interface resides. Returned
--   only for instances launched into a VPC.
ISubnetIPV4_CIDRBlock :: Interface

-- | The ID of the VPC in which the interface resides. Returned only for
--   instances launched into a VPC.
IVPCId :: Interface

-- | The CIDR block of the VPC in which the interface resides. Returned
--   only for instances launched into a VPC.
IVPCIPV4_CIDRBlock :: Interface

-- | Represents an instance's identity document.
--   
--   <i>Note:</i> Fields such as <a>$sel:_instanceType:IdentityDocument</a>
--   are represented as unparsed <a>Text</a> and will need to be manually
--   parsed using <a>fromText</a> when the relevant types from a library
--   such as <a>Network.AWS.EC2</a> are brought into scope.
data IdentityDocument
IdentityDocument :: Maybe [Text] -> Maybe [Text] -> Maybe Text -> Maybe Text -> Text -> Region -> Text -> Text -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe ISO8601 -> IdentityDocument
[$sel:_devpayProductCodes:IdentityDocument] :: IdentityDocument -> Maybe [Text]
[$sel:_billingProducts:IdentityDocument] :: IdentityDocument -> Maybe [Text]
[$sel:_version:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_privateIp:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_availabilityZone:IdentityDocument] :: IdentityDocument -> Text
[$sel:_region:IdentityDocument] :: IdentityDocument -> Region
[$sel:_instanceId:IdentityDocument] :: IdentityDocument -> Text
[$sel:_instanceType:IdentityDocument] :: IdentityDocument -> Text
[$sel:_accountId:IdentityDocument] :: IdentityDocument -> Text
[$sel:_imageId:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_kernelId:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_ramdiskId:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_architecture:IdentityDocument] :: IdentityDocument -> Maybe Text
[$sel:_pendingTime:IdentityDocument] :: IdentityDocument -> Maybe ISO8601
devpayProductCodes :: Lens' IdentityDocument (Maybe [Text])
billingProducts :: Lens' IdentityDocument (Maybe [Text])
version :: Lens' IdentityDocument (Maybe Text)
privateIp :: Lens' IdentityDocument (Maybe Text)
availabilityZone :: Lens' IdentityDocument Text
region :: Lens' IdentityDocument Region
instanceId :: Lens' IdentityDocument Text
instanceType :: Lens' IdentityDocument Text
accountId :: Lens' IdentityDocument Text
imageId :: Lens' IdentityDocument (Maybe Text)
kernelId :: Lens' IdentityDocument (Maybe Text)
ramdiskId :: Lens' IdentityDocument (Maybe Text)
architecture :: Lens' IdentityDocument (Maybe Text)
pendingTime :: Lens' IdentityDocument (Maybe UTCTime)
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.Dynamic
instance GHC.Show.Show Network.AWS.EC2.Metadata.Dynamic
instance GHC.Classes.Ord Network.AWS.EC2.Metadata.Dynamic
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.Dynamic
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.Mapping
instance GHC.Show.Show Network.AWS.EC2.Metadata.Mapping
instance GHC.Classes.Ord Network.AWS.EC2.Metadata.Mapping
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.Mapping
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.Interface
instance GHC.Show.Show Network.AWS.EC2.Metadata.Interface
instance GHC.Classes.Ord Network.AWS.EC2.Metadata.Interface
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.Interface
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.Info
instance GHC.Show.Show Network.AWS.EC2.Metadata.Info
instance GHC.Classes.Ord Network.AWS.EC2.Metadata.Info
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.Info
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.Metadata
instance GHC.Show.Show Network.AWS.EC2.Metadata.Metadata
instance GHC.Classes.Ord Network.AWS.EC2.Metadata.Metadata
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.Metadata
instance GHC.Generics.Generic Network.AWS.EC2.Metadata.IdentityDocument
instance GHC.Show.Show Network.AWS.EC2.Metadata.IdentityDocument
instance GHC.Classes.Eq Network.AWS.EC2.Metadata.IdentityDocument
instance Data.Aeson.Types.FromJSON.FromJSON Network.AWS.EC2.Metadata.IdentityDocument
instance Data.Aeson.Types.ToJSON.ToJSON Network.AWS.EC2.Metadata.IdentityDocument
instance Network.AWS.Data.Text.ToText Network.AWS.EC2.Metadata.Metadata
instance Network.AWS.Data.Text.ToText Network.AWS.EC2.Metadata.Info
instance Network.AWS.Data.Text.ToText Network.AWS.EC2.Metadata.Interface
instance Network.AWS.Data.Text.ToText Network.AWS.EC2.Metadata.Mapping
instance Network.AWS.Data.Text.ToText Network.AWS.EC2.Metadata.Dynamic


-- | Explicitly specify your Amazon AWS security credentials, or retrieve
--   them from the underlying OS.
--   
--   The format of environment variables and the credentials file follows
--   the official <a>AWS SDK guidelines</a>.
module Network.AWS.Auth

-- | Retrieve authentication information via the specified
--   <a>Credentials</a> mechanism.
--   
--   Throws <a>AuthError</a> when environment variables or IAM profiles
--   cannot be read, and credentials files are invalid or cannot be found.
getAuth :: MonadIO m => Manager -> Credentials -> m (Auth, Maybe Region)

-- | Determines how AuthN/AuthZ information is retrieved.
data Credentials

-- | Explicit access and secret keys. See <a>fromKeys</a>.
FromKeys :: AccessKey -> SecretKey -> Credentials

-- | Explicit access key, secret key and a session token. See
--   <a>fromSession</a>.
FromSession :: AccessKey -> SecretKey -> SessionToken -> Credentials

-- | Lookup specific environment variables for access key, secret key, an
--   optional session token, and an optional region, respectively.
FromEnv :: Text -> Text -> Maybe Text -> Maybe Text -> Credentials

-- | An IAM Profile name to lookup from the local EC2 instance-data.
--   Environment variables to lookup for the access key, secret key and
--   optional session token.
FromProfile :: Text -> Credentials

-- | A credentials profile name (the INI section), the path to the AWS
--   <a>credentials</a> file, and the path to the
--   <tt>~<i>.aws</i>config</tt> file.
FromFile :: Text -> FilePath -> FilePath -> Credentials

-- | Obtain credentials by attempting to contact the ECS container agent at
--   <a>http://169.254.170.2</a> using the path in
--   <a>envContainerCredentialsURI</a>. See <a>IAM Roles for Tasks</a> in
--   the AWS documentation for more information.
FromContainer :: Credentials

-- | Attempt credentials discovery via the following steps:
--   
--   <ul>
--   <li>Read the <a>envAccessKey</a>, <a>envSecretKey</a>, and
--   <a>envRegion</a> from the environment if they are set.</li>
--   <li>Read the credentials file if <a>credFile</a> exists.</li>
--   <li>Obtain credentials from the ECS container agent if
--   <a>envContainerCredentialsURI</a> is set.</li>
--   <li>Retrieve the first available IAM profile and read the
--   <a>Region</a> from the instance identity document, if running on
--   EC2.</li>
--   </ul>
--   
--   An attempt is made to resolve <a>http://instance-data</a> rather than
--   directly retrieving <a>http://169.254.169.254</a> for IAM profile
--   information. This assists in ensuring the DNS lookup terminates
--   promptly if not running on EC2.
Discover :: Credentials

-- | An authorisation environment containing AWS credentials, and
--   potentially a reference which can be refreshed out-of-band as
--   temporary credentials expire.
data Auth
Ref :: ThreadId -> IORef AuthEnv -> Auth
Auth :: AuthEnv -> Auth

-- | Default access key environment variable.
envAccessKey :: Text

-- | Default secret key environment variable.
envSecretKey :: Text

-- | Default session token environment variable.
envSessionToken :: Text

-- | Credentials INI default profile section variable.
confRegion :: Text

-- | Default path for the configuration file. This looks in in the
--   <tt>HOME</tt> directory as determined by the <a>directory</a> library.
--   
--   <ul>
--   <li>UNIX<i>OSX: @$HOME</i>.aws/config@</li>
--   <li>Windows: <tt>C:/Users//&lt;user&gt;.awsconfig</tt></li>
--   </ul>
--   
--   <i>Note:</i> This does not match the default AWS SDK location of
--   <tt>%USERPROFILE%.awsconfig</tt> on Windows. (Sorry.)
confFile :: MonadIO m => m FilePath

-- | Credentials INI file access key variable.
credAccessKey :: Text

-- | Credentials INI file secret key variable.
credSecretKey :: Text

-- | Credentials INI file session token variable.
credSessionToken :: Text

-- | Credentials INI default profile section variable.
credProfile :: Text

-- | Default path for the credentials file. This looks in in the
--   <tt>HOME</tt> directory as determined by the <a>directory</a> library.
--   
--   <ul>
--   <li>UNIX<i>OSX: @$HOME</i>.aws/credentials@</li>
--   <li>Windows: <tt>C:/Users//&lt;user&gt;.awscredentials</tt></li>
--   </ul>
--   
--   <i>Note:</i> This does not match the default AWS SDK location of
--   <tt>%USERPROFILE%.awscredentials</tt> on Windows. (Sorry.)
credFile :: MonadIO m => m FilePath

-- | Explicit access and secret keys.
fromKeys :: AccessKey -> SecretKey -> Auth

-- | Temporary credentials from a STS session consisting of the access key,
--   secret key, and session token.
--   
--   <i>See:</i> <a>fromTemporarySession</a>
fromSession :: AccessKey -> SecretKey -> SessionToken -> Auth

-- | Temporary credentials from a STS session consisting of the access key,
--   secret key, session token, and expiration time.
--   
--   <i>See:</i> <a>fromSession</a>
fromTemporarySession :: AccessKey -> SecretKey -> SessionToken -> UTCTime -> Auth

-- | Retrieve access key, secret key, and a session token from the default
--   environment variables.
--   
--   Throws <a>MissingEnvError</a> if either of the default environment
--   variables cannot be read, but not if the session token is absent.
--   
--   <i>See:</i> <a>envAccessKey</a>, <a>envSecretKey</a>,
--   <a>envSessionToken</a>
fromEnv :: MonadIO m => m (Auth, Maybe Region)

-- | Retrieve access key, secret key and a session token from specific
--   environment variables.
--   
--   Throws <a>MissingEnvError</a> if either of the specified key
--   environment variables cannot be read, but not if the session token is
--   absent.
fromEnvKeys :: MonadIO m => Text -> Text -> Maybe Text -> Maybe Text -> m (Auth, Maybe Region)

-- | Loads the default <tt>credentials</tt> INI file using the default
--   profile name.
--   
--   Throws <a>MissingFileError</a> if <a>credFile</a> is missing, or
--   <a>InvalidFileError</a> if an error occurs during parsing.
--   
--   <i>See:</i> <a>credProfile</a>, <a>credFile</a>, and <a>envProfile</a>
fromFile :: MonadIO m => m (Auth, Maybe Region)
fromFilePath :: MonadIO m => Text -> FilePath -> FilePath -> m (Auth, Maybe Region)

-- | Retrieve the default IAM Profile from the local EC2 instance-data.
--   
--   The default IAM profile is determined by Amazon as the first profile
--   found in the response from:
--   <tt><a>http://169.254.169.254/latest/meta-data/iam/security-credentials/</a></tt>
--   
--   Throws <a>RetrievalError</a> if the HTTP call fails, or
--   <a>InvalidIAMError</a> if the default IAM profile cannot be read.
fromProfile :: MonadIO m => Manager -> m (Auth, Maybe Region)

-- | Lookup a specific IAM Profile by name from the local EC2
--   instance-data.
--   
--   Additionally starts a refresh thread for the given authentication
--   environment.
--   
--   The resulting <a>IORef</a> wrapper + timer is designed so that
--   multiple concurrent accesses of <a>AuthEnv</a> from the <tt>AWS</tt>
--   environment are not required to calculate expiry and sequentially
--   queue to update it.
--   
--   The forked timer ensures a singular owner and pre-emptive refresh of
--   the temporary session credentials before expiration.
--   
--   A weak reference is used to ensure that the forked thread will
--   eventually terminate when <a>Auth</a> is no longer referenced.
--   
--   If no session token or expiration time is present the credentials will
--   be returned verbatim.
fromProfileName :: MonadIO m => Manager -> Text -> m (Auth, Maybe Region)

-- | Obtain credentials exposed to a task via the ECS container agent, as
--   described in the <a>IAM Roles for Tasks</a> section of the AWS ECS
--   documentation. The credentials are obtained by making a request to
--   <a>http://169.254.170.2</a> at the path contained by the
--   <a>envContainerCredentialsURI</a> environment variable.
--   
--   The ECS container agent provides an access key, secret key, session
--   token, and expiration time, but it does not include a region, so the
--   region will attempt to be determined from the <a>envRegion</a>
--   environment variable if it is set.
--   
--   Like <a>fromProfileName</a>, additionally starts a refresh thread that
--   will periodically fetch fresh credentials before the current ones
--   expire.
--   
--   Throws <a>MissingEnvError</a> if the <a>envContainerCredentialsURI</a>
--   environment variable is not set or <a>InvalidIAMError</a> if the
--   payload returned by the ECS container agent is not of the expected
--   format.
fromContainer :: MonadIO m => Manager -> m (Auth, Maybe Region)

-- | An access key ID.
--   
--   For example: <tt>AKIAIOSFODNN7EXAMPLE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype AccessKey
AccessKey :: ByteString -> AccessKey

-- | Secret access key credential.
--   
--   For example: <tt>wJalrXUtnFEMI<i>K7MDENG</i>bPxRfiCYEXAMPLEKE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype SecretKey
SecretKey :: ByteString -> SecretKey

-- | A session token used by STS to temporarily authorise access to an AWS
--   resource.
--   
--   <i>See:</i> <a>Temporary Security Credentials</a>.
newtype SessionToken
SessionToken :: ByteString -> SessionToken
class AsAuthError a

-- | A general authentication error.
_AuthError :: AsAuthError a => Prism' a AuthError

-- | An error occured while communicating over HTTP with the local metadata
--   endpoint.
_RetrievalError :: AsAuthError a => Prism' a HttpException

-- | The named environment variable was not found.
_MissingEnvError :: AsAuthError a => Prism' a Text

-- | An error occured parsing named environment variable's value.
_InvalidEnvError :: AsAuthError a => Prism' a Text

-- | The specified credentials file could not be found.
_MissingFileError :: AsAuthError a => Prism' a FilePath

-- | An error occured parsing the credentials file.
_InvalidFileError :: AsAuthError a => Prism' a Text

-- | The specified IAM profile could not be found or deserialised.
_InvalidIAMError :: AsAuthError a => Prism' a Text

-- | An error thrown when attempting to read AuthN/AuthZ information.
data AuthError
RetrievalError :: HttpException -> AuthError
MissingEnvError :: Text -> AuthError
InvalidEnvError :: Text -> AuthError
MissingFileError :: FilePath -> AuthError
InvalidFileError :: Text -> AuthError
InvalidIAMError :: Text -> AuthError
instance GHC.Generics.Generic Network.AWS.Auth.Credentials
instance GHC.Classes.Eq Network.AWS.Auth.Credentials
instance GHC.Generics.Generic Network.AWS.Auth.AuthError
instance GHC.Show.Show Network.AWS.Auth.AuthError
instance Network.AWS.Auth.AsAuthError GHC.Exception.Type.SomeException
instance Network.AWS.Auth.AsAuthError Network.AWS.Auth.AuthError
instance GHC.Exception.Type.Exception Network.AWS.Auth.AuthError
instance Network.AWS.Data.Log.ToLog Network.AWS.Auth.AuthError
instance Network.AWS.Data.Log.ToLog Network.AWS.Auth.Credentials
instance GHC.Show.Show Network.AWS.Auth.Credentials


-- | Environment and AWS specific configuration for the <a>AWS</a> and
--   <a>AWST</a> monads.
module Network.AWS.Env

-- | Creates a new environment with a new <tt>Manager</tt> without debug
--   logging and uses <a>getAuth</a> to expand/discover the supplied
--   <a>Credentials</a>. Lenses from <tt>AWSEnv</tt> can be used to further
--   configure the resulting <a>Env</a>.
--   
--   <i>Since:</i> <tt>1.5.0</tt> - The region is now retrieved from the
--   <tt>AWS_REGION</tt> environment variable (identical to official SDKs),
--   or defaults to <tt>us-east-1</tt>. You can override the <a>Env</a>
--   region by using <a>$sel:envRegion:Env</a>, or the current operation's
--   region by using <a>within</a>.
--   
--   <i>Since:</i> <tt>1.3.6</tt> - The default logic for retrying
--   <a>HttpException</a>s now uses <a>retryConnectionFailure</a> to retry
--   specific connection failure conditions up to 3 times. Previously only
--   service specific errors were automatically retried. This can be
--   reverted to the old behaviour by resetting the <a>Env</a> using
--   <a>$sel:envRetryCheck:Env</a> lens to <tt>(\_ _ -&gt; False)</tt>.
--   
--   Throws <a>AuthError</a> when environment variables or IAM profiles
--   cannot be read.
--   
--   <i>See:</i> <a>newEnvWith</a>.
newEnv :: MonadIO m => Credentials -> m Env

-- | <i>See:</i> <a>newEnv</a>
--   
--   The <a>Maybe</a> <a>Bool</a> parameter is used by the EC2 instance
--   check. By passing a value of <a>Nothing</a>, the check will be
--   performed. <a>Just</a> <a>True</a> would cause the check to be skipped
--   and the host treated as an EC2 instance.
--   
--   Throws <a>AuthError</a> when environment variables or IAM profiles
--   cannot be read.
newEnvWith :: MonadIO m => Credentials -> Manager -> m Env

-- | The environment containing the parameters required to make AWS
--   requests.
data Env
Env :: Region -> Logger -> (Int -> HttpException -> Bool) -> Dual (Endo Service) -> Manager -> Auth -> Env
[$sel:envRegion:Env] :: Env -> Region
[$sel:envLogger:Env] :: Env -> Logger
[$sel:envRetryCheck:Env] :: Env -> Int -> HttpException -> Bool
[$sel:envOverride:Env] :: Env -> Dual (Endo Service)
[$sel:envManager:Env] :: Env -> Manager
[$sel:envAuth:Env] :: Env -> Auth

-- | Provide a function which will be added to the existing stack of
--   overrides applied to all service configurations.
override :: (Service -> Service) -> Env -> Env

-- | Configure a specific service. All requests belonging to the supplied
--   service will use this configuration instead of the default.
--   
--   It's suggested you modify the default service configuration, such as
--   <tt>Network.AWS.DynamoDB.dynamoDB</tt>.
configure :: Service -> Env -> Env

-- | Scope an action within the specific <a>Region</a>.
within :: Region -> Env -> Env

-- | Scope an action such that any retry logic for the <a>Service</a> is
--   ignored and any requests will at most be sent once.
once :: Env -> Env

-- | Scope an action such that any HTTP response will use this timeout
--   value.
--   
--   Default timeouts are chosen by considering:
--   
--   <ul>
--   <li>This <a>timeout</a>, if set.</li>
--   <li>The related <a>Service</a> timeout for the sent request if set.
--   (Usually 70s)</li>
--   <li>The <a>$sel:envManager:Env</a> timeout if set.</li>
--   <li>The default <a>ClientRequest</a> timeout. (Approximately 30s)</li>
--   </ul>
timeout :: Seconds -> Env -> Env

-- | Retry the subset of transport specific errors encompassing connection
--   failure up to the specific number of times.
retryConnectionFailure :: Int -> Int -> HttpException -> Bool
instance GHC.Generics.Generic Network.AWS.Env.Env


module Network.AWS.Waiter
type Acceptor a = Request a -> Either Error (ClientResponse (AWSResponse a)) -> Maybe Accept
data Accept
AcceptSuccess :: Accept
AcceptFailure :: Accept
AcceptRetry :: Accept

-- | Timing and acceptance criteria to check fulfillment of a remote
--   operation.
data Wait a
Wait :: ByteString -> Int -> Seconds -> [Acceptor a] -> Wait a
[$sel:_waitName:Wait] :: Wait a -> ByteString
[$sel:_waitAttempts:Wait] :: Wait a -> Int
[$sel:_waitDelay:Wait] :: Wait a -> Seconds
[$sel:_waitAcceptors:Wait] :: Wait a -> [Acceptor a]
accept :: Wait a -> Acceptor a
matchAll :: Eq b => b -> Accept -> Fold (AWSResponse a) b -> Acceptor a
matchAny :: Eq b => b -> Accept -> Fold (AWSResponse a) b -> Acceptor a
matchNonEmpty :: Bool -> Accept -> Fold (AWSResponse a) b -> Acceptor a
matchError :: ErrorCode -> Accept -> Acceptor a
matchStatus :: Int -> Accept -> Acceptor a
nonEmptyText :: Fold a Text -> Fold a Bool
instance GHC.Show.Show Network.AWS.Waiter.Accept
instance GHC.Classes.Eq Network.AWS.Waiter.Accept
instance Network.AWS.Data.Log.ToLog Network.AWS.Waiter.Accept


module Network.AWS.HTTP
retryRequest :: (MonadResource m, AWSRequest a) => Env -> a -> m (Either Error (ClientResponse (AWSResponse a)))
awaitRequest :: (MonadResource m, AWSRequest a) => Env -> Wait a -> a -> m (Either Error Accept)

-- | The <a>Service</a> is configured + unwrapped at this point.
httpRequest :: (MonadResource m, AWSRequest a) => Env -> Request a -> m (Either Error (ClientResponse (AWSResponse a)))
configureRequest :: AWSRequest a => Env -> a -> Request a
retryService :: Service -> RetryPolicy
retryStream :: Request a -> RetryPolicy


-- | Types and values referenced by generated code.
module Network.AWS.Core
(.!@) :: Functor f => f (Maybe a) -> a -> f a
infixl 7 .!@
may :: Applicative f => ([a] -> f b) -> [a] -> f (Maybe b)


module Network.AWS.Request
head' :: ToRequest a => Service -> a -> Request a
delete :: ToRequest a => Service -> a -> Request a
get :: ToRequest a => Service -> a -> Request a
post :: ToRequest a => Service -> a -> Request a
put :: ToRequest a => Service -> a -> Request a
patchJSON :: (ToRequest a, ToJSON a) => Service -> a -> Request a
postXML :: (ToRequest a, ToElement a) => Service -> a -> Request a
postJSON :: (ToRequest a, ToJSON a) => Service -> a -> Request a
postQuery :: ToRequest a => Service -> a -> Request a
postBody :: (ToRequest a, ToBody a) => Service -> a -> Request a
putXML :: (ToRequest a, ToElement a) => Service -> a -> Request a
putJSON :: (ToRequest a, ToJSON a) => Service -> a -> Request a
putBody :: (ToRequest a, ToBody a) => Service -> a -> Request a
defaultRequest :: ToRequest a => Service -> a -> Request a
contentMD5Header :: Request a -> Request a
expectHeader :: Request a -> Request a
glacierVersionHeader :: ByteString -> Request a -> Request a
s3vhost :: Request a -> Request a
clientRequestHeaders :: Lens' ClientRequest RequestHeaders
clientRequestQuery :: Lens' ClientRequest ByteString
clientRequestURL :: ClientRequest -> ByteString


module Network.AWS.Sign.V4.Base
data V4
V4 :: UTCTime -> Method -> Path -> Endpoint -> Credential -> CanonicalQuery -> CanonicalRequest -> CanonicalHeaders -> SignedHeaders -> StringToSign -> Signature -> [Header] -> Maybe Seconds -> V4
[$sel:metaTime:V4] :: V4 -> UTCTime
[$sel:metaMethod:V4] :: V4 -> Method
[$sel:metaPath:V4] :: V4 -> Path
[$sel:metaEndpoint:V4] :: V4 -> Endpoint
[$sel:metaCredential:V4] :: V4 -> Credential
[$sel:metaCanonicalQuery:V4] :: V4 -> CanonicalQuery
[$sel:metaCanonicalRequest:V4] :: V4 -> CanonicalRequest
[$sel:metaCanonicalHeaders:V4] :: V4 -> CanonicalHeaders
[$sel:metaSignedHeaders:V4] :: V4 -> SignedHeaders
[$sel:metaStringToSign:V4] :: V4 -> StringToSign
[$sel:metaSignature:V4] :: V4 -> Signature
[$sel:metaHeaders:V4] :: V4 -> [Header]
[$sel:metaTimeout:V4] :: V4 -> Maybe Seconds
base :: Hash -> Request a -> AuthEnv -> Region -> UTCTime -> (V4, ClientRequest -> ClientRequest)

-- | Used to tag provenance. This allows keeping the same layout as the
--   signing documentation, passing <a>ByteString</a>s everywhere, with
--   some type guarantees.
--   
--   Data.Tagged is not used for no reason other than syntactic length and
--   the ToByteString instance.
newtype Tag (s :: Symbol) a
Tag :: a -> Tag (s :: Symbol) a
[$sel:untag:Tag] :: Tag (s :: Symbol) a -> a
type Hash = Tag "body-digest" ByteString
type StringToSign = Tag "string-to-sign" ByteString
type Credential = Tag "credential" ByteString
type CredentialScope = Tag "credential-scope" [ByteString]
type CanonicalRequest = Tag "canonical-request" ByteString
type CanonicalHeaders = Tag "canonical-headers" ByteString
type CanonicalQuery = Tag "canonical-query" ByteString
type SignedHeaders = Tag "signed-headers" ByteString
type NormalisedHeaders = Tag "normalised-headers" [(ByteString, ByteString)]
type Method = Tag "method" ByteString
type Path = Tag "path" ByteString
type Signature = Tag "signature" ByteString
authorisation :: V4 -> ByteString
signRequest :: V4 -> RequestBody -> (ClientRequest -> ClientRequest) -> Signed a
signMetadata :: AuthEnv -> Region -> UTCTime -> (Credential -> SignedHeaders -> QueryString -> QueryString) -> Hash -> Request a -> V4
algorithm :: ByteString
signature :: SecretKey -> CredentialScope -> StringToSign -> Signature
stringToSign :: UTCTime -> CredentialScope -> CanonicalRequest -> StringToSign
credential :: AccessKey -> CredentialScope -> Credential
credentialScope :: Service -> Endpoint -> UTCTime -> CredentialScope
canonicalRequest :: Method -> Path -> Hash -> CanonicalQuery -> CanonicalHeaders -> SignedHeaders -> CanonicalRequest
escapedPath :: Request a -> Path
canonicalQuery :: QueryString -> CanonicalQuery
canonicalHeaders :: NormalisedHeaders -> CanonicalHeaders
signedHeaders :: NormalisedHeaders -> SignedHeaders
normaliseHeaders :: [Header] -> NormalisedHeaders
instance GHC.Show.Show a => GHC.Show.Show (Network.AWS.Sign.V4.Base.Tag s a)
instance Network.AWS.Data.Log.ToLog Network.AWS.Sign.V4.Base.V4
instance Network.AWS.Data.ByteString.ToByteString Network.AWS.Sign.V4.Base.CredentialScope
instance Network.AWS.Data.ByteString.ToByteString (Network.AWS.Sign.V4.Base.Tag s Data.ByteString.Internal.ByteString)
instance Network.AWS.Data.Log.ToLog (Network.AWS.Sign.V4.Base.Tag s Data.ByteString.Internal.ByteString)


module Network.AWS.Sign.V4.Chunked
chunked :: ChunkedBody -> Algorithm a


module Network.AWS.Sign.V4
data V4
V4 :: UTCTime -> Method -> Path -> Endpoint -> Credential -> CanonicalQuery -> CanonicalRequest -> CanonicalHeaders -> SignedHeaders -> StringToSign -> Signature -> [Header] -> Maybe Seconds -> V4
[$sel:metaTime:V4] :: V4 -> UTCTime
[$sel:metaMethod:V4] :: V4 -> Method
[$sel:metaPath:V4] :: V4 -> Path
[$sel:metaEndpoint:V4] :: V4 -> Endpoint
[$sel:metaCredential:V4] :: V4 -> Credential
[$sel:metaCanonicalQuery:V4] :: V4 -> CanonicalQuery
[$sel:metaCanonicalRequest:V4] :: V4 -> CanonicalRequest
[$sel:metaCanonicalHeaders:V4] :: V4 -> CanonicalHeaders
[$sel:metaSignedHeaders:V4] :: V4 -> SignedHeaders
[$sel:metaStringToSign:V4] :: V4 -> StringToSign
[$sel:metaSignature:V4] :: V4 -> Signature
[$sel:metaHeaders:V4] :: V4 -> [Header]
[$sel:metaTimeout:V4] :: V4 -> Maybe Seconds
v4 :: Signer


-- | This module contains functions for presigning requests using
--   <a>MonadIO</a> and not one of the AWS specific transformers.
--   
--   It is intended for use directly with <a>Network.AWS.Auth</a> when only
--   presigning and no other AWS actions are required.
module Network.AWS.Presign

-- | Presign an URL that is valid from the specified time until the number
--   of seconds expiry has elapsed.
--   
--   <i>See:</i> <a>presign</a>, <a>presignWith</a>
presignURL :: (MonadIO m, AWSRequest a) => Auth -> Region -> UTCTime -> Seconds -> a -> m ByteString

-- | Presign an HTTP request that is valid from the specified time until
--   the number of seconds expiry has elapsed.
--   
--   <i>See:</i> <a>presignWith</a>, <a>presignWithHeaders</a>
presign :: (MonadIO m, AWSRequest a) => Auth -> Region -> UTCTime -> Seconds -> a -> m ClientRequest

-- | A variant of <a>presign</a> that allows modifying the default
--   <a>Service</a> definition used to configure the request.
--   
--   <i>See:</i> <a>presignWithHeaders</a>
presignWith :: (MonadIO m, AWSRequest a) => (Service -> Service) -> Auth -> Region -> UTCTime -> Seconds -> a -> m ClientRequest

-- | Modification to the headers that is applied by default (in
--   <a>presignWith</a>); removes the <a>Expect</a> header which is added
--   to every <tt>PutObject</tt>.
defaultHeaders :: [Header] -> [Header]

-- | A variant of <a>presign</a> that allows modifying the default
--   <tt>Headers</tt> and the default <a>Service</a> definition used to
--   configure the request.
presignWithHeaders :: (MonadIO m, AWSRequest a) => ([Header] -> [Header]) -> (Service -> Service) -> Auth -> Region -> UTCTime -> Seconds -> a -> m ClientRequest


-- | This module provides simple <a>Env</a> and <a>IO</a>-based operations
--   which can be performed against remote Amazon Web Services APIs, for
--   use with the types supplied by the various <tt>amazonka-*</tt>
--   libraries.
module Network.AWS

-- | The environment containing the parameters required to make AWS
--   requests.
data Env
Env :: Region -> Logger -> (Int -> HttpException -> Bool) -> Dual (Endo Service) -> Manager -> Auth -> Env
[$sel:envRegion:Env] :: Env -> Region
[$sel:envLogger:Env] :: Env -> Logger
[$sel:envRetryCheck:Env] :: Env -> Int -> HttpException -> Bool
[$sel:envOverride:Env] :: Env -> Dual (Endo Service)
[$sel:envManager:Env] :: Env -> Manager
[$sel:envAuth:Env] :: Env -> Auth

-- | Creates a new environment with a new <tt>Manager</tt> without debug
--   logging and uses <a>getAuth</a> to expand/discover the supplied
--   <a>Credentials</a>. Lenses from <tt>AWSEnv</tt> can be used to further
--   configure the resulting <a>Env</a>.
--   
--   <i>Since:</i> <tt>1.5.0</tt> - The region is now retrieved from the
--   <tt>AWS_REGION</tt> environment variable (identical to official SDKs),
--   or defaults to <tt>us-east-1</tt>. You can override the <a>Env</a>
--   region by using <a>$sel:envRegion:Env</a>, or the current operation's
--   region by using <a>within</a>.
--   
--   <i>Since:</i> <tt>1.3.6</tt> - The default logic for retrying
--   <a>HttpException</a>s now uses <a>retryConnectionFailure</a> to retry
--   specific connection failure conditions up to 3 times. Previously only
--   service specific errors were automatically retried. This can be
--   reverted to the old behaviour by resetting the <a>Env</a> using
--   <a>$sel:envRetryCheck:Env</a> lens to <tt>(\_ _ -&gt; False)</tt>.
--   
--   Throws <a>AuthError</a> when environment variables or IAM profiles
--   cannot be read.
--   
--   <i>See:</i> <a>newEnvWith</a>.
newEnv :: MonadIO m => Credentials -> m Env

-- | <i>See:</i> <a>newEnv</a>
--   
--   The <a>Maybe</a> <a>Bool</a> parameter is used by the EC2 instance
--   check. By passing a value of <a>Nothing</a>, the check will be
--   performed. <a>Just</a> <a>True</a> would cause the check to be skipped
--   and the host treated as an EC2 instance.
--   
--   Throws <a>AuthError</a> when environment variables or IAM profiles
--   cannot be read.
newEnvWith :: MonadIO m => Credentials -> Manager -> m Env

-- | Provide a function which will be added to the existing stack of
--   overrides applied to all service configurations.
override :: (Service -> Service) -> Env -> Env

-- | Configure a specific service. All requests belonging to the supplied
--   service will use this configuration instead of the default.
--   
--   It's suggested you modify the default service configuration, such as
--   <tt>Network.AWS.DynamoDB.dynamoDB</tt>.
configure :: Service -> Env -> Env

-- | Scope an action within the specific <a>Region</a>.
within :: Region -> Env -> Env

-- | Scope an action such that any retry logic for the <a>Service</a> is
--   ignored and any requests will at most be sent once.
once :: Env -> Env

-- | Scope an action such that any HTTP response will use this timeout
--   value.
--   
--   Default timeouts are chosen by considering:
--   
--   <ul>
--   <li>This <a>timeout</a>, if set.</li>
--   <li>The related <a>Service</a> timeout for the sent request if set.
--   (Usually 70s)</li>
--   <li>The <a>$sel:envManager:Env</a> timeout if set.</li>
--   <li>The default <a>ClientRequest</a> timeout. (Approximately 30s)</li>
--   </ul>
timeout :: Seconds -> Env -> Env

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to
--   <a>resourceForkIO</a>. If multiple threads are sharing the same
--   collection of resources, only the last call to <tt>runResourceT</tt>
--   will deallocate the resources.
--   
--   <i>NOTE</i> Since version 1.2.0, this function will throw a
--   <a>ResourceCleanupException</a> if any of the cleanup functions throw
--   an exception.
runResourceT :: MonadUnliftIO m => ResourceT m a -> m a

-- | An access key ID.
--   
--   For example: <tt>AKIAIOSFODNN7EXAMPLE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype AccessKey
AccessKey :: ByteString -> AccessKey

-- | Secret access key credential.
--   
--   For example: <tt>wJalrXUtnFEMI<i>K7MDENG</i>bPxRfiCYEXAMPLEKE</tt>
--   
--   <i>See:</i> <a>Understanding and Getting Your Security
--   Credentials</a>.
newtype SecretKey
SecretKey :: ByteString -> SecretKey

-- | A session token used by STS to temporarily authorise access to an AWS
--   resource.
--   
--   <i>See:</i> <a>Temporary Security Credentials</a>.
newtype SessionToken
SessionToken :: ByteString -> SessionToken

-- | Determines how AuthN/AuthZ information is retrieved.
data Credentials

-- | Explicit access and secret keys. See <a>fromKeys</a>.
FromKeys :: AccessKey -> SecretKey -> Credentials

-- | Explicit access key, secret key and a session token. See
--   <a>fromSession</a>.
FromSession :: AccessKey -> SecretKey -> SessionToken -> Credentials

-- | Lookup specific environment variables for access key, secret key, an
--   optional session token, and an optional region, respectively.
FromEnv :: Text -> Text -> Maybe Text -> Maybe Text -> Credentials

-- | An IAM Profile name to lookup from the local EC2 instance-data.
--   Environment variables to lookup for the access key, secret key and
--   optional session token.
FromProfile :: Text -> Credentials

-- | A credentials profile name (the INI section), the path to the AWS
--   <a>credentials</a> file, and the path to the
--   <tt>~<i>.aws</i>config</tt> file.
FromFile :: Text -> FilePath -> FilePath -> Credentials

-- | Obtain credentials by attempting to contact the ECS container agent at
--   <a>http://169.254.170.2</a> using the path in
--   <a>envContainerCredentialsURI</a>. See <a>IAM Roles for Tasks</a> in
--   the AWS documentation for more information.
FromContainer :: Credentials

-- | Attempt credentials discovery via the following steps:
--   
--   <ul>
--   <li>Read the <a>envAccessKey</a>, <a>envSecretKey</a>, and
--   <a>envRegion</a> from the environment if they are set.</li>
--   <li>Read the credentials file if <a>credFile</a> exists.</li>
--   <li>Obtain credentials from the ECS container agent if
--   <a>envContainerCredentialsURI</a> is set.</li>
--   <li>Retrieve the first available IAM profile and read the
--   <a>Region</a> from the instance identity document, if running on
--   EC2.</li>
--   </ul>
--   
--   An attempt is made to resolve <a>http://instance-data</a> rather than
--   directly retrieving <a>http://169.254.169.254</a> for IAM profile
--   information. This assists in ensuring the DNS lookup terminates
--   promptly if not running on EC2.
Discover :: Credentials

-- | The available AWS regions.
newtype Region
Region' :: Text -> Region
[$sel:fromRegion:Region'] :: Region -> Text
pattern NorthVirginia :: Region
pattern Ohio :: Region
pattern NorthCalifornia :: Region
pattern Oregon :: Region
pattern GovCloudWest :: Region
pattern GovCloudEast :: Region
pattern Montreal :: Region
pattern SaoPaulo :: Region
pattern Frankfurt :: Region
pattern Ireland :: Region
pattern London :: Region
pattern Milan :: Region
pattern Paris :: Region
pattern Stockholm :: Region
pattern Bahrain :: Region
pattern CapeTown :: Region
pattern Beijing :: Region
pattern Ningxia :: Region
pattern HongKong :: Region
pattern Tokyo :: Region
pattern Seoul :: Region
pattern Osaka :: Region
pattern Singapore :: Region
pattern Sydney :: Region
pattern Mumbai :: Region
data Endpoint
Endpoint :: ByteString -> Bool -> Int -> ByteString -> Endpoint
[$sel:_endpointHost:Endpoint] :: Endpoint -> ByteString
[$sel:_endpointSecure:Endpoint] :: Endpoint -> Bool
[$sel:_endpointPort:Endpoint] :: Endpoint -> Int
[$sel:_endpointScope:Endpoint] :: Endpoint -> ByteString

-- | A convenience function for overriding the <a>Service</a>
--   <a>Endpoint</a>.
--   
--   <i>See:</i> <a>serviceEndpoint</a>.
setEndpoint :: Bool -> ByteString -> Int -> Service -> Service

-- | Send a request, returning the associated response if successful.
--   
--   Errors are thrown in <a>IO</a>.
--   
--   See <a>sendEither</a>.
send :: (MonadResource m, AWSRequest a) => Env -> a -> m (AWSResponse a)

-- | Send a request, returning the associated response if successful.
--   
--   See <a>send</a>.
sendEither :: (MonadResource m, AWSRequest a) => Env -> a -> m (Either Error (AWSResponse a))

-- | Repeatedly send a request, automatically setting markers and
--   performing pagination. Exits on the first encountered error.
--   
--   Errors are thrown in <a>IO</a>.
--   
--   See <a>paginateEither</a>.
paginate :: (MonadResource m, AWSPager a) => Env -> a -> ConduitM () (AWSResponse a) m ()

-- | Repeatedly send a request, automatically setting markers and
--   performing pagination.
--   
--   Exits on the first encountered error.
--   
--   See <a>paginate</a>.
paginateEither :: (MonadResource m, AWSPager a) => Env -> a -> ConduitM () (AWSResponse a) m (Either Error ())

-- | Poll the API with the supplied request until a specific <a>Wait</a>
--   condition is fulfilled.
--   
--   Errors are thrown in <a>IO</a>.
--   
--   See <a>awaitEither</a>.
await :: (MonadResource m, AWSRequest a) => Env -> Wait a -> a -> m Accept

-- | Poll the API with the supplied request until a specific <a>Wait</a>
--   condition is fulfilled.
--   
--   See <a>await</a>.
awaitEither :: (MonadResource m, AWSRequest a) => Env -> Wait a -> a -> m (Either Error Accept)

-- | Anything that can be converted to a streaming request <tt>Body</tt>.
class ToBody a

-- | Convert a value to a request body.
toBody :: ToBody a => a -> RequestBody

-- | Convert a value to a request body.
toBody :: (ToBody a, ToHashedBody a) => a -> RequestBody

-- | Invariant: only services that support _both_ standard and chunked
--   signing expose <a>RequestBody</a> as a parameter.
data RequestBody
Chunked :: ChunkedBody -> RequestBody
Hashed :: HashedBody -> RequestBody

-- | A streaming, exception safe response body.
newtype ResponseBody
ResponseBody :: ConduitM () ByteString (ResourceT IO) () -> ResponseBody
[$sel:_streamBody:ResponseBody] :: ResponseBody -> ConduitM () ByteString (ResourceT IO) ()

-- | Anything that can be safely converted to a <a>HashedBody</a>.
class ToHashedBody a

-- | Convert a value to a hashed request body.
toHashed :: ToHashedBody a => a -> HashedBody

-- | An opaque request body containing a <a>SHA256</a> hash.
data HashedBody
HashedStream :: Digest SHA256 -> !Integer -> ConduitM () ByteString (ResourceT IO) () -> HashedBody
HashedBytes :: Digest SHA256 -> ByteString -> HashedBody

-- | Construct a <a>HashedBody</a> from a <a>FilePath</a>, calculating the
--   <a>SHA256</a> hash and file size.
--   
--   <i>Note:</i> While this function will perform in constant space, it
--   will enumerate the entirety of the file contents _twice_. Firstly to
--   calculate the SHA256 and lastly to stream the contents to the socket
--   during sending.
--   
--   <i>See:</i> <a>ToHashedBody</a>.
hashedFile :: MonadIO m => FilePath -> m HashedBody

-- | Construct a <a>HashedBody</a> from a <a>FilePath</a>, specifying the
--   range of bytes to read. This can be useful for constructing multiple
--   requests from a single file, say for S3 multipart uploads.
--   
--   <i>See:</i> <a>hashedFile</a>, <a>sourceFileRange</a>.
hashedFileRange :: MonadIO m => FilePath -> Integer -> Integer -> m HashedBody

-- | Construct a <a>HashedBody</a> from a <tt>Source</tt>, manually
--   specifying the <a>SHA256</a> hash and file size. It's left up to the
--   caller to calculate these correctly, otherwise AWS will return signing
--   errors.
--   
--   <i>See:</i> <a>ToHashedBody</a>.
hashedBody :: Digest SHA256 -> Integer -> ConduitM () ByteString (ResourceT IO) () -> HashedBody

-- | An opaque request body which will be transmitted via
--   <tt>Transfer-Encoding: chunked</tt>.
--   
--   <i>Invariant:</i> Only services that support chunked encoding can
--   accept a <a>ChunkedBody</a>. (Currently S3.) This is enforced by the
--   type signatures emitted by the generator.
data ChunkedBody
ChunkedBody :: ChunkSize -> Integer -> ConduitM () ByteString (ResourceT IO) () -> ChunkedBody
[$sel:_chunkedSize:ChunkedBody] :: ChunkedBody -> ChunkSize
[$sel:_chunkedLength:ChunkedBody] :: ChunkedBody -> Integer
[$sel:_chunkedBody:ChunkedBody] :: ChunkedBody -> ConduitM () ByteString (ResourceT IO) ()

-- | Specifies the transmitted size of the 'Transfer-Encoding' chunks.
--   
--   <i>See:</i> <tt>defaultChunk</tt>.
newtype ChunkSize
ChunkSize :: Int -> ChunkSize

-- | The default chunk size of 128 KB. The minimum chunk size accepted by
--   AWS is 8 KB, unless the entirety of the request is below this
--   threshold.
--   
--   A chunk size of 64 KB or higher is recommended for performance
--   reasons.
defaultChunkSize :: ChunkSize

-- | Construct a <a>ChunkedBody</a> from a <a>FilePath</a>, where the
--   contents will be read and signed incrementally in chunks if the target
--   service supports it.
--   
--   Will intelligently revert to <a>HashedBody</a> if the file is smaller
--   than the specified <a>ChunkSize</a>.
--   
--   <i>See:</i> <a>ToBody</a>.
chunkedFile :: MonadIO m => ChunkSize -> FilePath -> m RequestBody

-- | Construct a <a>ChunkedBody</a> from a <a>FilePath</a>, specifying the
--   range of bytes to read. This can be useful for constructing multiple
--   requests from a single file, say for S3 multipart uploads.
--   
--   <i>See:</i> <a>chunkedFile</a>.
chunkedFileRange :: MonadIO m => ChunkSize -> FilePath -> Integer -> Integer -> m RequestBody

-- | Unsafely construct a <a>ChunkedBody</a>.
--   
--   This function is marked unsafe because it does nothing to enforce the
--   chunk size. Typically for conduit <a>IO</a> functions, it's whatever
--   ByteString's <tt>defaultBufferSize</tt> is, around 32 KB. If the chunk
--   size is less than 8 KB, the request will error. 64 KB or higher chunk
--   size is recommended for performance reasons.
--   
--   Note that it will always create a chunked body even if the request is
--   too small.
--   
--   <i>See:</i> <a>ToBody</a>.
unsafeChunkedBody :: ChunkSize -> Integer -> ConduitM () ByteString (ResourceT IO) () -> RequestBody

-- | Connect a <tt>Sink</tt> to a response stream.
sinkBody :: MonadIO m => ResponseBody -> ConduitM ByteString Void (ResourceT IO) a -> m a

-- | Convenience function for obtaining the size of a file.
getFileSize :: MonadIO m => FilePath -> m Integer

-- | Incrementally calculate a <tt>MD5</tt> <tt>Digest</tt>.
sinkMD5 :: Monad m => ConduitM ByteString o m (Digest MD5)

-- | Incrementally calculate a <tt>SHA256</tt> <tt>Digest</tt>.
sinkSHA256 :: Monad m => ConduitM ByteString o m (Digest SHA256)

-- | Presign an URL that is valid from the specified time until the number
--   of seconds expiry has elapsed.
presignURL :: (MonadIO m, AWSRequest a) => Env -> UTCTime -> Seconds -> a -> m ByteString

-- | Presign an HTTP request that is valid from the specified time until
--   the number of seconds expiry has elapsed.
presign :: (MonadIO m, AWSRequest a) => Env -> UTCTime -> Seconds -> a -> m ClientRequest
data Dynamic

-- | Value showing whether the customer has enabled detailed one-minute
--   monitoring in CloudWatch.
--   
--   Valid values: enabled | disabled.
FWS :: Dynamic

-- | JSON containing instance attributes, such as instance-id, private IP
--   address, etc. <i>See:</i> <a>identity</a>, <tt>InstanceDocument</tt>.
Document :: Dynamic

-- | Used to verify the document's authenticity and content against the
--   signature.
PKCS7 :: Dynamic
Signature :: Dynamic

-- | Retrieve the specified <tt>Dynamic</tt> data.
dynamic :: MonadIO m => Env -> Dynamic -> m ByteString
data Metadata

-- | The AMI ID used to launch the instance.
AMIId :: Metadata

-- | If you started more than one instance at the same time, this value
--   indicates the order in which the instance was launched. The value of
--   the first instance launched is 0.
AMILaunchIndex :: Metadata

-- | The path to the AMI's manifest file in Amazon S3. If you used an
--   Amazon EBS-backed AMI to launch the instance, the returned result is
--   unknown.
AMIManifestPath :: Metadata

-- | The AMI IDs of any instances that were rebundled to create this AMI.
--   This value will only exist if the AMI manifest file contained an
--   ancestor-amis key.
AncestorAMIIds :: Metadata

-- | See: <a>Mapping</a>
BlockDevice :: !Mapping -> Metadata

-- | The private hostname of the instance. In cases where multiple network
--   interfaces are present, this refers to the eth0 device (the device for
--   which the device number is 0).
Hostname :: Metadata

-- | See: <a>Info</a>
IAM :: !Info -> Metadata

-- | Notifies the instance that it should reboot in preparation for
--   bundling. Valid values: none | shutdown | bundle-pending.
InstanceAction :: Metadata

-- | The ID of this instance.
InstanceId :: Metadata

-- | The type of instance.
--   
--   See: <tt>InstanceType</tt>
InstanceType :: Metadata

-- | The ID of the kernel launched with this instance, if applicable.
KernelId :: Metadata

-- | The private DNS hostname of the instance. In cases where multiple
--   network interfaces are present, this refers to the eth0 device (the
--   device for which the device number is 0).
LocalHostname :: Metadata

-- | The private IP address of the instance. In cases where multiple
--   network interfaces are present, this refers to the eth0 device (the
--   device for which the device number is 0).
LocalIPV4 :: Metadata

-- | The instance's media access control (MAC) address. In cases where
--   multiple network interfaces are present, this refers to the eth0
--   device (the device for which the device number is 0).
MAC :: Metadata

-- | See: <a>Interface</a>
Network :: !Text -> !Interface -> Metadata

-- | The Availability Zone in which the instance launched.
AvailabilityZone :: Metadata

-- | Product codes associated with the instance, if any.
ProductCodes :: Metadata

-- | The instance's public DNS. If the instance is in a VPC, this category
--   is only returned if the enableDnsHostnames attribute is set to true.
--   For more information, see Using DNS with Your VPC.
PublicHostname :: Metadata

-- | The public IP address. If an Elastic IP address is associated with the
--   instance, the value returned is the Elastic IP address.
PublicIPV4 :: Metadata

-- | Public key. Only available if supplied at instance launch time.
OpenSSHKey :: Metadata

-- | The ID of the RAM disk specified at launch time, if applicable.
RAMDiskId :: Metadata

-- | ID of the reservation.
ReservationId :: Metadata

-- | The names of the security groups applied to the instance.
SecurityGroups :: Metadata

-- | Retrieve the specified <tt>Metadata</tt>.
metadata :: MonadIO m => Env -> Metadata -> m ByteString

-- | Retrieve the user data. Returns <a>Nothing</a> if no user data is
--   assigned to the instance.
userdata :: MonadIO m => Env -> m (Maybe ByteString)
class AsError a

-- | A general Amazonka error.
_Error :: AsError a => Prism' a Error

-- | An error occured while communicating over HTTP with a remote service.
_TransportError :: AsError a => Prism' a HttpException

-- | A serialisation error occured when attempting to deserialise a
--   response.
_SerializeError :: AsError a => Prism' a SerializeError

-- | A service specific error returned by the remote service.
_ServiceError :: AsError a => Prism' a ServiceError
class AsAuthError a

-- | A general authentication error.
_AuthError :: AsAuthError a => Prism' a AuthError

-- | An error occured while communicating over HTTP with the local metadata
--   endpoint.
_RetrievalError :: AsAuthError a => Prism' a HttpException

-- | The named environment variable was not found.
_MissingEnvError :: AsAuthError a => Prism' a Text

-- | An error occured parsing named environment variable's value.
_InvalidEnvError :: AsAuthError a => Prism' a Text

-- | The specified credentials file could not be found.
_MissingFileError :: AsAuthError a => Prism' a FilePath

-- | An error occured parsing the credentials file.
_InvalidFileError :: AsAuthError a => Prism' a Text

-- | The specified IAM profile could not be found or deserialised.
_InvalidIAMError :: AsAuthError a => Prism' a Text

-- | A variant of <a>try</a> that takes a <a>Prism</a> (or any <a>Fold</a>)
--   to select which exceptions are caught (c.f. <a>tryJust</a>,
--   <a>catchJust</a>). If the <a>Exception</a> does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | Catch exceptions that match a given <a>Prism</a> (or any <a>Fold</a>,
--   really).
--   
--   <pre>
--   &gt;&gt;&gt; catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -&gt; return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | Provides a generalised prism for catching a specific service error
--   identified by the opaque service abbreviation and error code.
--   
--   This can be used if the generated error prisms provided by
--   <tt>Network.AWS.<a>ServiceName</a>.Types</tt> do not cover all the
--   thrown error codes. For example to define a new error prism:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Network.AWS.S3 (ServiceError, s3)
--   
--   _NoSuchBucketPolicy :: AsError a =&gt; Getting (First ServiceError) a ServiceError
--   _NoSuchBucketPolicy = _MatchServiceError s3 "NoSuchBucketPolicy"
--   </pre>
--   
--   With example usage being:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Exception.Lens (trying)
--   
--   &gt;&gt;&gt; :t trying _NoSuchBucketPolicy
--   MonadCatch m =&gt; m a -&gt; m (Either ServiceError a)
--   </pre>
_MatchServiceError :: AsError a => Service -> ErrorCode -> Getting (First ServiceError) a ServiceError
hasService :: (Applicative f, Choice p) => Service -> Optic' p f ServiceError ServiceError
hasStatus :: (Applicative f, Choice p) => Int -> Optic' p f ServiceError ServiceError
hasCode :: (Applicative f, Choice p) => ErrorCode -> Optic' p f ServiceError ServiceError
data LogLevel

-- | Info messages supplied by the user - this level is not emitted by the
--   library.
Info :: LogLevel

-- | Error messages only.
Error :: LogLevel

-- | Useful debug information + info + error levels.
Debug :: LogLevel

-- | Includes potentially sensitive signing metadata, and non-streaming
--   response bodies.
Trace :: LogLevel

-- | A function threaded through various request and serialisation routines
--   to log informational and debug messages.
type Logger = LogLevel -> ByteStringBuilder -> IO ()

-- | This is a primitive logger which can be used to log builds to a
--   <tt>Handle</tt>.
--   
--   <i>Note:</i> A more sophisticated logging library such as
--   <a>tinylog</a> or <a>fast-logger</a> should be used in production
--   code.
newLogger :: MonadIO m => LogLevel -> Handle -> m Logger
