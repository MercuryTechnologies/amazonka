-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package libZSamazonka-s3-encryptionZSamazonka-s3-encryption
@version 2.0


module Amazonka.S3.Encryption.Body
class ToChunkedBody a
toChunked :: ToChunkedBody a => a -> ChunkedBody
enforceChunks :: Integral a => a -> ConduitT () ByteString (ResourceT IO) () -> ChunkedBody
instance Amazonka.S3.Encryption.Body.ToChunkedBody Amazonka.Data.Body.ChunkedBody
instance Amazonka.S3.Encryption.Body.ToChunkedBody Amazonka.Data.Body.HashedBody
instance Amazonka.S3.Encryption.Body.ToChunkedBody Amazonka.Data.Body.RequestBody


module Amazonka.S3.Encryption.Types

-- | An error thrown when performing encryption or decryption.
data EncryptionError

-- | Error initialising an AES cipher from a secret key.
CipherFailure :: CryptoError -> EncryptionError

-- | Failure performing asymmetric encryption/decryption.
PubKeyFailure :: Error -> EncryptionError

-- | Failure creating an IV from some bytes.
IVInvalid :: ByteString -> EncryptionError

-- | Required envelope field missing.
EnvelopeMissing :: CI Text -> EncryptionError

-- | Error parsing envelope.
EnvelopeInvalid :: CI Text -> String -> EncryptionError

-- | KMS error when retrieving decrypted plaintext.
PlaintextUnavailable :: EncryptionError
class AsEncryptionError r_anJg
_EncryptionError :: AsEncryptionError r_anJg => Prism' r_anJg EncryptionError
_CipherFailure :: AsEncryptionError r_anJg => Prism' r_anJg CryptoError
_PubKeyFailure :: AsEncryptionError r_anJg => Prism' r_anJg Error
_IVInvalid :: AsEncryptionError r_anJg => Prism' r_anJg ByteString
_EnvelopeMissing :: AsEncryptionError r_anJg => Prism' r_anJg (CI Text)
_EnvelopeInvalid :: AsEncryptionError r_anJg => Prism' r_anJg (CI Text, String)
_PlaintextUnavailable :: AsEncryptionError r_anJg => Prism' r_anJg ()
data ContentAlgorithm

-- | AES<i>CBC</i>PKCS5Padding
AES_CBC_PKCS5Padding :: ContentAlgorithm
data WrappingAlgorithm

-- | Key Management Service.
KMSWrap :: WrappingAlgorithm
data Location
Metadata :: Location
Discard :: Location

-- | An instructions file extension.
newtype Ext
Ext :: Text -> Ext

-- | Defaults to <tt>.instruction</tt>
defaultExtension :: Ext
appendExtension :: Ext -> ObjectKey -> ObjectKey

-- | A key material description. This is attached in plaintext to the
--   metadata, and will be logged using CloudTrail. For KMS decryption any
--   supplemental material description is merged with the description
--   stored on the object during decryption.
newtype Description
Description :: HashMap Text Text -> Description
[fromDescription] :: Description -> HashMap Text Text

-- | The key used for encryption and decryption.
data Key
Symmetric :: AES256 -> Description -> Key
Asymmetric :: KeyPair -> Description -> Key
KMS :: Text -> Description -> Key

-- | Modify the material description of a key.
--   
--   <i>See:</i> <a>Description</a>.
description :: Lens' Key Description
instance GHC.Classes.Eq Amazonka.S3.Encryption.Types.Location
instance Data.String.IsString Amazonka.S3.Encryption.Types.Ext
instance GHC.Show.Show Amazonka.S3.Encryption.Types.Ext
instance GHC.Classes.Eq Amazonka.S3.Encryption.Types.Ext
instance Data.Aeson.Types.ToJSON.ToJSON Amazonka.S3.Encryption.Types.Description
instance Data.Aeson.Types.FromJSON.FromJSON Amazonka.S3.Encryption.Types.Description
instance GHC.Base.Monoid Amazonka.S3.Encryption.Types.Description
instance GHC.Base.Semigroup Amazonka.S3.Encryption.Types.Description
instance GHC.Show.Show Amazonka.S3.Encryption.Types.Description
instance GHC.Classes.Eq Amazonka.S3.Encryption.Types.Description
instance Amazonka.Data.ByteString.ToByteString Amazonka.S3.Encryption.Types.Description
instance Amazonka.Data.Text.FromText Amazonka.S3.Encryption.Types.Description
instance Amazonka.Data.Text.FromText Amazonka.S3.Encryption.Types.WrappingAlgorithm
instance Amazonka.Data.ByteString.ToByteString Amazonka.S3.Encryption.Types.WrappingAlgorithm
instance Amazonka.Data.Text.FromText Amazonka.S3.Encryption.Types.ContentAlgorithm
instance Amazonka.Data.ByteString.ToByteString Amazonka.S3.Encryption.Types.ContentAlgorithm
instance Amazonka.S3.Encryption.Types.AsEncryptionError Amazonka.S3.Encryption.Types.EncryptionError
instance Amazonka.S3.Encryption.Types.AsEncryptionError GHC.Exception.Type.SomeException
instance GHC.Show.Show Amazonka.S3.Encryption.Types.EncryptionError
instance GHC.Classes.Eq Amazonka.S3.Encryption.Types.EncryptionError
instance GHC.Exception.Type.Exception Amazonka.S3.Encryption.Types.EncryptionError


module Amazonka.S3.Encryption.Envelope
data V1Envelope
V1Envelope :: !ByteString -> !IV AES256 -> !Description -> V1Envelope

-- | <tt>x-amz-key</tt>: Content encrypting key (cek) in encrypted form,
--   base64 encoded. The cek is randomly generated per S3 object, and is
--   always an AES 256-bit key. The corresponding cipher is always
--   <tt>AES<i>CBC</i>PKCS5Padding</tt>.
[_v1Key] :: V1Envelope -> !ByteString

-- | <tt>x-amz-iv</tt>: Randomly generated IV (per S3 object), base64
--   encoded.
[_v1IV] :: V1Envelope -> !IV AES256

-- | <tt>x-amz-matdesc</tt>: Customer provided material description in JSON
--   (UTF8) format.
[_v1Description] :: V1Envelope -> !Description
newV1 :: MonadIO m => (ByteString -> IO ByteString) -> Description -> m Envelope
decodeV1 :: MonadResource m => (ByteString -> IO ByteString) -> [(CI Text, Text)] -> m Envelope
data V2Envelope
V2Envelope :: !ByteString -> !IV AES256 -> !ContentAlgorithm -> !WrappingAlgorithm -> !Description -> V2Envelope

-- | <tt>x-amz-key-v2</tt>: CEK in key wrapped form. This is necessary so
--   that the S3 encryption client that doesn't recognize the v2 format
--   will not mistakenly decrypt S3 object encrypted in v2 format.
[_v2Key] :: V2Envelope -> !ByteString

-- | <tt>x-amz-iv</tt>: Randomly generated IV (per S3 object), base64
--   encoded.
[_v2IV] :: V2Envelope -> !IV AES256

-- | <tt>x-amz-cek-alg</tt>: Content encryption algorithm used. Supported
--   values: <tt>AES<i>GCM</i>NoPadding</tt>,
--   <tt>AES<i>CBC</i>PKCS5Padding</tt> Default to
--   <tt>AES<i>CBC</i>PKCS5Padding</tt> if this key is absent.
--   
--   Supported values: <tt>AESWrap</tt>,
--   <tt>RSA<i>ECB</i>OAEPWithSHA-256AndMGF1Padding</tt>, <tt>kms</tt> No
--   standard key wrapping is used if this meta information is absent
--   Always set to <tt>kms</tt> if KMS is used for client-side encryption
[_v2CEKAlgorithm] :: V2Envelope -> !ContentAlgorithm

-- | <tt>x-amz-wrap-alg</tt>: Key wrapping algorithm used.
[_v2WrapAlgorithm] :: V2Envelope -> !WrappingAlgorithm

-- | <tt>x-amz-matdesc</tt>: Customer provided material description in JSON
--   format. Used to identify the client-side master key. For KMS client
--   side encryption, the KMS Customer Master Key ID is stored as part of
--   the material description, <tt>x-amz-matdesc, under the key-name
--   </tt>kms_cmk_id@.
[_v2Description] :: V2Envelope -> !Description
newV2 :: MonadResource m => Text -> Env -> Description -> m Envelope
decodeV2 :: MonadResource m => Env -> [(CI Text, Text)] -> Description -> m Envelope
data Envelope
V1 :: AES256 -> V1Envelope -> Envelope
V2 :: AES256 -> V2Envelope -> Envelope
toMetadata :: Envelope -> [(CI ByteString, ByteString)]
newEnvelope :: MonadResource m => Key -> Env -> m Envelope
decodeEnvelope :: MonadResource m => Key -> Env -> [(CI Text, Text)] -> m Envelope
fromMetadata :: MonadResource m => Key -> Env -> HashMap Text Text -> m Envelope
aesKeySize :: Int
aesBlockSize :: Int
bodyEncrypt :: Envelope -> RequestBody -> RequestBody
bodyDecrypt :: Envelope -> ResponseBody -> ResponseBody
aesCbc :: Monad m => IV AES256 -> (IV AES256 -> ByteString -> (IV AES256, ByteString)) -> (IV AES256 -> ByteString -> ByteString) -> ConduitT ByteString ByteString m ()
rsaEncrypt :: KeyPair -> ByteString -> IO ByteString
rsaDecrypt :: KeyPair -> ByteString -> IO ByteString
getCipher :: Envelope -> (AES256, IV AES256)
createCipher :: (MonadIO m, ByteArray a, Cipher b) => a -> m b
createIV :: (MonadIO m, BlockCipher a) => ByteString -> m (IV a)
plaintext :: MonadIO m => DecryptResponse -> m ByteString
(.&) :: (MonadIO m, FromText a) => [(CI Text, Text)] -> CI Text -> m a
hoistEither :: MonadIO m => Either EncryptionError a -> m a
throwIO :: MonadIO m => EncryptionError -> m a
instance Amazonka.Data.Headers.ToHeaders Amazonka.S3.Encryption.Envelope.Envelope
instance Data.Aeson.Types.ToJSON.ToJSON Amazonka.S3.Encryption.Envelope.Envelope
instance Amazonka.Data.Body.ToBody Amazonka.S3.Encryption.Envelope.Envelope


module Amazonka.S3.Encryption.Instructions
newtype Instructions
Instructions :: (forall m. MonadResource m => Key -> Env -> m Envelope) -> Instructions
[runInstructions] :: Instructions -> forall m. MonadResource m => Key -> Env -> m Envelope
class AWSRequest a => AddInstructions a

-- | Determine the bucket and key an instructions file is adjacent to.
addInstructions :: AddInstructions a => a -> (BucketName, ObjectKey)
data PutInstructions
PutInstructions :: Ext -> PutObject -> PutInstructions
[_piExt] :: PutInstructions -> Ext
[_piPut] :: PutInstructions -> PutObject
putInstructions :: AddInstructions a => a -> Envelope -> PutInstructions
piExtension :: Lens' PutInstructions Ext
data GetInstructions
GetInstructions :: Ext -> GetObject -> GetInstructions
[_giExt] :: GetInstructions -> Ext
[_giGet] :: GetInstructions -> GetObject
getInstructions :: AddInstructions a => a -> GetInstructions
giExtension :: Lens' GetInstructions Ext
class AWSRequest a => RemoveInstructions a

-- | Determine the bucket and key an instructions file is adjacent to.
removeInstructions :: RemoveInstructions a => a -> (BucketName, ObjectKey)
data DeleteInstructions
DeleteInstructions :: Ext -> DeleteObject -> DeleteInstructions
[_diExt] :: DeleteInstructions -> Ext
[_diDelete] :: DeleteInstructions -> DeleteObject
deleteInstructions :: RemoveInstructions a => a -> DeleteInstructions
diExtension :: Lens' DeleteInstructions Ext
instance GHC.Show.Show Amazonka.S3.Encryption.Instructions.PutInstructions
instance GHC.Show.Show Amazonka.S3.Encryption.Instructions.GetInstructions
instance GHC.Show.Show Amazonka.S3.Encryption.Instructions.DeleteInstructions
instance Amazonka.Types.AWSRequest Amazonka.S3.Encryption.Instructions.DeleteInstructions
instance Amazonka.S3.Encryption.Instructions.RemoveInstructions Amazonka.S3.AbortMultipartUpload.AbortMultipartUpload
instance Amazonka.S3.Encryption.Instructions.RemoveInstructions Amazonka.S3.DeleteObject.DeleteObject
instance Amazonka.Types.AWSRequest Amazonka.S3.Encryption.Instructions.GetInstructions
instance Amazonka.Types.AWSRequest Amazonka.S3.Encryption.Instructions.PutInstructions
instance Amazonka.S3.Encryption.Instructions.AddInstructions Amazonka.S3.PutObject.PutObject
instance Amazonka.S3.Encryption.Instructions.AddInstructions Amazonka.S3.GetObject.GetObject
instance Amazonka.S3.Encryption.Instructions.AddInstructions Amazonka.S3.CreateMultipartUpload.CreateMultipartUpload
instance Amazonka.S3.Encryption.Instructions.AddInstructions Amazonka.S3.UploadPart.UploadPart


module Amazonka.S3.Encryption.Encrypt

-- | Note about how it doesn't attach metadata by default. You can re-set
--   the location and then discard the PutInstructions request.
encrypted :: (MonadResource m, ToEncrypted a) => Key -> Env -> a -> m (Encrypted a, PutInstructions)
encryptPart :: Encrypted CreateMultipartUpload -> UploadPart -> Encrypted UploadPart
data Encrypted a
Encrypted :: a -> [Header] -> Location -> Envelope -> Encrypted a
[_encPayload] :: Encrypted a -> a
[_encHeaders] :: Encrypted a -> [Header]
[_encLocation] :: Encrypted a -> Location
[_encEnvelope] :: Encrypted a -> Envelope
location :: Setter' (Encrypted a) Location
envelope :: Encrypted a -> Envelope
proxy :: forall a. Proxy (Encrypted a) -> Proxy a
class AddInstructions a => ToEncrypted a

-- | Create an encryption context.
encryptWith :: ToEncrypted a => a -> Location -> Envelope -> Encrypted a
instance Amazonka.S3.Encryption.Encrypt.ToEncrypted Amazonka.S3.CreateMultipartUpload.CreateMultipartUpload
instance Amazonka.S3.Encryption.Encrypt.ToEncrypted Amazonka.S3.PutObject.PutObject
instance Amazonka.S3.Encryption.Encrypt.ToEncrypted Amazonka.S3.UploadPart.UploadPart
instance Amazonka.Types.AWSRequest a => Amazonka.Types.AWSRequest (Amazonka.S3.Encryption.Encrypt.Encrypted a)


module Amazonka.S3.Encryption.Decrypt
decrypted :: GetObject -> (Decrypt GetObject, GetInstructions)
newtype Decrypt a
Decrypt :: a -> Decrypt a
newtype Decrypted a
Decrypted :: (forall m. MonadResource m => Key -> Env -> Maybe Envelope -> m a) -> Decrypted a
[runDecrypted] :: Decrypted a -> forall m. MonadResource m => Key -> Env -> Maybe Envelope -> m a
proxy :: forall a. Proxy (Decrypt a) -> Proxy a
instance Amazonka.Types.AWSRequest (Amazonka.S3.Encryption.Decrypt.Decrypt Amazonka.S3.GetObject.GetObject)


-- | Addons for <a>amazonka-s3</a> to support client-side encryption.
--   
--   Your client-side master keys and your unencrypted data are never sent
--   to AWS; therefore, it is important that you safely manage your
--   encryption keys. If you lose them, you won't be able to decrypt your
--   data. When generating a symmetric key, you should ensure that the key
--   length is compatible with the underlying <tt>AES256</tt> cipher.
--   
--   The encryption procedure is:
--   
--   <ul>
--   <li>A one-time-use symmetric key a.k.a. a data encryption key (or data
--   key) and initialisation vector (IV) are generated locally. This data
--   key and IV are used to encrypt the data of a single S3 object using an
--   AES256 cipher in CBC mode, with PKCS5 padding. (For each object sent,
--   a completely separate data key and IV are generated.)</li>
--   <li>The generated data encryption key used above is encrypted using a
--   symmetric AES256 cipher in ECB mode, asymmetric RSA, or KMS
--   facilities, depending on the client-side master key you provide.</li>
--   <li>The encrypted data is uploaded and the encrypted data key and
--   material description are attached as object metadata (either headers
--   or a separate instruction file). If KMS is used, the material
--   description helps determine which client-side master key to later use
--   for decryption, otherwise the configured client-side key at time of
--   decryption is used.</li>
--   </ul>
--   
--   For decryption:
--   
--   The encrypted object is downloaded from Amazon S3 along with any
--   metadata. If KMS was used to encrypt the data then the master key id
--   is taken from the metadata material description, otherwise the
--   client-side master key in the current environment is used to decrypt
--   the data key, which in turn is used to decrypt the object data.
--   
--   The client-side master key you provide can be either a symmetric key,
--   an asymmetric public/private key pair, or a KMS master key.
--   
--   The stored metadata format is designed to be compatible with the
--   official Java AWS SDK (both V1 and V2 envelopes), but only a limited
--   set of the possible encryption options are supported. Therefore
--   assuming defaults, objects stored with this library should be
--   retrievable by any of the other official SDKs, and vice versa.
module Amazonka.S3.Encryption

-- | The key used for encryption and decryption.
data Key
Symmetric :: AES256 -> Description -> Key
Asymmetric :: KeyPair -> Description -> Key
KMS :: Text -> Description -> Key

-- | Specify a KMS master key to use, with an initially empty material
--   description.
--   
--   <i>See:</i> <a>description</a>, <tt>material</tt>.
kmsKey :: Text -> Key

-- | Specify the asymmetric key used for RSA encryption.
--   
--   <i>See:</i> <a>description</a>, <tt>material</tt>.
asymmetricKey :: PrivateKey -> Key

-- | Specify the shared secret to use for symmetric key encryption. This
--   must be compatible with the AES256 key size, 32 bytes.
--   
--   Throws <a>EncryptionError</a>, specifically <a>CipherFailure</a>.
--   
--   <i>See:</i> <a>newSecret</a>, <a>description</a>, <tt>material</tt>.
symmetricKey :: MonadIO m => ByteString -> m Key

-- | Generate a random shared secret that is of the correct length to use
--   with <a>symmetricKey</a>. This will need to be stored securely to
--   enable decryption of any requests that are encrypted using this
--   secret.
newSecret :: MonadRandom m => m ByteString

-- | Encrypt an object, storing the encryption envelope in
--   <tt>x-amz-meta-*</tt> headers.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
encrypt :: MonadResource m => Key -> Env -> PutObject -> m PutObjectResponse

-- | Retrieve an object, parsing the envelope from any
--   <tt>x-amz-meta-*</tt> headers and decrypting the response body.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
decrypt :: MonadResource m => Key -> Env -> GetObject -> m GetObjectResponse

-- | Initiate an encrypted multipart upload, storing the encryption
--   envelope in the <tt>x-amz-meta-*</tt> headers.
--   
--   The returned <a>UploadPart</a> <tt>-&gt;</tt> <a>Encrypted</a>
--   <a>UploadPart</a> function is used to encrypt each part of the object.
--   The same caveats for multipart upload apply, it is assumed that each
--   part is uploaded in order and each part needs to be individually
--   encrypted.
--   
--   For example:
--   
--   <pre>
--   (a', f) &lt;- initiate (a :: CreateMultipartUpload)
--   b'      &lt;- send (f b :: Encrypted UploadPart)
--   </pre>
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
initiate :: MonadResource m => Key -> Env -> CreateMultipartUpload -> m (CreateMultipartUploadResponse, UploadPart -> Encrypted UploadPart)

-- | Encrypt an object, storing the encryption envelope in an adjacent
--   instruction file with the same <a>ObjectKey</a> and
--   <a>defaultExtension</a>. This makes two HTTP requests, storing the
--   instruction file first and upon success, storing the actual object.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
encryptInstructions :: MonadResource m => Key -> Env -> PutObject -> m PutObjectResponse

-- | Retrieve an object and its adjacent instruction file. The instruction
--   are retrieved and parsed first. Performs two HTTP requests.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
decryptInstructions :: MonadResource m => Key -> Env -> GetObject -> m GetObjectResponse

-- | Initiate an encrypted multipart upload, storing the encryption
--   envelope in an adjacent instruction file with the same
--   <a>ObjectKey</a> and <a>defaultExtension</a>.
--   
--   The returned <a>UploadPart</a> <tt>-&gt;</tt> <a>Encrypted</a>
--   <a>UploadPart</a> function is used to encrypt each part of the object.
--   The same caveats for multipart upload apply, it is assumed that each
--   part is uploaded in order and each part needs to be individually
--   encrypted.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
initiateInstructions :: MonadResource m => Key -> Env -> CreateMultipartUpload -> m (CreateMultipartUploadResponse, UploadPart -> Encrypted UploadPart)

-- | Given a request to execute, such as <a>AbortMultipartUpload</a> or
--   <a>DeleteObject</a>, remove the adjacent instruction file, if it
--   exists with the <a>defaultExtension</a>. Performs two HTTP requests.
--   
--   Throws <a>EncryptionError</a>, <a>Error</a>.
cleanupInstructions :: (MonadResource m, RemoveInstructions a) => Env -> a -> m (AWSResponse a)

-- | An instructions file extension.
newtype Ext
Ext :: Text -> Ext

-- | Defaults to <tt>.instruction</tt>
defaultExtension :: Ext

-- | An error thrown when performing encryption or decryption.
data EncryptionError

-- | Error initialising an AES cipher from a secret key.
CipherFailure :: CryptoError -> EncryptionError

-- | Failure performing asymmetric encryption/decryption.
PubKeyFailure :: Error -> EncryptionError

-- | Failure creating an IV from some bytes.
IVInvalid :: ByteString -> EncryptionError

-- | Required envelope field missing.
EnvelopeMissing :: CI Text -> EncryptionError

-- | Error parsing envelope.
EnvelopeInvalid :: CI Text -> String -> EncryptionError

-- | KMS error when retrieving decrypted plaintext.
PlaintextUnavailable :: EncryptionError
class AsEncryptionError r_anJg
_EncryptionError :: AsEncryptionError r_anJg => Prism' r_anJg EncryptionError
_CipherFailure :: AsEncryptionError r_anJg => Prism' r_anJg CryptoError
_PubKeyFailure :: AsEncryptionError r_anJg => Prism' r_anJg Error
_IVInvalid :: AsEncryptionError r_anJg => Prism' r_anJg ByteString
_EnvelopeMissing :: AsEncryptionError r_anJg => Prism' r_anJg (CI Text)
_EnvelopeInvalid :: AsEncryptionError r_anJg => Prism' r_anJg (CI Text, String)
_PlaintextUnavailable :: AsEncryptionError r_anJg => Prism' r_anJg ()
