-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package libZSamazonka-testZSamazonka-test
@version 2.0


module Test.AWS.Diff

-- | Display the difference between two Haskell values, with control over
--   the diff parameters.
diff :: (Show a, Show b) => a -> b -> IO String


module Test.AWS.Orphans
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Internal.ByteString


module Test.AWS.Assert
assertDiff :: (Eq a, Show a) => String -> a -> Either String a -> Assertion


module Test.AWS.TH
mkTime :: Text -> Q Exp
instance Language.Haskell.TH.Syntax.Lift (Network.AWS.Data.Time.Time a)
instance Language.Haskell.TH.Syntax.Lift Data.Time.Clock.Internal.UTCTime.UTCTime
instance Language.Haskell.TH.Syntax.Lift Data.Time.Calendar.Days.Day
instance Language.Haskell.TH.Syntax.Lift Data.Time.Clock.Internal.DiffTime.DiffTime


module Test.AWS.Prelude

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice (p :: Type -> Type -> Type)

-- | A variant of <a>throwing</a> that can only be used within the
--   <tt>IO</tt> <a>Monad</a> (or any other <a>MonadCatch</a> instance) to
--   throw an <a>Exception</a> described by a <a>Prism</a>.
--   
--   Although <a>throwingM</a> has a type that is a specialization of the
--   type of <a>throwing</a>, the two functions are subtly different:
--   
--   <pre>
--   <a>throwing</a> l e `seq` x  ≡ <a>throwing</a> e
--   <a>throwingM</a> l e `seq` x ≡ x
--   </pre>
--   
--   The first example will cause the <a>Exception</a> <tt>e</tt> to be
--   raised, whereas the second one won't. In fact, <a>throwingM</a> will
--   only cause an <a>Exception</a> to be raised when it is used within the
--   <a>MonadCatch</a> instance. The <a>throwingM</a> variant should be
--   used in preference to <a>throwing</a> to raise an <a>Exception</a>
--   within the <a>Monad</a> because it guarantees ordering with respect to
--   other monadic operations, whereas <a>throwing</a> does not.
--   
--   <pre>
--   <a>throwingM</a> l ≡ <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m r
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m r
--   </pre>
throwingM :: MonadThrow m => AReview SomeException b -> b -> m r

-- | A variant of <a>try</a> that takes a <a>Prism</a> (or any <a>Fold</a>)
--   to select which exceptions are caught (c.f. <a>tryJust</a>,
--   <a>catchJust</a>). If the <a>Exception</a> does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particularly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   &gt;&gt;&gt; catching_ _AssertionFailed (assert False (return "uncaught")) $ return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any <a>Fold</a>,
--   really).
--   
--   <pre>
--   &gt;&gt;&gt; catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -&gt; return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | Traverse the strongly typed <a>Exception</a> contained in
--   <a>SomeException</a> where the type of your function matches the
--   desired <a>Exception</a>.
--   
--   <pre>
--   <a>exception</a> :: (<a>Applicative</a> f, <a>Exception</a> a)
--             =&gt; (a -&gt; f a) -&gt; <a>SomeException</a> -&gt; f <a>SomeException</a>
--   </pre>
exception :: Exception a => Prism' SomeException a

-- | Unfortunately the name <tt>ioException</tt> is taken by <tt>base</tt>
--   for throwing IOExceptions.
--   
--   <pre>
--   <a>_IOException</a> :: <a>Prism'</a> <a>IOException</a> <a>IOException</a>
--   <a>_IOException</a> :: <a>Prism'</a> <a>SomeException</a> <a>IOException</a>
--   </pre>
--   
--   Many combinators for working with an <a>IOException</a> are available
--   in <a>System.IO.Error.Lens</a>.
_IOException :: AsIOException t => Prism' t IOException

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList "abcde" &amp; _last .~ 'Q') == Vector.fromList "abcdQ"
--   True
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a

-- | Data types that are representationally equal are isomorphic.
--   
--   This is only available on GHC 7.8+
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; fromList [("hello",fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: forall (f :: Type -> Type) (g :: Type -> Type) s t a b. (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g) ≡ f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g)) ≡ g
--   <a>over</a> (<a>iso</a> f g) h ≡ g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h ≡ f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: forall (f :: Type -> Type) a b. Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees. This is because <a>^?</a> works by using the
--   <a>First</a> monoid, which can occasionally cause space leaks.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   This operator works as an infix version of <a>preview</a>.
--   
--   <pre>
--   (<a>^?</a>) ≡ <a>flip</a> <a>preview</a>
--   </pre>
--   
--   It may be helpful to think of <a>^?</a> as having one of the following
--   more specialized types:
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a
infixl 8 ^?

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a> ≡ <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a> ≡ <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l ≡ <a>anyOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..id
--   [[[1,2],[3]]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse
--   [[1,2],[3]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs ≡ xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>a</a> :: s -&gt; <a>Fold</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Lens'</a> s a      -&gt; <a>a</a> :: s -&gt; <a>Iso'</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Traversal'</a> s a -&gt; <a>a</a> :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | Obtain a <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that fails the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding tail
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a> ≡ m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x ≡ f x
--   l # x ≡ x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = a -> Const r a -> s -> Const r s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Modify the target of a <a>Semigroup</a> value by using
--   <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
infixr 4 <>~

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t ≡ <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <a>?~</a> can be used type-changily:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', ('b', 'c')) &amp; _2.both ?~ 'x'
--   ('a',(Just 'x',Just 'x'))
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged :: Type -> Type -> Type Identity t b

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall (f :: Type -> Type). (Contravariant f, Functor f) => a -> f a -> s -> f s

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall (f :: Type -> Type). (Contravariant f, Applicative f) => a -> f a -> s -> f s

-- | <pre>
--   type <a>Optic'</a> p f s a = <a>Simple</a> (<a>Optic</a> p f) s a
--   </pre>
type Optic' (p :: k -> k1 -> Type) (f :: k -> k1) (s :: k) (a :: k) = Optic p f s s a a

-- | Create a named group of test cases or other groups
testGroup :: TestName -> [TestTree] -> TestTree

-- | The main data structure defining a test suite.
--   
--   It consists of individual test cases and properties, organized in
--   named groups which form a tree-like hierarchy.
--   
--   There is no generic way to create a test case. Instead, every test
--   provider (tasty-hunit, tasty-smallcheck etc.) provides a function to
--   turn a test case into a <a>TestTree</a>.
--   
--   Groups can be created using <a>testGroup</a>.
data TestTree

-- | Turn an <a>Assertion</a> into a tasty test case
testCase :: TestName -> Assertion -> TestTree
assertDiff :: (Eq a, Show a) => String -> a -> Either String a -> Assertion
mkTime :: Text -> Q Exp


module Test.AWS.Fixture
res :: (AWSRequest a, Eq (AWSResponse a), Show (AWSResponse a)) => TestName -> FilePath -> Service -> Proxy a -> AWSResponse a -> TestTree
req :: (AWSRequest a, Eq a, Show a) => TestName -> FilePath -> a -> TestTree
testResponse :: forall a. AWSRequest a => Service -> Proxy a -> ByteStringLazy -> IO (Either String (AWSResponse a))
auth :: AuthEnv
time :: UTCTime
data Req
Req :: Method -> ByteString -> ByteString -> [Header] -> ByteString -> Req
[_method] :: Req -> Method
[_path] :: Req -> ByteString
[_query] :: Req -> ByteString
[_headers] :: Req -> [Header]
[_body] :: Req -> ByteString
mkReq :: Method -> ByteString -> ByteString -> [Header] -> ByteString -> Req
sortKeys :: Ord a => [(a, b)] -> [(a, b)]
instance GHC.Generics.Generic Test.AWS.Fixture.Req
instance GHC.Show.Show Test.AWS.Fixture.Req
instance GHC.Classes.Eq Test.AWS.Fixture.Req
instance Data.Aeson.Types.FromJSON.FromJSON Test.AWS.Fixture.Req
